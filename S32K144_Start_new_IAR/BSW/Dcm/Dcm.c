/**********************************************************************************************************************
 *  COPYRIGHT
 *  -------------------------------------------------------------------------------------------------------------------
 *  \verbatim
 *  Copyright (c) 2018 by Vector Informatik GmbH.                                             All rights reserved.
 *
 *                This software is copyright protected and proprietary to Vector Informatik GmbH.
 *                Vector Informatik GmbH grants to you only those rights as set out in the license conditions.
 *                All other rights remain with Vector Informatik GmbH.
 *  \endverbatim
 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -----------------------------------------------------------------------------------------------------------------*/
/**        \file  Dcm.c
 *        \brief  Implementation of DCM core
 *
 *      \details  MICROSAR DCM based on AR 4.0.3
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 *  REVISION HISTORY
 *  -------------------------------------------------------------------------------------------------------------------
 *  Refer to the module's header file.
 *
 *  FILE VERSION
 *  -------------------------------------------------------------------------------------------------------------------
 *  Refer to the VERSION CHECK below.
 *********************************************************************************************************************/
#define DCM_SOURCE
/* ----------------------------------------------
 ~&&&   Includes
---------------------------------------------- */
                                                                                                                                                     /* PRQA S 0857, 0828 EOF */ /* MD_MSR_1.1_857, MD_MSR_1.1_828 */
#include "Dcm.h"
#include "Rte_Dcm.h"
#include "SchM_Dcm.h"
#if ((DCM_UTI_NVM_READ_ENABLED == STD_ON) || \
    (DCM_UTI_NVM_WRITE_ENABLED == STD_ON))
# include "NvM.h"
#endif /* ((DCM_UTI_NVM_READ_ENABLED == STD_ON) || \
 (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)) */
#if (DCM_DEV_ERROR_REPORT == STD_ON)
# include "Det.h"
#endif /* (DCM_DEV_ERROR_REPORT == STD_ON) */
#include "PduR_Dcm.h"
#include "ComM_Dcm.h"
#if (((DCM_MODE_ECU_RESET_ENABLED == STD_ON) || (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)) && (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) || \
    (DCM_DIAG_NOTIF_BSWM_APPL_UPDATED_ENABLED == STD_ON) || \
    (DCM_SVC_28_SUPPORT_ENABLED == STD_ON))
# include "BswM_Dcm.h"
#endif /* (((DCM_MODE_ECU_RESET_ENABLED == STD_ON) || (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)) && (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) || \
 (DCM_DIAG_NOTIF_BSWM_APPL_UPDATED_ENABLED == STD_ON) || \
 (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)) */
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# include "EcuM_Error.h"
#endif /* (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON) */
#if (((DCM_SVC_02_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)) && ((DCM_DEM_API_403_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON)))                         /* COV_DCM_SUPPORT_PARTIALLY TF tf tf tf tf tf tf tf tf xf tf */
# include "Dem.h"
#endif /* (((DCM_SVC_02_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)) && ((DCM_DEM_API_403_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON))) */
#if (((DCM_SVC_02_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)) && ((DCM_DEM_API_412_ENABLED == STD_ON) || (DCM_DEM_API_421_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON)))
# include "Dem_Dcm.h"
#endif /* (((DCM_SVC_02_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)) && ((DCM_DEM_API_412_ENABLED == STD_ON) || (DCM_DEM_API_421_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON))) */
#include "Dcm_Int.h"
/* ----------------------------------------------
 ~&&&   Versions
---------------------------------------------- */
#if ((DCM_SW_MAJOR_VERSION != 10u) || \
    (DCM_SW_MINOR_VERSION !=  4u) || \
    (DCM_SW_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm.h are inconsistent"
#endif
#if ((DCM_CBK_MAJOR_VERSION != 10u) || \
    (DCM_CBK_MINOR_VERSION !=  4u) || \
    (DCM_CBK_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Cbk.h are inconsistent"
#endif
#if ((DCM_TYPES_MAJOR_VERSION != 10u) || \
    (DCM_TYPES_MINOR_VERSION !=  4u) || \
    (DCM_TYPES_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Types.h are inconsistent"
#endif
#if ((DCM_INT_MAJOR_VERSION != 10u) || \
    (DCM_INT_MINOR_VERSION !=  4u) || \
    (DCM_INT_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Int.h are inconsistent"
#endif
#if ((DCM_BASE_MAJOR_VERSION != 10u) || \
    (DCM_BASE_MINOR_VERSION !=  4u) || \
    (DCM_BASE_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Base.h are inconsistent"
#endif
#if ((DCM_BASECBK_MAJOR_VERSION != 10u) || \
    (DCM_BASECBK_MINOR_VERSION !=  4u) || \
    (DCM_BASECBK_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_BaseCbk.h are inconsistent"
#endif
#if ((DCM_BASETYPES_MAJOR_VERSION != 10u) || \
    (DCM_BASETYPES_MINOR_VERSION !=  4u) || \
    (DCM_BASETYPES_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_BaseTypes.h are inconsistent"
#endif
#if ((DCM_BASEINT_MAJOR_VERSION != 10u) || \
    (DCM_BASEINT_MINOR_VERSION !=  4u) || \
    (DCM_BASEINT_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_BaseInt.h are inconsistent"
#endif
#if ((DCM_CORE_MAJOR_VERSION != 10u) || \
    (DCM_CORE_MINOR_VERSION !=  4u) || \
    (DCM_CORE_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Core.h are inconsistent"
#endif
#if ((DCM_CORECBK_MAJOR_VERSION != 10u) || \
    (DCM_CORECBK_MINOR_VERSION !=  4u) || \
    (DCM_CORECBK_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_CoreCbk.h are inconsistent"
#endif
#if ((DCM_CORETYPES_MAJOR_VERSION != 10u) || \
    (DCM_CORETYPES_MINOR_VERSION !=  4u) || \
    (DCM_CORETYPES_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_CoreTypes.h are inconsistent"
#endif
#if ((DCM_COREINT_MAJOR_VERSION != 10u) || \
    (DCM_COREINT_MINOR_VERSION !=  4u) || \
    (DCM_COREINT_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_CoreInt.h are inconsistent"
#endif
#if ((DCM_EXT_MAJOR_VERSION != 10u) || \
    (DCM_EXT_MINOR_VERSION !=  4u) || \
    (DCM_EXT_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Ext.h are inconsistent"
#endif
#if ((DCM_EXTCBK_MAJOR_VERSION != 10u) || \
    (DCM_EXTCBK_MINOR_VERSION !=  4u) || \
    (DCM_EXTCBK_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_ExtCbk.h are inconsistent"
#endif
#if ((DCM_EXTTYPES_MAJOR_VERSION != 10u) || \
    (DCM_EXTTYPES_MINOR_VERSION !=  4u) || \
    (DCM_EXTTYPES_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_ExtTypes.h are inconsistent"
#endif
#if ((DCM_EXTINT_MAJOR_VERSION != 10u) || \
    (DCM_EXTINT_MINOR_VERSION !=  4u) || \
    (DCM_EXTINT_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_ExtInt.h are inconsistent"
#endif
#if ((DCM_CFG_MAJOR_VERSION != 10u) || \
    (DCM_CFG_MINOR_VERSION !=  4u) || \
    (DCM_CFG_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Cfg.h are inconsistent"
#endif
#if ((DCM_LCFG_MAJOR_VERSION != 10u) || \
    (DCM_LCFG_MINOR_VERSION !=  4u) || \
    (DCM_LCFG_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Lcfg.h are inconsistent"
#endif
#if ((DCM_PBCFG_MAJOR_VERSION != 10u) || \
    (DCM_PBCFG_MINOR_VERSION !=  4u) || \
    (DCM_PBCFG_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_PBcfg.h are inconsistent"
#endif
/* ----------------------------------------------
 ~&&&   Switches
---------------------------------------------- */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
/* Verify consistency between DCM and DEM configurations.
 * In case of error, please refer to the DCM technical reference (search for the error text) for more information and solution.
 */
# if defined(DEM_CFG_SUPPORT_DTR)                                                                                                                    /* COV_DCM_UNSUPPORTED_ERROR_DETECTION XF */
#  if (DEM_CFG_SUPPORT_DTR == STD_ON)
#   if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
#    error "DCM configured to handle OBD DID MIDs via DCM configuration, but MID handling is done by DEM."
#   endif
#  else
#   if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
#    error "DCM configured to handle OBD DID MIDs via DEM configuration, but no MID handling is done by DEM."
#   endif
#  endif
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)
/*! Specifies whether at least one diagnostic service needs the request parser utility */
# if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) || \
     (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) || \
     (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
#  define DCM_OBDIDMGR_REQ_PARSER_ENABLED                            STD_ON
# else
#  define DCM_OBDIDMGR_REQ_PARSER_ENABLED                            STD_OFF
# endif
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) || \
    (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
# define DCM_UTI_LOOKUP_U16_ENABLED                                  STD_ON
#else
# define DCM_UTI_LOOKUP_U16_ENABLED                                  STD_OFF
#endif

#if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
# define DCM_UTI_LOOKUP_RANGE_U16_ENABLED                            STD_ON
#else
# define DCM_UTI_LOOKUP_RANGE_U16_ENABLED                            STD_OFF
#endif
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
# define DCM_NET_CONN_LOCK_ENABLED                                   STD_ON
#else
# define DCM_NET_CONN_LOCK_ENABLED                                   STD_OFF
#endif

#if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON) || \
    (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON) || \
    (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
# define DCM_NET_RX_BLOCKING_ENABLED                                 STD_ON
#else
# define DCM_NET_RX_BLOCKING_ENABLED                                 STD_OFF
#endif
/* derive reentrant scheduling from split task */
#define DCM_TSK_REENTRANT_SCHEDULER_ENABLED                          DCM_SPLIT_TASKS_ENABLED

#define DCM_TSK_TASK_KILL_ENABLED                                    DCM_NET_PROCESSING_CANCELLATION_ENABLED

#if (DCM_TSK_TASK_KILL_ENABLED == STD_ON) && \
    (DCM_TSK_REENTRANT_SCHEDULER_ENABLED == STD_ON)
# define DCM_TSK_TASK_COMPLEX_KILL_ENABLED                           STD_ON
#else
# define DCM_TSK_TASK_COMPLEX_KILL_ENABLED                           STD_OFF
#endif

#define DCM_TSK_TASK_FLAG_SUPPORT_ENABLED                            DCM_TSK_TASK_COMPLEX_KILL_ENABLED

#if (DCM_DEV_ERROR_DETECT == STD_ON) && \
    (DCM_STATE_SECURITY_EXT_SETTER_ENABLED == STD_ON)                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TF tx tf */
# define DCM_TSK_TRACING_ENABLED                                     STD_ON
#else
# define DCM_TSK_TRACING_ENABLED                                     STD_OFF
#endif
/*! Specifies whether at least one diagnostic service needs global data storage.
    Extend this list if needed when adding a new diagnostic service with post-request memory */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
# define DCM_DIAG_SVC_CONTEXT_ENABLED                                STD_ON
#else
# define DCM_DIAG_SVC_CONTEXT_ENABLED                                STD_OFF
#endif

#if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
# define DCM_DIAG_TOBJ_QUEUE_ENABLED                                 STD_ON
#else
# define DCM_DIAG_TOBJ_QUEUE_ENABLED                                 STD_OFF
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON) || \
    (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
# define DCM_DIAG_SYNCH_FLAGS_ENABLED                                STD_ON
#else
# define DCM_DIAG_SYNCH_FLAGS_ENABLED                                STD_OFF
#endif

#if (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)
# define DCM_DIAG_PROCESSOR_FLAGS_ENABLED                            STD_ON
#else
# define DCM_DIAG_PROCESSOR_FLAGS_ENABLED                            STD_OFF
#endif

#if (DCM_DIAG_TOBJ_QUEUE_ENABLED    == STD_ON) || \
    (DCM_DIAG_PROCESSOR_FLAGS_ENABLED == STD_ON)
# define DCM_DIAG_SYNCH_DATA_SET_ENABLED                             STD_ON
#else
# define DCM_DIAG_SYNCH_DATA_SET_ENABLED                             STD_OFF
#endif

/*! Specifies whether at least one diagnostic service with a sub-function followed by no other data is active in the configuration */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_3E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX tx tf tf */
# define DCM_DIAG_SF_ONLY_SERVICE_ENABLED                            STD_ON
#else
# define DCM_DIAG_SF_ONLY_SERVICE_ENABLED                            STD_OFF
#endif

/*! Specifies whether the sequence check for services with sub-functions is active */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# define DCM_DIAG_SF_SEQUENCE_CHECK_SUPPORT_ENABLED                  STD_ON
#else
# define DCM_DIAG_SF_SEQUENCE_CHECK_SUPPORT_ENABLED                  STD_OFF
#endif
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/* Verify consistency between DCM and DEM configurations.
 * In case of error, please refer to the DCM technical reference (search for the error text) for more information and solution.
 */
# if defined(DEM_CFG_SUPPORT_DTR)                                                                                                                    /* COV_DCM_UNSUPPORTED_ERROR_DETECTION XF */
#  if (DEM_CFG_SUPPORT_DTR == STD_ON)
#  else
#   error "DCM configured to handle OBD MIDs via DEM configuration, but no MID handling is done by DEM."
#  endif
# endif
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
/* Verify consistency between DCM and DEM configurations.
 * In case of error, please refer to the DCM technical reference (search for the error text) for more information and solution.
 */
# if defined(DEM_CFG_SUPPORT_DTR)                                                                                                                    /* COV_DCM_UNSUPPORTED_ERROR_DETECTION XF */
#  if (DEM_CFG_SUPPORT_DTR == STD_ON)
#   error "DCM configured to handle OBD MIDs via DCM configuration, but MID handling is done by DEM."
#  endif
# endif
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON) && \
     ( (DCM_SVC_11_USER_ENABLED == STD_ON) || \
     (DCM_SVC_11_RAPID_SHTDWN_ENABLED == STD_ON) )
#  define DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED                    STD_ON
# else
#  define DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED                    STD_OFF
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED  == STD_ON ) || \
     (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON ) || \
     (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON )
#  define DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED                   STD_ON
# else
#  define DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED                   STD_OFF
# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON) && \
     (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
#  define DCM_SVC_19_COPY_LINEAR_DATA_ENABLED                        STD_ON
# else
#  define DCM_SVC_19_COPY_LINEAR_DATA_ENABLED                        STD_OFF
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED  == STD_ON) || \
     (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
#  define DCM_SVC_19_RECORD_ITER_ENABLED                             STD_ON
# else
#  define DCM_SVC_19_RECORD_ITER_ENABLED                             STD_OFF
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED       == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED  == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED      == STD_ON) || \
     (DCM_SVC_19_05_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED   == STD_ON) || \
     (DCM_SVC_19_08_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_09_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_14_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_42_SUPPORT_ENABLED                   == STD_ON)
#  define DCM_SVC_19_CHAINING_ENABLED                                STD_ON

#  if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON) || \
      (DCM_SVC_19_05_SUPPORT_ENABLED             == STD_ON) || \
      (DCM_SVC_19_09_SUPPORT_ENABLED             == STD_ON)
#   define DCM_SVC_19_CHAIN_END_ENABLED                              STD_ON
#  else
#   define DCM_SVC_19_CHAIN_END_ENABLED                              STD_OFF
#  endif
# else
#  define DCM_SVC_19_CHAINING_ENABLED                                STD_OFF
#  define DCM_SVC_19_CHAIN_END_ENABLED                               STD_OFF
# endif

# if ((DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)) && \
     (DCM_DEM_API_430_ENABLED == STD_OFF)
#  define DCM_SVC_19_ABSTRACT_RECORD_ITER_ENABLED                    STD_ON
# else
#  define DCM_SVC_19_ABSTRACT_RECORD_ITER_ENABLED                    STD_OFF
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/* Consistent configuration checks */
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_OFF)
#  error "Service 0x2A is enabled, but no periodic messages have been configured for Dcm. Please, refer to the Dcm TechRef for SID 0x2A configuration aspect."
# endif
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
#  define DCM_SVC_2C_RACE_CONDITION_READ_ENABLED                     STD_ON
# else
#  define DCM_SVC_2C_RACE_CONDITION_READ_ENABLED                     STD_OFF
# endif

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
#  error "Service 0x2C is not allowed when any paged DID is configured!"
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Defines
---------------------------------------------- */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
/*! Memory manager access types, used for locking the memory manager to protect from concurrent access */
# define DCM_MEMMGR_ACCESS_NONE                                      ((Dcm_MemMgrAccessType)0u)  /*!< The access to the memory is not locked */
# define DCM_MEMMGR_ACCESS_REQ_EXT                                   ((Dcm_MemMgrAccessType)1u)  /*!< The access to the memory is locked by SVC 0x23 */
# define DCM_MEMMGR_ACCESS_REQ_INT                                   ((Dcm_MemMgrAccessType)2u)  /*!< The access to the memory is locked by SVC 0x2C */

/*! Memory manager operations function prototype descriptors */
# define DCM_MEMMGR_OP_READ                                          ((Dcm_MemMgrMemoryOpType)0u)
# if (DCM_MEMMGR_MEMOP_READ_ENABLED == STD_ON)
#  define DCM_MEMMGR_OP_WRITE                                        ((Dcm_MemMgrMemoryOpType)(DCM_MEMMGR_OP_READ + 1u))
# else
#  define DCM_MEMMGR_OP_WRITE                                        ((Dcm_MemMgrMemoryOpType)(DCM_MEMMGR_OP_READ + 0u))
# endif
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)
# define DCM_OBDIDMGR_MAX_NUMBER_OF_IDS                              (6u) /*!< Maximum number of requested IDs */
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
/*! ComM notification allowance states */
#define DCM_NET_COMM_ACTIVE                                          ((Dcm_NetActiveDiagnosticType)TRUE)  /*!< Do notify ComM for ActiveDiagnostics (default state) */
#define DCM_NET_COMM_NOT_ACTIVE                                      ((Dcm_NetActiveDiagnosticType)FALSE) /*!< Do NOT notify ComM for ActiveDiagnostics (sleep prevention by DCM is inhibited by application) */

/*! Network variant/non-variant configuration abstraction */
#define Dcm_PbCfgNetNumRxPduIds                                      (Dcm_NetCfgGetNumRxPduIds(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumTxPduIds                                      (Dcm_NetCfgGetNumTxPduIds(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetCanTpRxPduIdMin                                  (Dcm_NetCfgGetMinCanTpRxPduId(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetCanTpRxPduIdMax                                  (Dcm_NetCfgGetMaxCanTpRxPduId(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumCanRxPduIds                                   (Dcm_NetCfgGetNumCanRxPduIds(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumPerTxObjects                                  (Dcm_NetCfgGetNumPerTxObjects(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumConnections                                   (Dcm_NetCfgGetNumConnections(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumProtocols                                     (Dcm_NetCfgGetNumProtocols(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumComMChannels                                  (Dcm_NetCfgGetNumComMChannels(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumBuffers                                       (Dcm_NetCfgGetNumBuffers(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumTransportObjects                              (Dcm_NetCfgGetNumTranspObjects(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumAllComMChannels                               (Dcm_NetCfgGetNumAllComMChannels(DCM_VARMGR_ACTIVE_COMVAR))

#define Dcm_PbCfgNetRxPduInfo                                        (Dcm_NetCfgGetRxPduInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetConnectionInfo                                   (Dcm_NetCfgGetConnectionInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetProtocolInfo                                     (Dcm_NetCfgGetProtocolInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetConnComMChannelMap                               (Dcm_NetCfgGetNetConnComMChannelMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNetworkHdlLookUp                                 (Dcm_NetCfgGetNetworkHdlLookUp(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetTxPdu2ConnMap                                    (Dcm_NetCfgGetTxPdu2ConnMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetPerTxPdu2RsrsMap                                 (Dcm_NetCfgGetPerTxPdu2RsrsMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetPerTxPduIdInfo                                   (Dcm_NetCfgGetPerTxPduIdInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetComCtrlChannelListAll                            (Dcm_NetCfgGetComCtrlChannelListAll(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetAllComMChannelMap                                (Dcm_NetCfgGetNetAllComMChannelMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetCanTp2DcmRxPduIdMap                              (Dcm_NetCfgGetCanTp2DcmRxPduIdMap(DCM_VARMGR_ACTIVE_COMVAR))

#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_PbRamNetBufferContext                                   (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.BufferContexts)
# define Dcm_PbRamNetTransportObject                                 (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.TranspObjects)
# define Dcm_PbRamNetComMContext                                     (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.ComMContexts)
# define Dcm_PbRamNetPeriodicTxObject                                (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.PeriodicTxObjects)
# define Dcm_PbRamNetConnId2TObjMap                                  (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.ConnId2TObjIdMap)
# define Dcm_PbRamNetComCtrlChannels                                 (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.ComCtrlChannels)
# define Dcm_PbCfgNetBufferInfo                                      (DCM_VARMGR_ACTIVE_ROMVAR.NetworkRom.BufferInfo)
#else
# define Dcm_PbRamNetBufferContext                                   (Dcm_SingletonContext.Network.BufferContext)
# define Dcm_PbRamNetTransportObject                                 (Dcm_SingletonContext.Network.TransportObject)
# define Dcm_PbRamNetComMContext                                     (Dcm_SingletonContext.Network.ComMContext)
# define Dcm_PbRamNetPeriodicTxObject                                (Dcm_SingletonContext.Network.PeriodicTxContext.TxObject)
# define Dcm_PbRamNetConnId2TObjMap                                  (Dcm_SingletonContext.Network.ConnId2TObjIdMap)
# define Dcm_PbRamNetComCtrlChannels                                 (Dcm_SingletonContext.Network.ComCtrlChannels)
# define Dcm_PbCfgNetBufferInfo                                      Dcm_CfgNetBufferInfo
#endif

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/*! Converts a Dcm related CanTp PduID to its corresponding DcmRxPduId */
# define Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpPduId)                (Dcm_PbCfgNetCanTp2DcmRxPduIdMap[(canTpPduId)-Dcm_PbCfgNetCanTpRxPduIdMin])     /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Provides the ECUs network address of a specific client connection */
# define Dcm_NetGetNodeAddress(connId)                               (Dcm_PbCfgNetConnectionInfo[(connId)].EcuAddress)                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpPduId)                /* not used */
# define Dcm_NetGetNodeAddress(connId)                               /* not used */
#endif

#if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
# define Dcm_NetGetDemClientId(protocolIdx)                          (Dcm_NetGetProtObjOfProtId(protocolIdx)->DemClientId)                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetDemClientId(protocolIdx)                          ((uint8)DCM_NET_DEFAULT_DEM_CLIENTID)                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif
/*! Retrieves diagnostic protocol specific P2 time justification */
#define Dcm_NetGetP2AdjTime(protocolIdx)                             (Dcm_NetGetProtObjOfProtId(protocolIdx)->SrvAdjTime.P2)                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Retrieves diagnostic protocol specific P2* time justification */
#define Dcm_NetGetP2StarAdjTime(protocolIdx)                         (Dcm_NetGetProtObjOfProtId(protocolIdx)->SrvAdjTime.P2Star)                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! USDT transport object states */
#define DCM_NET_TOBJ_STATE_FREE                                      ((Dcm_NetTransportObjectStateType)0x00u)  /*!< Free to be used */
#define DCM_NET_TOBJ_STATE_ONRX                                      ((Dcm_NetTransportObjectStateType)0x01u)  /*!< USDT reception in progress */
#define DCM_NET_TOBJ_STATE_RX_END                                    ((Dcm_NetTransportObjectStateType)0x02u)  /*!< USDT reception already finished */
#define DCM_NET_TOBJ_STATE_PREPTX                                    ((Dcm_NetTransportObjectStateType)0x04u)  /*!< Ready for USDT transmission */
#define DCM_NET_TOBJ_STATE_ONTX                                      ((Dcm_NetTransportObjectStateType)0x08u)  /*!< USDT transmission in progress */
#define DCM_NET_TOBJ_STATE_READY                                     ((Dcm_NetTransportObjectStateType)0x10u)  /*!< Transmission (Rx/Tx) finished but transport object still in use */
#define DCM_NET_TOBJ_STATE_RESERVED                                  ((Dcm_NetTransportObjectStateType)0x20u)  /*!< Transport object is allocated, but not yet in use (transmission) */

/*! USDT transport object flags */
#define DCM_NET_TOBJ_FLAG_NONE                                       ((Dcm_NetTransportObjectFlagType)0x0000u)  /*!< No flags set */
#define DCM_NET_TOBJ_FLAG_INTERNAL                                   ((Dcm_NetTransportObjectFlagType)0x0001u)  /*!< The transport object is used for internal (virtual) request (e.g. RoE) */
#define DCM_NET_TOBJ_FLAG_COPYHEAD                                   ((Dcm_NetTransportObjectFlagType)0x0002u)  /*!< The diagnostic request head shall be copied into a temporary buffer */
#define DCM_NET_TOBJ_FLAG_BUSY                                       ((Dcm_NetTransportObjectFlagType)0x0004u)  /*!< Current diagnostic request reception is a pseudo-parallel one */
#define DCM_NET_TOBJ_FLAG_CANCELED                                   ((Dcm_NetTransportObjectFlagType)0x0008u)  /*!< Current message transmission (Rx/Tx) was canceled */
#define DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ                               ((Dcm_NetTransportObjectFlagType)0x0010u)  /*!< RCR-RP state: just requested to be sent */
#define DCM_NET_TOBJ_FLAG_RCRRP_ON_TX                                ((Dcm_NetTransportObjectFlagType)0x0020u)  /*!< RCR-RP state: currently on transmission */
#define DCM_NET_TOBJ_FLAG_RCRRP_SENT                                 ((Dcm_NetTransportObjectFlagType)0x0040u)  /*!< RCR-RP state: at least once has been sent */
#define DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL                            ((Dcm_NetTransportObjectFlagType)0x0080u)  /*!< RCR-RP state: current one was triggered by the application */
#define DCM_NET_TOBJ_FLAG_OBSOLETE                                   ((Dcm_NetTransportObjectFlagType)0x0100u)  /*!< Transport object is obsolete and shall be canceled at later time. The difference to FLAG_CANCELED is that the ongoing transmission is not affected */
#define DCM_NET_TOBJ_FLAG_IGNORE                                     ((Dcm_NetTransportObjectFlagType)0x0200u)  /*!< Transport object shall not restart S3 and Keep-Alive Timers */
/*! USDT transport object response types */
#define DCM_NET_TOBJ_RESTYPE_NONE                                    ((Dcm_NetResponseType)0u)  /*!< No response is ongoing */
#define DCM_NET_TOBJ_RESTYPE_LINEAR                                  ((Dcm_NetResponseType)1u)  /*!< Final response (linear buffer) */
#define DCM_NET_TOBJ_RESTYPE_PAGED                                   ((Dcm_NetResponseType)2u)  /*!< Final response (paged-buffer) */
#define DCM_NET_TOBJ_RESTYPE_RCRRP                                   ((Dcm_NetResponseType)3u)  /*!< RCR-RP response */
#define DCM_NET_TOBJ_RESTYPE_UNSOLICITED                             ((Dcm_NetResponseType)4u)  /*!< Unsolicited (response without request) (e.g. FBL final response after power on/reset) */
#define DCM_NET_TOBJ_RESTYPE_SIMPLE                                  ((Dcm_NetResponseType)5u)  /*!< Simply respond (without processing) e.g. final negative response NRC 0x21 for pseudo parallel client handling or protocol switch rejection */

/*! Diagnostic client USDT connection properties */
#define DCM_NET_CONN_PROP_NONE                                       ((Dcm_CfgNetConnPropertiesType)0x00u)  /*!< Nothing special */
#define DCM_NET_CONN_PROP_TX_ON_FUNC_RX                              ((Dcm_CfgNetConnPropertiesType)0x01u)  /*!< No response to be sent on functional requests over this connection */
#define DCM_NET_CONN_PROP_NO_MAIN_TX                                 ((Dcm_CfgNetConnPropertiesType)0x02u)  /*!< The USDT connection does not contain a PduRTxPduId */

#define DCM_NET_INVALID_CONNID                                       ((Dcm_CfgNetNetIdRefMemType)Dcm_PbCfgNetNumConnections)
#define DCM_NET_INVALID_TOBJID                                       ((Dcm_CfgNetTObjHandleMemType)Dcm_PbCfgNetNumTransportObjects)
#define DCM_NET_INVALID_PROTID                                       ((Dcm_NetProtRefMemType)Dcm_PbCfgNetNumProtocols)

/*! State definitions for periodic transport object */
#define DCM_NET_PERIODIC_TX_STATE_FREE                               ((Dcm_NetPerTxObjStateMemType)0)
#define DCM_NET_PERIODIC_TX_STATE_RESERVED                           ((Dcm_NetPerTxObjStateMemType)1)
#define DCM_NET_PERIODIC_TX_STATE_QUEUED                             ((Dcm_NetPerTxObjStateMemType)2)
#define DCM_NET_PERIODIC_TX_STATE_ONTX                               ((Dcm_NetPerTxObjStateMemType)3)
#define DCM_NET_INVALID_PTXOBJ_HANDLE                                ((Dcm_CfgNetPTxObjHandleMemType)Dcm_PbCfgNetNumPerTxObjects)
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/*! AR 3.x PduR API result values adaption */
# define DCM_NET_ARENV_NTFRSLT_OK                                    NTFRSLT_OK
# define DCM_NET_ARENV_NTFRSLT_NOT_OK                                NTFRSLT_E_NOT_OK
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if (DCM_PDUR_API_401_ENABLED == STD_ON)
/*! AR 4.0.1 PduR API argument values adaption */
#  define DCM_NET_ARENV_NTFRSLT_OK                                   NTFRSLT_OK
#  define DCM_NET_ARENV_NTFRSLT_NOT_OK                               NTFRSLT_E_NOT_OK
# elif (DCM_PDUR_API_403_ENABLED == STD_ON)
/*! AR 4.0.3 PduR API argument values adaption */
#  define DCM_NET_ARENV_NTFRSLT_OK                                   NTFRSLT_OK
#  define DCM_NET_ARENV_NTFRSLT_NOT_OK                               NTFRSLT_E_NOT_OK
# elif (DCM_PDUR_API_412_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
/*! AR 4.1.2+ PduR API argument values adaption */
#  define DCM_NET_ARENV_NTFRSLT_OK                                   E_OK
#  define DCM_NET_ARENV_NTFRSLT_NOT_OK                               E_NOT_OK
# else
#  error "Unsupported PduR version!"
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#define DCM_PAGEDBUFFER_STATE_INACTIVE                               (Dcm_PagedBufferStateType)0x00u /*!< No paged-buffer transmission in progress */
#define DCM_PAGEDBUFFER_STATE_ACTIVATED                              (Dcm_PagedBufferStateType)0x01u /*!< Paged-buffer transmission activated, but not yet passed to the PduR */
#define DCM_PAGEDBUFFER_STATE_CANCELED                               (Dcm_PagedBufferStateType)0x02u /*!< Paged-buffer transmission terminated prior passing it to the PduR */
#define DCM_PAGEDBUFFER_STATE_ONTX                                   (Dcm_PagedBufferStateType)0x03u /*!< Paged-buffer transmission ongoing (passed to the PduR) */

#define DCM_PAGEDBUFFER_ALL_DATA_PROVIDED                            (Dcm_PagedBufferDataProvisionStateType)0x00u /*!< All data provided */
#define DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED                           (Dcm_PagedBufferDataProvisionStateType)0x01u /*!< Already some data provided */
#define DCM_PAGEDBUFFER_WAIT_FOR_DATA                                (Dcm_PagedBufferDataProvisionStateType)0x02u /*!< Waiting for data provision */
#define DCM_REPEATER_USER_NONE                                       ((Dcm_RepeaterUserType)0)
#define DCM_REPEATER_USER_DEM                                        ((Dcm_RepeaterUserType)1)
#define DCM_REPEATER_USER_DIDMGR                                     ((Dcm_RepeaterUserType)2)
#define DCM_REPEATER_PROGRESS_INITIAL                                ((Dcm_RepeaterProgressType)0)

#define DCM_REPEATER_PROGRESS_USERS_FIRST                            ((Dcm_RepeaterProgressType)1)
#define DCM_REPEATER_PROGRESS_USERS_LAST                             ((Dcm_RepeaterProgressType)254)
#define DCM_REPEATER_PROGRESS_INVALID                                ((Dcm_RepeaterProgressType)255)
/* all other progress types are client /service processor specific and shall start with DCM_REPEATER_PROGRESS_USERS_FIRST and end with DCM_REPEATER_PROGRESS_USERS_LAST */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/*! AR 3.x EcuReset related notification data type adapters */
# define Dcm_ModeMgrArEnvModeEcuResetType                            Dcm_ResetModeType
# define Dcm_ModeMgrArEnvModeRapidPowerShutDownType                  Dcm_ResetModeType
/*! AR 3.x EcuReset related notification value adapters. Values are self-explanatory and in AR DCM SWS documented */
# define DCM_MODEMGR_ARENV_MODE_ECURESET_NONE                        DCM_NO_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_HARD                        DCM_HARD_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_KEYONOFF                    DCM_KEY_ON_OFF_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_SOFT                        DCM_SOFT_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_OEM                DCM_BOOTLOADER_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_SYS                DCM_SS_BOOTLOADER_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE                     DCM_RESET_EXECUTION
# define DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_ENABLE                  DCM_ENABLE_RAPID_POWER_SHUTDOWN_RESET
# define DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_DISABLE                 DCM_DISABLE_RAPID_POWER_SHUTDOWN_RESET
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/*! AR 4.x EcuReset related notification data type adapters */
# define Dcm_ModeMgrArEnvModeEcuResetType                            Rte_ModeType_DcmEcuReset
# define Dcm_ModeMgrArEnvModeRapidPowerShutDownType                  Rte_ModeType_DcmModeRapidPowerShutDown
/*! AR 4.x EcuReset related notification value adapters. Values are self-explanatory and in AR DCM SWS documented */
# define DCM_MODEMGR_ARENV_MODE_ECURESET_NONE                        RTE_MODE_DcmEcuReset_NONE
# define DCM_MODEMGR_ARENV_MODE_ECURESET_HARD                        RTE_MODE_DcmEcuReset_HARD
# define DCM_MODEMGR_ARENV_MODE_ECURESET_KEYONOFF                    RTE_MODE_DcmEcuReset_KEYONOFF
# define DCM_MODEMGR_ARENV_MODE_ECURESET_SOFT                        RTE_MODE_DcmEcuReset_SOFT
# define DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_OEM                RTE_MODE_DcmEcuReset_JUMPTOBOOTLOADER
# define DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_SYS                RTE_MODE_DcmEcuReset_JUMPTOSYSSUPPLIERBOOTLOADER
# define DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE                     RTE_MODE_DcmEcuReset_EXECUTE
# define DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_ENABLE                  RTE_MODE_DcmModeRapidPowerShutDown_ENABLE_RAPIDPOWERSHUTDOWN
# define DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_DISABLE                 RTE_MODE_DcmModeRapidPowerShutDown_DISABLE_RAPIDPOWERSHUTDOWN
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/*! Task priorities */
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
# define DCM_TSK_PRIO_NONE                                           /* must not be used */       /*!< Always use a concrete priority! */
# define DCM_TSK_PRIO_LOW                                            ((Dcm_TskTaskPrioMemType)0)  /*!< Low priority - can be interrupted by higher priority tasks and ISRs */
# define DCM_TSK_PRIO_HIGH                                           ((Dcm_TskTaskPrioMemType)1)  /*!< High priority - cannot be interrupted by any other tasks, only ISRs */
# define DCM_TSK_NUM_PRIOS                                           ((Dcm_TskTaskPrioMemType)2)  /*!< The number of different task priorities */
#else
# define DCM_TSK_PRIO_NONE                                           ((Dcm_TskTaskPrioMemType)0)  /*!< Default priority - to be used only in case no task-splitting is used */
# define DCM_TSK_PRIO_LOW                                            DCM_TSK_PRIO_NONE            /*!< Low priority - can be interrupted by ISRs */
# define DCM_TSK_PRIO_HIGH                                           DCM_TSK_PRIO_NONE            /*!< High priority - shares the same priority as low */
# define DCM_TSK_NUM_PRIOS                                           ((Dcm_TskTaskPrioMemType)1)  /*!< The number of different task priorities */
#endif

/*! Task event representing that no events are available */
#define DCM_TSK_EV_NONE                                              ((Dcm_TskTaskEvMemType)0x00u)

/* Task setup informations */
/*! Task execution types */
#define DCM_TSK_ATR_EXEC_ONCE                                        ((Dcm_TskTaskAttributeType)0x00u)  /*!< Task will be executed only once per Dcm_MainFunction() call */
#define DCM_TSK_ATR_EXEC_MULTI                                       ((Dcm_TskTaskAttributeType)0x01u)  /*!< Task can be executed multiple times per Dcm_MainFunction() call if still has any active events */
/*! Task termination ability types */
#define DCM_TSK_ATR_KILL_NEVER                                       ((Dcm_TskTaskAttributeType)0x00u)  /*!< Task can never be terminated on a kill-task signal */
#define DCM_TSK_ATR_KILL_ALWAYS                                      ((Dcm_TskTaskAttributeType)0x02u)  /*!< Task will be terminated on a kill task signal */

/*! Task runtime status flags */
#define DCM_TSK_TASK_FLAG_NONE                                       ((Dcm_TskTaskFlagType)0x00u) /*!< Task is in normal mode (running) */
#define DCM_TSK_TASK_FLAG_KILLED                                     ((Dcm_TskTaskFlagType)0x01u) /*!< Task is in terminated mode (no more events can be set) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
# define DCM_DIDMGR_RANGELOOKUPRSLT_NOMATCH                          ((Dcm_DidMgrRangeLookUpResultType)0x00)
# define DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_SUPPORTED                ((Dcm_DidMgrRangeLookUpResultType)0x01)
# define DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_UNSUPPORTED              ((Dcm_DidMgrRangeLookUpResultType)0x02)
# define DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_ANY                      ((Dcm_DidMgrRangeLookUpResultType)(DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_SUPPORTED | DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_UNSUPPORTED))
# define DCM_DIDMGR_RANGELOOKUPRSLT_PENDING                          ((Dcm_DidMgrRangeLookUpResultType)0x04)

/* Service port operation types */
# define DCM_DIDMGR_OPTYPE_READ                                      ((Dcm_DidMgrOpCallMemType)0x01u)
# define DCM_DIDMGR_OPTYPE_READLENGTH                                ((Dcm_DidMgrOpCallMemType)0x02u)
# define DCM_DIDMGR_OPTYPE_READCHKCOND                               ((Dcm_DidMgrOpCallMemType)0x04u)
# define DCM_DIDMGR_OPTYPE_RANGEREAD                                 DCM_DIDMGR_OPTYPE_READ
# define DCM_DIDMGR_OPTYPE_RANGEREADLENGTH                           DCM_DIDMGR_OPTYPE_READLENGTH

# define DCM_DIDMGR_OPTYPE_WRITE                                     ((Dcm_DidMgrOpCallMemType)0x01u)
# define DCM_DIDMGR_OPTYPE_RANGEWRITE                                DCM_DIDMGR_OPTYPE_WRITE

/* this value shall be for both OP_READ and OP_WRITE OP_TYPES the same! */
# define DCM_DIDMGR_OPTYPE_RANGEISDIDAVAILABLE                       ((Dcm_DidMgrOpCallMemType)0x10u)

# define DCM_DIDMGR_OPTYPE_GETSCALING                                ((Dcm_DidMgrOpCallMemType)0x01u)

# define DCM_DIDMGR_OPTYPE_DEFINE                                    ((Dcm_DidMgrOpCallMemType)0x01u)

# define DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU                            ((Dcm_DidMgrOpCallMemType)0x01u)
# define DCM_DIDMGR_OPTYPE_IO_RST2DEF                                ((Dcm_DidMgrOpCallMemType)0x02u)
# define DCM_DIDMGR_OPTYPE_IO_FRZCURSTATE                            ((Dcm_DidMgrOpCallMemType)0x04u)
# define DCM_DIDMGR_OPTYPE_IO_SHRTTRMADJ                             ((Dcm_DidMgrOpCallMemType)0x08u)

/* Service port operation classes */
# define DCM_DIDMGR_OPCLS_READ_RANGE                                 ((Dcm_DidMgrOpClassType)0x0000)
# define DCM_DIDMGR_OPCLS_READ_SYNC                                  ((Dcm_DidMgrOpClassType)0x0001)
# define DCM_DIDMGR_OPCLS_READ_ASYNC                                 ((Dcm_DidMgrOpClassType)0x0002)
# define DCM_DIDMGR_OPCLS_READ_PAGED                                 ((Dcm_DidMgrOpClassType)0x0003)
# define DCM_DIDMGR_OPCLS_READ_VID                                   ((Dcm_DidMgrOpClassType)0x0004)
# define DCM_DIDMGR_OPCLS_READ_SR                                    ((Dcm_DidMgrOpClassType)0x0005)
# define DCM_DIDMGR_OPCLS_READ_GAP                                   ((Dcm_DidMgrOpClassType)0x0006)
# define DCM_DIDMGR_OPCLS_READ_WRAPPER                               ((Dcm_DidMgrOpClassType)0x0007)

# define DCM_DIDMGR_OPCLS_READLENGTH_RANGE                           ((Dcm_DidMgrOpClassType)0x0100)
# define DCM_DIDMGR_OPCLS_READLENGTH_SYNC                            ((Dcm_DidMgrOpClassType)0x0101)
# define DCM_DIDMGR_OPCLS_READLENGTH_ASYNC                           ((Dcm_DidMgrOpClassType)0x0102)

# define DCM_DIDMGR_OPCLS_READCHK_COND_SYNC                          ((Dcm_DidMgrOpClassType)0x0200)
# define DCM_DIDMGR_OPCLS_READCHK_COND_ASYNC                         ((Dcm_DidMgrOpClassType)0x0201)

# define DCM_DIDMGR_OPCLS_WRITE_RANGE                                ((Dcm_DidMgrOpClassType)0x1000)
# define DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_ERROR                 ((Dcm_DidMgrOpClassType)0x1001)
# define DCM_DIDMGR_OPCLS_WRITE_NLEN_ASYNC_NRES_ERROR                ((Dcm_DidMgrOpClassType)0x1002)
# define DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_NRES_ERROR                  ((Dcm_DidMgrOpClassType)0x1003)
# define DCM_DIDMGR_OPCLS_WRITE_LEN_ASYNC_NRES_ERROR                 ((Dcm_DidMgrOpClassType)0x1004)
# define DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_NERROR                ((Dcm_DidMgrOpClassType)0x1005)
# define DCM_DIDMGR_OPCLS_WRITE_GAP                                  ((Dcm_DidMgrOpClassType)0x1006)
# define DCM_DIDMGR_OPCLS_WRITE_WRAPPER                              ((Dcm_DidMgrOpClassType)0x1007)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR         ((Dcm_DidMgrOpClassType)0x2000)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_NCEMR_ERROR          ((Dcm_DidMgrOpClassType)0x2001)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_NCEMR_ERROR           ((Dcm_DidMgrOpClassType)0x2002)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR        ((Dcm_DidMgrOpClassType)0x2003)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_NCEMR_ERROR         ((Dcm_DidMgrOpClassType)0x2004)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_NCEMR_ERROR          ((Dcm_DidMgrOpClassType)0x2005)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR         ((Dcm_DidMgrOpClassType)0x2006)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR8_ERROR          ((Dcm_DidMgrOpClassType)0x2007)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR8_ERROR           ((Dcm_DidMgrOpClassType)0x2008)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR        ((Dcm_DidMgrOpClassType)0x2009)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR8_ERROR         ((Dcm_DidMgrOpClassType)0x200A)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR8_ERROR          ((Dcm_DidMgrOpClassType)0x200B)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR        ((Dcm_DidMgrOpClassType)0x200C)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR16_ERROR         ((Dcm_DidMgrOpClassType)0x200D)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR16_ERROR          ((Dcm_DidMgrOpClassType)0x200E)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR       ((Dcm_DidMgrOpClassType)0x200F)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR16_ERROR        ((Dcm_DidMgrOpClassType)0x2010)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR16_ERROR         ((Dcm_DidMgrOpClassType)0x2011)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR        ((Dcm_DidMgrOpClassType)0x2012)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR32_ERROR         ((Dcm_DidMgrOpClassType)0x2013)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR32_ERROR          ((Dcm_DidMgrOpClassType)0x2014)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR       ((Dcm_DidMgrOpClassType)0x2015)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR32_ERROR        ((Dcm_DidMgrOpClassType)0x2016)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR32_ERROR         ((Dcm_DidMgrOpClassType)0x2017)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR         ((Dcm_DidMgrOpClassType)0x2018)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMRN_ERROR          ((Dcm_DidMgrOpClassType)0x2019)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMRN_ERROR           ((Dcm_DidMgrOpClassType)0x201A)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR        ((Dcm_DidMgrOpClassType)0x201B)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMRN_ERROR         ((Dcm_DidMgrOpClassType)0x201C)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMRN_ERROR          ((Dcm_DidMgrOpClassType)0x201D)

# define DCM_DIDMGR_OPCLS_IO_GAP                                     ((Dcm_DidMgrOpClassType)0x201E)
/* IO wrapper must be used for supported IDs only */
# define DCM_DIDMGR_OPCLS_IO_WRAPPER                                 ((Dcm_DidMgrOpClassType)0x201F)

# define DCM_DIDMGR_OPCLS_GETSCALING_SYNC                            ((Dcm_DidMgrOpClassType)0x3000)
# define DCM_DIDMGR_OPCLS_GETSCALING_ASYNC                           ((Dcm_DidMgrOpClassType)0x3001)

# define DCM_DIDMGR_OPCLS_DEFINE                                     ((Dcm_DidMgrOpClassType)0x4000)

# define DCM_DIDMGR_OPCLS_ISDIDAVAILABLE                             ((Dcm_DidMgrOpClassType)0x5400)

# define DCM_DIDMGR_IO_CEMR_HANDLING_NO                              ((Dcm_DidMgrIoDidCemrHandlingType)0)
# define DCM_DIDMGR_IO_CEMR_HANDLING_INTERNAL                        ((Dcm_DidMgrIoDidCemrHandlingType)1)
# define DCM_DIDMGR_IO_CEMR_HANDLING_EXTERNAL                        ((Dcm_DidMgrIoDidCemrHandlingType)2)

# define DCM_DIDMGR_LOOKUP_STATE_DIDRANGE                            ((Dcm_DidMgrDidLookUpStateType)0)
# define DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID                         ((Dcm_DidMgrDidLookUpStateType)1)
# define DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN                    ((Dcm_DidMgrDidLookUpStateType)2)

# define DCM_DIDMGR_DIDLOCK_OWNER_NONE                               ((Dcm_DidMgrDidLockOwnerType)0)
# define DCM_DIDMGR_DIDLOCK_OWNER_READONCE                           ((Dcm_DidMgrDidLockOwnerType)1)
# define DCM_DIDMGR_DIDLOCK_OWNER_READPERIODIC                       ((Dcm_DidMgrDidLockOwnerType)2)
# define DCM_DIDMGR_DIDLOCK_OWNER_READDYNAMIC                        ((Dcm_DidMgrDidLockOwnerType)3)
# define DCM_DIDMGR_DIDLOCK_OWNER_WRITE                              ((Dcm_DidMgrDidLockOwnerType)4)
# define DCM_DIDMGR_DIDLOCK_OWNER_IO                                 ((Dcm_DidMgrDidLockOwnerType)5)

/*!
 * Maximum numbers of Dids which could be handled in parallel.
 * Only periodic Dids can be read in parallel, so a mutex is required only if
 * e.g. service 0x22 wants to access the same Did as the 0x2A background scheduler.
 * In case of periodic DDDIDs, the DDDID itself and the currently read source DID has to be locked.
 * Therefore maximal three Dids could be handled in parallel.
 */
# define DCM_DIDMGR_DID_LOCK_LIST_SIZE                               3u
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/*! RID operation types */
# define DCM_RIDMGR_OP_NONE                                          ((Dcm_RidMgrOpType)0x00u)
# define DCM_RIDMGR_OP_START                                         ((Dcm_RidMgrOpType)0x01u)
# define DCM_RIDMGR_OP_STOP                                          ((Dcm_RidMgrOpType)0x02u)
# define DCM_RIDMGR_OP_REQRSLTS                                      ((Dcm_RidMgrOpType)0x04u)

/*! Routine operations function prototype descriptors */
# define DCM_RIDMGR_OPTYPE_NONE                                      ((Dcm_RidMgrOpCallType)0u)
# define DCM_RIDMGR_OPTYPE_REQ                                       ((Dcm_RidMgrOpCallType)1u)
# define DCM_RIDMGR_OPTYPE_REQ_RES                                   ((Dcm_RidMgrOpCallType)2u)
# define DCM_RIDMGR_OPTYPE_RES                                       ((Dcm_RidMgrOpCallType)3u)
# define DCM_RIDMGR_OPTYPE_REQ_DYNLEN                                ((Dcm_RidMgrOpCallType)4u)
# define DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES                            ((Dcm_RidMgrOpCallType)5u)
# define DCM_RIDMGR_OPTYPE_RES_DYNLEN                                ((Dcm_RidMgrOpCallType)6u)
# define DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN                     ((Dcm_RidMgrOpCallType)7u)
# define DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN                            ((Dcm_RidMgrOpCallType)8u)
# define DCM_RIDMGR_OPTYPE_WRAPPER                                   ((Dcm_RidMgrOpCallType)9u)
# define DCM_RIDMGR_OPTYPE_SUPP_ID_WRAPPER                           ((Dcm_RidMgrOpCallType)10u)

# define DCM_RIDMGR_ROUTINEINFOBYTE_IDX                              ((Dcm_DiagBufferIndexType)3u) /*!< Index of routine info byte in response message (skip SF and RID) */
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)
/*! OBD DTC manager processing steps */
# define DCM_OBDDTCMGR_PROGRESS_INITAL                               ((Dcm_RepeaterProgressType)0)
# define DCM_OBDDTCMGR_PROGRESS_GETNUMFLTRDDTC                       ((Dcm_RepeaterProgressType)1)
# define DCM_OBDDTCMGR_PROGRESS_COPYLINEARDATA                       ((Dcm_RepeaterProgressType)2)
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/*! Network to diagnostic variant bridge abstraction */
#if (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON) && (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
# define Dcm_PbCfgDiagSvcId2ProtMap                                  (DCM_VARMGR_ACTIVE_BRIDGEVAR.Svc2ProtocolMap)
#else
# define Dcm_PbCfgDiagSvcId2ProtMap                                  Dcm_CfgDiagSvcId2ProtMap
#endif

/*! Diagnostic entity evaluation level */
#define DCM_DIAG_CHK_LVL_SERVICE_ID                                  ((Dcm_DiagCheckLvlType)0u) /*!< Evaluation on diagnostic service ID level */
#define DCM_DIAG_CHK_LVL_PARAMETER                                   ((Dcm_DiagCheckLvlType)1u) /*!< Evaluation on diagnostic parameter ID level */
#define DCM_DIAG_CHK_LVL_SUBFUNC                                     ((Dcm_DiagCheckLvlType)2u) /*!< Evaluation on diagnostic sub-function ID level */

/*! Total number of diagnostic entities that can be verified (use always the one with highest ID as reference) */
#define DCM_DIAG_NUM_CHK_LVLS                                        (DCM_DIAG_CHK_LVL_SUBFUNC + 1u)

/*! Bitmap encoding for the enumerator values below (used to build the AR standard confirmation status values e.g. DCM_RES_POS_OK !) */
#define DCM_DIAG_RES_ANY_OK                                          ((Dcm_ConfirmationStatusType)0x00u) /*!< The response (positive/negative) was successfully sent */
#define DCM_DIAG_RES_ANY_NOT_OK                                      ((Dcm_ConfirmationStatusType)0x01u) /*!< The response (positive/negative) transmission failed */
#define DCM_DIAG_RES_POS_ANY                                         ((Dcm_ConfirmationStatusType)0x00u) /*!< It is a positive response */
#define DCM_DIAG_RES_NEG_ANY                                         ((Dcm_ConfirmationStatusType)0x02u) /*!< It is a negative response */

/*! Diagnostic kernel application notification levels reached during diagnostic service processing.
    This levels are used to determine which finalization callouts shall be performed later (e.g. service execution confirmation, post-handlers etc.) */
#define DCM_DIAG_APPL_NOTIFICATION_NONE                              ((Dcm_DiagApplNotificationType)0x00u) /*!< No application call was made */
#define DCM_DIAG_APPL_NOTIFICATION_OEM                               ((Dcm_DiagApplNotificationType)0x01u) /*!< Manufacturer specific request indication(s) reached (Xxx_Indication()) */
#define DCM_DIAG_APPL_NOTIFICATION_SYS                               ((Dcm_DiagApplNotificationType)0x02u) /*!< System supplier specific request indication(s) reached (Xxx_Indication()) */
#define DCM_DIAG_APPL_NOTIFICATION_CONFIRMATION                      ((Dcm_DiagApplNotificationType)0x04u) /*!< Call the DCM confirmation after service processing */
#define DCM_DIAG_APPL_NOTIFICATION_POSTPROCESSOR                     ((Dcm_DiagApplNotificationType)0x08u) /*!< Call the post processor function */
#define DCM_DIAG_APPL_NOTIFICATION_FASTPOSTPROCESSOR                 ((Dcm_DiagApplNotificationType)0x10u) /*!< Call the fast post processor function */


/*! Diagnostic kernel request queued flags. These are used to keep track of any overlapping diagnostic request in processing with a new one just won a request prioritization
    Especially in case of split-task this mechanism provides a look-ahead whether a new request is already queue to be processed within the low-priority Dcm_DiagTaskWorker() */
#define DCM_DIAG_QUEUE_FLAG_NONE                                     ((Dcm_DiagProcessorFlagType)0x00u) /*!< There is no diagnostic request queued to be processed */
#define DCM_DIAG_QUEUE_FLAG_IS_WAITING                               ((Dcm_DiagProcessorFlagType)0x01u) /*!< There is already a diagnostic request queued (waiting) to be processed */
#define DCM_DIAG_QUEUE_FLAG_IS_ACTIVE                                ((Dcm_DiagProcessorFlagType)0x02u) /*!< There diagnostic request in started processing */

/*! Diagnostic service specific properties */
#define DCM_DIAG_SVC_CFG_PROP_HAS_SUBFUNC                            ((DcmCfg_DiagServicePropertiesType)0x01u) /*!< Has a sub-function parameter */
#define DCM_DIAG_SVC_CFG_PROP_CALL_POST_HDLR_ALWAYS                  ((DcmCfg_DiagServicePropertiesType)0x02u) /*!< Requires the post-handler (Dcm_ServiceXXPostHandler()) to be called always once the service evaluation has started */
#define DCM_DIAG_SVC_CFG_PROP_CALL_SVC_DISPATCHER                    ((DcmCfg_DiagServicePropertiesType)0x04u) /*!< Requires a service dispatching (internal and external service processing) */

/*! Getter for the diagnostic session specific P2 timings */
#define Dcm_DiagGetP2Time(sesStateIdx)                               (Dcm_CfgStateSessionInfo[(sesStateIdx)].P2ServerTime.P2)                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_DiagGetP2StarTime(sesStateIdx)                           (Dcm_CfgStateSessionInfo[(sesStateIdx)].P2ServerTime.P2Star)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Specifies the maximum buffer size required for the final unsolicited response (i.e. after ECU re-programming)
  Note: Currently the longest possible response is for SID 0x10, that has: SID*1 + SF*1 + P2*2 + P2Ex*2 = 6 Bytes */
#define DCM_DIAG_START_UP_FBL_RES_SIZE                               6u
/*! Variant management optimization abstraction */
#define DCM_VARMGR_ACTIVE_COMVAR                                     (Dcm_SingletonContext.VarMgr.ActiveComVariant)      /*!< Substitution for COM-criteria storage */
#define DCM_VARMGR_ACTIVE_BRIDGEVAR                                  (Dcm_SingletonContext.VarMgr.ActiveBridgeVariant)   /*!< Substitution for COM-to-CFG bridge storage */
#define DCM_VARMGR_ACTIVE_RAMVAR                                     (Dcm_SingletonContext.VarMgr.ActiveRamVariant)      /*!< Substitution for PBL RAM storage */
#define DCM_VARMGR_ACTIVE_ROMVAR                                     (Dcm_SingletonContext.VarMgr.ActiveRomVariant)      /*!< Substitution for PBL ROM storage */
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_PbCfgVarMgrDiagVariantFilter                            (DCM_VARMGR_ACTIVE_ROMVAR.DiagRom.VariantFilter)
#else
# define Dcm_PbCfgVarMgrDiagVariantFilter                            Dcm_CfgVarMgrVariantTable
#endif
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC01_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
/*! Service 0x02 processing steps */
# define DCM_SVC02_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)
/*! Service 0x03 processing steps */
# define DCM_SVC03_PROGRESS_SETDTCFILTER                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC03_PROGRESS_READDTCBYSTATUSMASK                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)
/*! Service 0x04 processing steps */
# define DCM_SVC04_PROGRESS_REPEATERPROXY_SELECT_DTC                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC04_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/*! Service 0x06 processing step */
# define DCM_SVC06_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
# define DCM_SVC06_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)
/*! Service 0x07 processing steps */
# define DCM_SVC07_PROGRESS_SETDTCFILTER                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC07_PROGRESS_READDTCBYSTATUSMASK                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC08_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC09_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)
/*! Service 0x0A processing steps */
# define DCM_SVC0A_PROGRESS_SETDTCFILTER                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC0A_PROGRESS_READDTCBYSTATUSMASK                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
/*! Service 0x10 processing steps */
# define DCM_SVC10_PROGRESS_WAIT_RESET_ACK                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC10_PROGRESS_SET_PRGCOND                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/*! Service 0x11 processing steps */
# define DCM_SVC11_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC11_PROGRESS_ECURST_WAITFORACK                        ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC11_RAPPWRDWN_WAITFORACK                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/*! Service 0x14 processing steps */
# define DCM_SVC14_PROGRESS_REPEATERPROXY_SELECT_DTC                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC14_PROGRESS_REPEATERPROXY_CHECK_SELECTION_RESULT     ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC14_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! Service 0x19 processing steps */
# define DCM_SVC19_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC19_PROGRESS_UTI_COPYLINEARDATA                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))

# define DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 10))
# define DCM_SVC19_PROGRESS_DEMCHAIN_DISABLERECORDUPDATE             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 11))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 12))
# define DCM_SVC19_PROGRESS_DEMCHAIN_SELECTFFREC                     ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 13))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFFFREC                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 14))
# define DCM_SVC19_PROGRESS_DEMCHAIN_SELECTEXTDATAREC                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 15))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFEXTDATAREC             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 16))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 17))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDSEVERITY            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 18))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETSEVERITYOFDTC                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 19))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETFUNCUNITOFDTC                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 20))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDDTC                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 21))
# define DCM_SVC19_PROGRESS_DEMCHAIN_PUTNUMFLTRDDTC                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 22))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDFDC                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 23))
# define DCM_SVC19_PROGRESS_DEMCHAIN_WWHOBD_GETNEXTFLTRDSEVERITY     ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 24))

# define DCM_SVC19_PROGRESS_CHAIN_END                                DCM_REPEATER_PROGRESS_USERS_LAST /*!< Service 0x19 final processing step */

/*! Service 0x19 paged-buffer updater dispatching items IDs */
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_RECORD                      ((Dcm_Svc19SubUpdaterType)0u)
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY                    ((Dcm_Svc19SubUpdaterType)1u)
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_FDC                         ((Dcm_Svc19SubUpdaterType)2u)
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY_WWHOBD             ((Dcm_Svc19SubUpdaterType)3u)
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_DTC                         ((Dcm_Svc19SubUpdaterType)4u)
# define DCM_SVC_19_UPDATE_GET_EXT_RECORD                            ((Dcm_Svc19SubUpdaterType)5u)
# define DCM_SVC_19_UPDATE_SELECT_FF_RECORD                          ((Dcm_Svc19SubUpdaterType)6u)
# define DCM_SVC_19_UPDATE_GET_FF_RECORD                             ((Dcm_Svc19SubUpdaterType)7u)
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! List of DEM filter configurations */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_01                           ((Dcm_Svc19DemSetFilterClassType)0u) /*!< For SF 0x01, 0x02, 0x14, 0x0A */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_02                           ((Dcm_Svc19DemSetFilterClassType)1u) /*!< For SF 0x07, 0x08 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_03                           ((Dcm_Svc19DemSetFilterClassType)2u) /*!< For SF 0x11, 0x0F */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_04                           ((Dcm_Svc19DemSetFilterClassType)3u) /*!< For SF 0x12, 0x13 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_05                           ((Dcm_Svc19DemSetFilterClassType)4u) /*!< For SF 0x15 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_06                           ((Dcm_Svc19DemSetFilterClassType)5u) /*!< For SF 0x17 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_07                           ((Dcm_Svc19DemSetFilterClassType)6u) /*!< For SF 0x42 */

/*! Total number of DEM filter configurations */
# define DCM_SVC_19_DEM_SETFILTER_NUM_CLASSES                        (DCM_SVC_19_DEM_SETFILTER_CLASS_07+1u)

/*! API Dcm_Svc19UtiReportDtcByStatusMaskData DTC status mask usage parametrization */
# define DCM_SVC_19_USE_MASK_REQ                                     ((Dcm_Svc19DemSetFilterMaskUsageType)0u) /*!< Extract and use the mask from request data */
# define DCM_SVC_19_USE_MASK_ALL                                     ((Dcm_Svc19DemSetFilterMaskUsageType)1u) /*!< Do report all supported DTCs */

/*! DTC extended record number wildcard types */
# define DCM_SVC_19_RECNUM_ALL                                       ((uint8)0xFFu) /*!< All supported extended data records */
# define DCM_SVC_19_RECNUM_OBD_ALL                                   ((uint8)0xFEu) /*!< Report only OBD related extended data records */
/*! DTC (extended/freeze frame) record list end marker (0xFF is not a valid single record ID) */
# define DCM_SVC_19_RECLIST_END                                      ((uint8)0xFFu)

/*! Abstract DTC record iterator result values */
# define DCM_SVC19_UTI_REC_ITER_RSLT_OK                              ((Dcm_Svc19UtiRecordIterResultType)0) /*!< Next DTC record found and can be used */
# define DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS                 ((Dcm_Svc19UtiRecordIterResultType)1) /*!< Iteration ends here */
/*! Vector DCM to Vector DEM Interface check */
# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
#  if ( defined(DCM_SVC_19_NUM_EXTDATA_RECID) && !defined (DCM_SVC_19_LST_EXTDATA_RECID)) || \
      (!defined(DCM_SVC_19_NUM_EXTDATA_RECID) &&  defined (DCM_SVC_19_LST_EXTDATA_RECID))
#   error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#  else
#   if (defined(DCM_SVC_19_NUM_EXTDATA_RECID) && defined (DCM_SVC_19_LST_EXTDATA_RECID))                                                             /* COV_DCM_UNSUPPORTED XF xf xf */
/* the DCM knows the extended data records of the DEM */
#   else
#    if ( defined(DEM_DCM_NUM_EXTDATA_RECID) && !defined (DEM_DCM_LST_EXTDATA_RECID)) || \
        (!defined(DEM_DCM_NUM_EXTDATA_RECID) &&  defined (DEM_DCM_LST_EXTDATA_RECID))
#     error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#    else
#     if (defined(DEM_DCM_NUM_EXTDATA_RECID) && defined (DEM_DCM_LST_EXTDATA_RECID))                                                                 /* COV_DCM_SUPPORT_WITH_MSR_DEM TX tx tx */
/* use the information provided by DEM */
#      define DCM_SVC_19_NUM_EXTDATA_RECID                           DEM_DCM_NUM_EXTDATA_RECID
#      define DCM_SVC_19_LST_EXTDATA_RECID                           DEM_DCM_LST_EXTDATA_RECID
#     else
#      define DCM_SVC_19_NUM_EXTDATA_RECID                           0
#      define DCM_SVC_19_LST_EXTDATA_RECID                           /* empty */
#      error "Missing information for the supported DTC Extended Data Records! See DCM TechRef!"
#     endif
#    endif
#   endif
#  endif
/*! Actual complete extended data record list sizes */
#  define DCM_SVC_19_EXTDATA_RECID_SIZE                              (DCM_SVC_19_NUM_EXTDATA_RECID     + 1)
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
#  if ( defined(DCM_SVC_19_NUM_OBD_EXTDATA_RECID) && !defined (DCM_SVC_19_LST_OBD_EXTDATA_RECID)) || \
      (!defined(DCM_SVC_19_NUM_OBD_EXTDATA_RECID) &&  defined (DCM_SVC_19_LST_OBD_EXTDATA_RECID))
#   error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#  else
#   if (defined(DCM_SVC_19_NUM_OBD_EXTDATA_RECID) && defined (DCM_SVC_19_LST_OBD_EXTDATA_RECID))                                                     /* COV_DCM_UNSUPPORTED XF xf xf */
/* the DCM knows the OBD extended data records of the DEM */
#   else
#    if ( defined(DEM_DCM_NUM_OBD_EXTDATA_RECID) && !defined (DEM_DCM_LST_OBD_EXTDATA_RECID)) || \
        (!defined(DEM_DCM_NUM_OBD_EXTDATA_RECID) &&  defined (DEM_DCM_LST_OBD_EXTDATA_RECID))
#     error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#    else
#     if ( defined(DEM_DCM_NUM_OBD_EXTDATA_RECID) && defined (DEM_DCM_LST_OBD_EXTDATA_RECID))                                                        /* COV_DCM_SUPPORT_WITH_MSR_DEM TX tx tx */
/* use the information provided by DEM */
#      define DCM_SVC_19_NUM_OBD_EXTDATA_RECID                       DEM_DCM_NUM_OBD_EXTDATA_RECID
#      define DCM_SVC_19_LST_OBD_EXTDATA_RECID                       DEM_DCM_LST_OBD_EXTDATA_RECID
#     else
#      define DCM_SVC_19_NUM_OBD_EXTDATA_RECID                       0
#      define DCM_SVC_19_LST_OBD_EXTDATA_RECID                       /* empty */
#     endif
#    endif
#   endif
#  endif
/*! Actual OBD extended data record list sizes */
#  define DCM_SVC_19_OBD_EXTDATA_RECID_SIZE                          (DCM_SVC_19_NUM_OBD_EXTDATA_RECID + 1)

#  if (DCM_SVC_19_NUM_OBD_EXTDATA_RECID > 0)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
#   define DCM_SVC_19_OBD_EXT_RECORD_ENABLED                         STD_ON
#  endif
# endif

# if defined(DCM_SVC_19_OBD_EXT_RECORD_ENABLED)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/* already set */
# else
#  define DCM_SVC_19_OBD_EXT_RECORD_ENABLED                          STD_OFF
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
#  if ( defined(DCM_SVC_19_NUM_FRZFRAME_RECID) && !defined (DCM_SVC_19_LST_FRZFRAME_RECID)) || \
      (!defined(DCM_SVC_19_NUM_FRZFRAME_RECID) &&  defined (DCM_SVC_19_LST_FRZFRAME_RECID))
#   error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#  else
#   if (defined(DCM_SVC_19_NUM_FRZFRAME_RECID) && defined (DCM_SVC_19_LST_FRZFRAME_RECID))                                                           /* COV_DCM_UNSUPPORTED XF xf xf */
/* the DCM knows the OBD extended data records of the DEM */
#   else
#    if ( defined(DEM_DCM_NUM_FRZFRAME_RECID) && !defined (DEM_DCM_LST_FRZFRAME_RECID)) || \
        (!defined(DEM_DCM_NUM_FRZFRAME_RECID) &&  defined (DEM_DCM_LST_FRZFRAME_RECID))
#     error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#    else
#     if ( defined(DEM_DCM_NUM_FRZFRAME_RECID) && defined (DEM_DCM_LST_FRZFRAME_RECID))                                                              /* COV_DCM_SUPPORT_WITH_MSR_DEM TX tx tx */
/* use the information provided by DEM */
#      define DCM_SVC_19_NUM_FRZFRAME_RECID                          DEM_DCM_NUM_FRZFRAME_RECID
#      define DCM_SVC_19_LST_FRZFRAME_RECID                          DEM_DCM_LST_FRZFRAME_RECID
#     else
#      define DCM_SVC_19_NUM_FRZFRAME_RECID                          0
#      define DCM_SVC_19_LST_FRZFRAME_RECID                          /* empty */
#      error "Missing information for the supported DTC Freeze Frame Records! See DCM TechRef!"
#     endif
#    endif
#   endif
#  endif
/*! Actual complete freeze frame data record list sizes */
#  define DCM_SVC_19_FRZFRAME_RECID_SIZE                             (DCM_SVC_19_NUM_FRZFRAME_RECID    + 1)
# endif
/*! Per default - no patching of DTC status masks required */
# if !defined(DCM_EXT_SVC19_PATCH_CONTEXT)
#  define DCM_EXT_SVC19_PATCH_CONTEXT                                /* not used */
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC22_PROGRESS_DIDLOOKUP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC22_PROGRESS_CHECKCONDITION                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC22_PROGRESS_GETLENGTH                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
# define DCM_SVC22_PROGRESS_READDATA                                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3))
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)
/*! Service 0x23 processing steps */
# define DCM_SVC23_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC23_PROGRESS_READMEMORY                               ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC24_PROGRESS_DIDLOOKUP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC24_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/*! Service 0x27 processing steps */
# define DCM_SVC27_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC27_PROGRESS_SETATTEMPTCNTR                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC27_PROGRESS_SEEDREPEATER                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
# define DCM_SVC27_PROGRESS_KEYREPEATER                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3))
# define DCM_SVC27_PROGRESS_CHECKATTEMPTSEXCEEDED                    ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 4))

/*! Get-Seed port operation classes  */
# define DCM_SVC27_OPCLS_SEED_WITHOUT_ADR                            ((Dcm_Svc27OpClassType)0)
# define DCM_SVC27_OPCLS_SEED_WITH_ADR                               ((Dcm_Svc27OpClassType)1)
# define DCM_SVC_27_LEVEL_MASK                                       (Dcm_UtiGetMaskFromXintType(uint32, DCM_STATE_SECURITY_NUM_LEVELS))
# define DCM_SVC_27_SEED_LVL_INVALID                                 ((uint8)0x00u)
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/*! Service 0x28 processing steps */
# define DCM_SVC28_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))

# define DCM_SVC_28_CTRL_OP_MASK                                     (0x03u)/*!< Leaves the relevant bits for the conversion function "sub-function id -> operation type" since only sub-functions 0x00-0x03 are handled in DCM */
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2A_RATE_TYPE_SLOW                                    ((Dcm_Svc2ASchedRateMemType)0)
# define DCM_SVC2A_RATE_TYPE_MED                                     ((Dcm_Svc2ASchedRateMemType)1)
# define DCM_SVC2A_RATE_TYPE_FAST                                    ((Dcm_Svc2ASchedRateMemType)2)

# define DCM_SVC2A_RATE_TYPE_MASK                                    ((Dcm_Svc2ASchedRateMemType)0x03u)

# define DCM_SVC2A_RATE_TYPE_STOPPED                                 ((Dcm_Svc2ASchedRateMemType)0x10u)
# define DCM_SVC2A_RATE_TYPE_RESERVED                                ((Dcm_Svc2ASchedRateMemType)0x40u)
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2A_MAX_RESPONSE_LEN                                  ((Dcm_UudtFrameSizeType)(DCM_NET_PERIODIC_BUFFER_SIZE - 1u))

# define DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0)) /*!< Look up DIDs */
# define DCM_SVC2A_PROGRESS_DID_CHECKCONDITION                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1)) /*!< Check conditions */
# define DCM_SVC2A_PROGRESS_DID_GETLENGTH                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2)) /*!< Obtain total length of the DID */
# define DCM_SVC2A_PROGRESS_STOPPED_DID_LOOKUP                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3)) /*!< Loop up DIDs and stop periodic transmission */

/*! Service 0x2A transmissionMode parameter */
# define DCM_SVC_2A_SEND_AT_SLOW_RATE                                ((Dcm_Svc2ATransmissionModeType)0x01u)  /*!< Server shall transmit at a slow rate */
# define DCM_SVC_2A_SEND_AT_MEDIUM_RATE                              ((Dcm_Svc2ATransmissionModeType)0x02u)  /*!< Server shall transmit at a medium rate */
# define DCM_SVC_2A_SEND_AT_FAST_RATE                                ((Dcm_Svc2ATransmissionModeType)0x03u)  /*!< Server shall transmit at a fast rate */
# define DCM_SVC_2A_STOP_SENDING                                     ((Dcm_Svc2ATransmissionModeType)0x04u)  /*!< Server stops transmitting periodically/repeatedly */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2C_INVALID_DYNDID_HDL                                (Dcm_UtiMaxValueOfUintType(Dcm_CfgDidMgrDynDidHandleMemType))

# define DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED                        0u

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON) && \
     (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_COND_ENABLED == STD_ON)
#  define DCM_SVC_2C_NUM_PROCESS_CONTEXTS                            2u
#  define DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY                     1u
# else
#  define DCM_SVC_2C_NUM_PROCESS_CONTEXTS                            1u
#  define DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY                     0u
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2C_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP                          ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC2C_PROGRESS_01SRC_DIDCHECKCONDITIONS                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
# define DCM_SVC2C_PROGRESS_01SRC_DIDGETLENGTH                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3))
# define DCM_SVC2C_PROGRESS_03_DIDLOOKUP                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 4))
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2E_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)1)
# define DCM_SVC2E_PROGRESS_WRITEDATA                                ((Dcm_RepeaterProgressType)2)
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2F_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC2F_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC2F_PROGRESS_GETLENGTH                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
# define DCM_SVC2F_PROGRESS_READDATA                                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3))
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
/*! Service 0x31 processing steps */
# define DCM_SVC31_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC3D_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC3D_PROGRESS_WRITEMEMORY                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/*! Service 0x14 processing steps */
# define DCM_SVC85_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC86_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Function-like macros
---------------------------------------------- */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
/*! Extract the size of the length of the memory block from the format BYTE */
# define Dcm_MemMgrGetMemBlockLenSize(formatByte)                    (Dcm_UtiGetHiNibble(formatByte))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Extract the size of the address of the memory block from the format BYTE */
# define Dcm_MemMgrGetMemBlockAddrSize(formatByte)                   (Dcm_UtiGetLoNibble(formatByte))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Extract the information length from the format BYTE */
# define Dcm_MemMgrGetMemBlockInfoLength(formatByte)                 ((uint8)(Dcm_MemMgrGetMemBlockAddrSize(formatByte) + Dcm_MemMgrGetMemBlockLenSize(formatByte))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
/* Check if it is an available ID at all: (id MOD 0x20) == 0 */
# define Dcm_ObdIdMgrIsAvailabilityId(obdId)                         (((obdId) & 0x1Fu) == 0)                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrGetObdIdMaskBit(obdId)                          ((uint32)(0x01UL << (31u - (((obdId)-1u) & 0x1Fu))))                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrIsIdSupported(availMask, obdId)                 (Dcm_UtiBitOpTest(uint32, (availMask), Dcm_ObdIdMgrGetObdIdMaskBit(obdId)))     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrGetAvailabilityIdIdx(obdId)                     ((uint8)(((uint8)(obdId)) >> 5u))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrGetAvailabilityId(id)                           ((uint8)((id) & 0xE0))                                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrGetMaskValue(obdAidId, pMaskData)               ((pMaskData)[Dcm_ObdIdMgrGetAvailabilityIdIdx(obdAidId)])                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/*! AR3.x SchM enter exclusive area implementation */
# define Dcm_UtiArEnvEnterCriticalSection()                          SchM_Enter_Dcm(DCM_EXCLUSIVE_AREA_0)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! AR3.x SchM leave exclusive area implementation */
# define Dcm_UtiArEnvLeaveCriticalSection()                          SchM_Exit_Dcm(DCM_EXCLUSIVE_AREA_0)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/*! AR4.x SchM enter exclusive area adapter implementation */
# define Dcm_UtiArEnvEnterCriticalSection()                          SchM_Enter_Dcm_DCM_EXCLUSIVE_AREA_0()                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! AR4.x SchM leave exclusive area adapter implementation */
# define Dcm_UtiArEnvLeaveCriticalSection()                          SchM_Exit_Dcm_DCM_EXCLUSIVE_AREA_0()                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! AR4.x NvM_GetErrorStatus() API adapter implementation */
# define Dcm_UtiArEnvNvMGetErrorStatus(blockId, nvmStatus)           (NvM_GetErrorStatus((blockId),(nvmStatus)))                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/*! Returns modules initialization state for internal optimized invocations */
#define Dcm_DebugOptIsModuleInitialized()                            (Dcm_DebugInitState == DCM_DEBUG_INITSTATE_INIT)                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Puts DCM into uninitialized state (isolate from the rest of the world) */
#define Dcm_DebugDeInit()                                            (Dcm_DebugInitState = DCM_DEBUG_INITSTATE_UNINIT)                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Memory initialization hook for the debugging sub-component */
#define Dcm_DebugInitMemory()                                        (Dcm_DebugDeInit())                                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Initialization hook for the debugging sub-component */
#define Dcm_DebugInit()                                              (Dcm_DebugInitState = DCM_DEBUG_INITSTATE_INIT)                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Protection against parallel request from another communication channel */
#if(DCM_NET_MULTI_CHANNEL_ENABLED == STD_ON)
# define Dcm_NetMultiChannelEnterCS()                                Dcm_UtiArEnvEnterCriticalSection()                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetMultiChannelLeaveCS()                                Dcm_UtiArEnvLeaveCriticalSection()                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetMultiChannelEnterCS()                                /* not used */
# define Dcm_NetMultiChannelLeaveCS()                                /* not used */
#endif

/*! USDT buffer management */
#define Dcm_NetBufferIsFree(pBufferContext)                          ((pBufferContext)->IsInUseCnt == 0u)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetBufferLock(pBufferContext)                            ((pBufferContext)->IsInUseCnt=1u)                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetBufferRelease(pBufferContext)                         ((pBufferContext)->IsInUseCnt--)                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetBufferUsageEnter(pBufferContext)                      ((pBufferContext)->IsInUseCnt++)                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetBufferUsageLeave(pBufferContext)                      (Dcm_NetBufferRelease(pBufferContext))                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dcm_NetGetConnIdOfRxPduId(rxPduId)                           (Dcm_NetCfgGetConnIdOfRxPduId(DCM_VARMGR_ACTIVE_COMVAR, (rxPduId)))             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetConnIdOfTxPduId(txPduId)                           (Dcm_PbCfgNetTxPdu2ConnMap[(txPduId)])                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
# define Dcm_NetGetProtIdOfActiveProtocol()                          (Dcm_SingletonContext.Network.ActiveProtocol)                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetGetProtIdOfConnection(connId)                        (Dcm_PbCfgNetConnectionInfo[(connId)].ProtRef)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetGetProtIdOfTranspObj(pTranspObj)                     (Dcm_NetGetProtIdOfConnection((pTranspObj)->ConnId))                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetProtIdOfActiveProtocol()                          0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetGetProtIdOfConnection(connId)                        0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetGetProtIdOfTranspObj(pTranspObj)                     0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#define Dcm_NetGetProtObjOfProtId(protId)                            (&Dcm_PbCfgNetProtocolInfo[(protId)])                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetProtObjOfConnection(connId)                        (Dcm_NetGetProtObjOfProtId(Dcm_NetGetProtIdOfConnection(connId)))               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetProtObjOfTranspObj(pTranspObj)                     (Dcm_NetGetProtObjOfConnection((pTranspObj)->ConnId))                           /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
# define Dcm_NetPeriodicMsgGetTxPduIdByConn(connId, txObjIdx)        (Dcm_PbCfgNetPerTxPduIdInfo[Dcm_PbCfgNetConnectionInfo[(connId)].PeriodicTxRef + (txObjIdx)]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgGetNumMsgsFor(connId)                     (Dcm_PbCfgNetConnectionInfo[(connId)].NumPeriodicTxPduIds)                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_NetPeriodicMsgGetTxPduIdCurrConn(txObjIdx)              (Dcm_NetPeriodicMsgGetTxPduIdByConn(Dcm_NetPeriodicMsgGetConnection(),(txObjIdx))) /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_NetPeriodicMsgSetConnection(connId)                     (Dcm_SingletonContext.Network.PeriodicTxContext.ConnIdInUse = (connId))         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgGetConnection()                           (Dcm_SingletonContext.Network.PeriodicTxContext.ConnIdInUse)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgSupportedFor(connId)                      (Dcm_NetPeriodicMsgGetNumMsgsFor(connId) != 0)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_NetPeriodicMsgNumMsgsCurrConnection()                   (Dcm_NetPeriodicMsgGetNumMsgsFor(Dcm_NetPeriodicMsgGetConnection()))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId)             ((Dcm_CfgNetPTxObjHandleOptType)(Dcm_PbCfgNetPerTxPdu2RsrsMap[txPduId]))        /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_NetPeriodicMsgGetNextMsgHdl()                           (Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl)                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgResetNextMsgHdl()                         (Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl = 0u)           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgIncNextMsgHdl()                           (++Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl)              /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_NetPeriodicMsgGetTxObjectSentCntr()                     (Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectSentCntr)               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgResetTxObjectSentCntr()                   (Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectSentCntr = 0u)          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgIncTxObjectSentCntr()                     (++Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectSentCntr)             /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
#  define Dcm_NetPeriodicMsgGetDelayCntr()                           (Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr)                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgIncDelayCntr()                           (++Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgDecDelayCntr()                           (--Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgInitDelayCntr()                          (Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr = DCM_NET_DELAY_BULK_TRANSMISSION) /* PRQA S 3453 */ /* MD_MSR_19.7 */

#  define Dcm_NetPeriodicMsgResetNextDelayTimer()                    (Dcm_SingletonContext.Network.PeriodicTxContext.NextDelayTimer = 0)             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgGetNextDelayTimer()                      (Dcm_SingletonContext.Network.PeriodicTxContext.NextDelayTimer)                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

#  define Dcm_NetPeriodicMsgGetFastestRate()                         (Dcm_SingletonContext.Network.PeriodicTxContext.FastestRate)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgInitFastestRate()                        (Dcm_SingletonContext.Network.PeriodicTxContext.FastestRate = DCM_SVC2A_RATE_TYPE_SLOW) /* PRQA S 3453 */ /* MD_MSR_19.7 */

#  define Dcm_NetGetPeriodicDelayTime(Rate)                          (Dcm_CfgNetPeriodicDelayTime[Rate])                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_NetPeriodicMsgGetDelayCntr()                           0u
#  define Dcm_NetPeriodicMsgIncDelayCntr()                           /* not used */
#  define Dcm_NetPeriodicMsgDecDelayCntr()                           /* not used */
#  define Dcm_NetPeriodicMsgInitDelayCntr()                          /* not used */

#  define Dcm_NetPeriodicMsgGetFastestRate()                         DCM_SVC2A_RATE_TYPE_SLOW
#  define Dcm_NetPeriodicMsgInitFastestRate()                        /* not used */

#  define Dcm_NetGetPeriodicDelayTime(Rate)                          0u
# endif

# define Dcm_NetPTxObjTimerGet(pPeriodicTxObj)                       ((pPeriodicTxObj)->Timer)                                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPTxObjTimerExpired(pPeriodicTxObj)                   (Dcm_NetPTxObjTimerGet(pPeriodicTxObj) == 0u)                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

#endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */

#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
# define Dcm_NetGetSessionConnection()                               (Dcm_SingletonContext.Network.SessionConnection)                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetSetSessionConnection(connId)                         (Dcm_SingletonContext.Network.SessionConnection = (connId))                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetSessionConnection()                               /* not used */
# define Dcm_NetSetSessionConnection(connId)                         /* not used */
#endif

#define Dcm_NetGetComStateByConnection(connId)                       (Dcm_NetGetComStateByChannelId(Dcm_PbCfgNetConnectionInfo[(connId)].NetworkIdRef)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetComStateByRxPduId(rxPduId)                         (Dcm_NetGetComStateByConnection(Dcm_NetGetConnIdOfRxPduId(rxPduId)))            /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dcm_NetGetComStateByTranspObject(pTranspObj)                 (Dcm_NetGetComStateByConnection((pTranspObj)->ConnId))                          /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DCM_NET_CONN_PROPERTIES_ENABLED == STD_ON)
# define Dcm_NetGetProperties(pTranspObj)                            (Dcm_PbCfgNetConnectionInfo[(pTranspObj)->ConnId].Properties)                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetIsPropertieSet(pTranspObj, prop)                     (Dcm_UtiBitOpTest(Dcm_CfgNetConnPropertiesType, Dcm_NetGetProperties(pTranspObj), (prop))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetProperties(pTranspObj)                            /* not used */
# define Dcm_NetIsPropertieSet(pTranspObj, prop)                     /* not used */
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/*! AR 3.x ComM Active Diagnostics notification */
# define Dcm_NetArEnvComMActiveDiag(channel)                         (ComM_DCM_ActiveDiagnostic())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! AR 3.x ComM Inactive Diagnostics notification */
# define Dcm_NetArEnvComMInactiveDiag(channel)                       (ComM_DCM_InactiveDiagnostic())                                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! AR 3.x PduR API adaption */
# define Dcm_NetArEnvPduRCancelReceive(rxPduId)                      (PduR_DcmCancelReceive((rxPduId)))                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetArEnvPduRCancelTransmit(txPduId)                     (PduR_DcmCancelTransmit((txPduId)))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetArEnvGetTransmResult(notifResult)                    ((Dcm_NetTransmissionResultType)(((notifResult) == DCM_NET_ARENV_NTFRSLT_OK)?DCM_E_OK:DCM_E_NOT_OK)) /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_NetGetComStateByChannelId(channelId)                    (Dcm_PbRamNetComMContext[0].ComState)                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/*! AR 4.x ComM Active Diagnostics notification */
# define Dcm_NetArEnvComMActiveDiag(channel)                         (ComM_DCM_ActiveDiagnostic((channel)))                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! AR 4.x ComM Inactive Diagnostics notification */
# define Dcm_NetArEnvComMInactiveDiag(channel)                       (ComM_DCM_InactiveDiagnostic((channel)))                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_PDUR_API_401_ENABLED == STD_ON)
/*! AR 4.0.1 PduR API adaption */
#  define Dcm_NetArEnvGetTransmResult(notifResult)                   ((Dcm_NetTransmissionResultType)(((notifResult) == DCM_NET_ARENV_NTFRSLT_OK)?DCM_E_OK:DCM_E_NOT_OK)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelReceive(rxPduId)                     (PduR_DcmCancelReceiveRequest((rxPduId)))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelTransmit(txPduId)                    (PduR_DcmCancelTransmitRequest((txPduId)))                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# elif (DCM_PDUR_API_403_ENABLED == STD_ON)
/*! AR 4.0.3 PduR API adaption */
#  define Dcm_NetArEnvGetTransmResult(notifResult)                   ((Dcm_NetTransmissionResultType)(((notifResult) == DCM_NET_ARENV_NTFRSLT_OK)?DCM_E_OK:DCM_E_NOT_OK)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelReceive(rxPduId)                     (PduR_DcmCancelReceive((rxPduId)))                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelTransmit(txPduId)                    (PduR_DcmCancelTransmit((txPduId)))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# elif (DCM_PDUR_API_412_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
/*! AR 4.1.2+ PduR API adaption */
#  define Dcm_NetArEnvGetTransmResult(notifResult)                   (notifResult)                                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelReceive(rxPduId)                     (PduR_DcmCancelReceive((rxPduId)))                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelTransmit(txPduId)                    (PduR_DcmCancelTransmit((txPduId)))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  error "Unsupported PduR version!"
# endif

# define Dcm_NetGetComStateByChannelId(channelId)                    (Dcm_PbRamNetComMContext[(channelId)].ComState)                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
# define Dcm_RepeaterSetUser(repUser)                                (Dcm_InstanceContext.Repeater.Contexts.User = (repUser))                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_RepeaterSetUser(repUser)                                /* not used */
#endif

#define Dcm_RepeaterResetOpStatus()                                  (Dcm_InstanceContext.Repeater.Contexts.OpStatus = DCM_INITIAL)

#define Dcm_RepeaterGetProgress()                                    (Dcm_InstanceContext.Repeater.Contexts.Progress)
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
/*! Configuration dependent getter/setter access to the communication control state */
# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
#  define Dcm_ModeGetCommControlState(networkRef)                    (Dcm_PbRamNetComCtrlChannels[(networkRef)])                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_ModeSetCommControlState(networkRef, mode)              (Dcm_NetSetComControlChannelState((networkRef), (mode)))                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_ModeGetCommControlState(networkRef)                    /* not used */
#  define Dcm_ModeSetCommControlState(networkRef, mode)              /* not used */
# endif

/*! Configuration dependent getter/setter access to the DTC setting state */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
#  define Dcm_ModeGetControlDtcSettingMode()                         (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.Mode)                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_ModeSetControlDtcSettingMode(newMode)                  (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.Mode = (newMode))                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_ModeGetControlDtcSettingMode()                         /* not used */
#  define Dcm_ModeSetControlDtcSettingMode(newMode)                  /* not used */
# endif

/*! Configuration dependent getter/setter access to the DTC group associated to the already set DTC setting's state */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON) && \
     (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
#  define Dcm_ModeGetControlDtcSettingGroup()                        (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.DTCGroup)                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_ModeSetControlDtcSettingGroup(newGroup)                (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.DTCGroup = (newGroup))             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_ModeGetControlDtcSettingGroup()                        /* not used */
#  define Dcm_ModeSetControlDtcSettingGroup(newGroup)                /* not used */
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/*! AR 3.x BswM ComunicationControl related notification adapter */
# define Dcm_ModeArEnvBswMComControlModeChange(network, newMode)     (BswM_Dcm_RequestCommunicationMode((network), (newMode)))                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! AR 3.x EcuReset related notification adapters */
# define Dcm_ModeMgrArEnvSwitchReqEcuReset(newMode)                  (Dcm_ModeSwitchEcuReset(newMode))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchAckEcuReset()                         (Dcm_ModeSwitchAckEcuReset())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_ModeMgrArEnvSwitchReqRapidPowerShutDown(newMode)        (Dcm_ModeSwitchEcuReset(newMode))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchAckRapidPowerShutDown()               (Dcm_ModeSwitchAckEcuReset())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/*! AR 4.x BswM ComunicationControl related notification adapter */
# define Dcm_ModeArEnvBswMComControlModeChange(network, newMode)     (BswM_Dcm_CommunicationMode_CurrentState((network), (newMode)))                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! AR 4.x EcuReset related notification adapters */
# define Dcm_ModeMgrArEnvSwitchReqEcuReset(newMode)                  (Dcm_ModeSwitchEcuReset(newMode))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchAckEcuReset()                         (Dcm_ModeSwitchAckEcuReset())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchReqRapidPowerShutDown(newMode)        (Dcm_ModeSwitchRapidShutDown(newMode))                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchAckRapidPowerShutDown()               (Dcm_ModeSwitchAckRapidShutDown())                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/*! Set the new (not yet finally committed, but probably "will become active") diagnostic session */
#define Dcm_StateSetPendingSession(session)                          (Dcm_SingletonContext.StateMgr.PendingSession = (session))                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns the new (not yet finally committed, but probably "will become active") diagnostic session */
#define Dcm_StateGetPendingSession()                                 (Dcm_SingletonContext.StateMgr.PendingSession)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Synchronizes both pending and committed (active) diagnostic session to have the same state (i.e. the pending session becomes the state of the last valid diagnostic session */
#define Dcm_StateSyncPendingSession()                                (Dcm_StateSetPendingSession(Dcm_SingletonContext.StateMgr.Preconditions.Session)) /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Returns the diagnostic state related pre-conditions of a diagnostic entity */
#define Dcm_StateGetPreconditionStates(precondPckgRef)               (Dcm_CfgStatePreconditions[(precondPckgRef)].States)                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns the currently active (committed) diagnostic session state */
#define Dcm_StateGetSession()                                        (Dcm_SingletonContext.StateMgr.Preconditions.Session)                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns the diagnostic session pre-condition(s) of a diagnostic entity */
#define Dcm_StateGetPreconditionSession(precondPckgRef)              (Dcm_StateGetPreconditionStates(precondPckgRef).Session)                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/*! Returns the currently active security access level related state */
# define Dcm_StateGetSecurity()                                      (Dcm_SingletonContext.StateMgr.Preconditions.Security)                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns the security access pre-condition(s) of a diagnostic entity */
# define Dcm_StateGetPreconditionSecurity(precondPckgRef)            (Dcm_StateGetPreconditionStates(precondPckgRef).Security)                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif
/*! Returns TRUE if current (committed) diagnostic session is the Default-Session. Otherwise returns FALSE */
#define Dcm_StateIsDefaultSessionActive()                            ((Dcm_StateGetSession() & DCM_STATE_VALUE_SESSION_INIT) != 0)                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns TRUE if the diagnostic session precondition of a diagnostic entity is met */
#define Dcm_StateIsSupportedInSession(preconditionPackage)           ((Dcm_StateGetSession() & (preconditionPackage).Session) != 0)                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns the diagnostic session ID of the diagnostic session state */
#define Dcm_StateGetSessionValue(stateIdx)                           (Dcm_CfgStateSessionInfo[stateIdx].Value)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/*! Returns TRUE if current security level is the Locked-Level. Otherwise returns FALSE */
# define Dcm_StateIsSecurityLocked()                                 ((Dcm_StateGetSecurity() & DCM_STATE_VALUE_SECURITY_INIT) != 0)                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns TRUE if the security access pre-condition of a diagnostic entity is met */
# define Dcm_StateIsSupportedInSecurityLevel(preconditionPackage)    ((Dcm_StateGetSecurity() & (preconditionPackage).Security) != 0)                /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns the security access level ID of the security access state */
# define Dcm_StateGetSecurityValue(stateIdx)                         ((Dcm_SecLevelType)(((stateIdx) == 0)?0u:Dcm_CfgStateSecurityInfo[(stateIdx)-1u].Value)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DCM_STATE_MULTIPLE_SECURITYFIXEDBYTES_ENABLED == STD_ON)
# define Dcm_StateGetVsgMaskInfoIdx(stateIdx)                        (Dcm_CfgStateVsgSecurityFixedByteInfo[(stateIdx)])                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_StateGetNumberOfVsgs(stateIdx)                          ((Dcm_VsgSizeType)(Dcm_CfgStateVsgSecurityFixedByteInfo[(stateIdx) + 1] - Dcm_CfgStateVsgSecurityFixedByteInfo[(stateIdx) + 0])) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_StateGetVsgMaskInfoIdx(stateIdx)                        (stateIdx)                                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_StateGetNumberOfVsgs(stateIdx)                          (((Dcm_CfgStateSecurityFixedByteInfo[(stateIdx) + 1] - Dcm_CfgStateSecurityFixedByteInfo[(stateIdx) + 0]) > 0)?1u:0u) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif
/*! Returns the current events of a specific task */
#define Dcm_TskGetEvent(taskId)                                      (Dcm_SingletonContext.TaskMgr.TaskContext[(taskId)].TaskEvents)                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Task runtime flag management abstraction */
#if (DCM_TSK_TASK_FLAG_SUPPORT_ENABLED == STD_ON)
# define Dcm_TskIsFlagSet(pTaskContext, flg)                         (Dcm_UtiBitOpTest(Dcm_TskTaskFlagType, (pTaskContext)->TaskFlags, (flg)))       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskSetFlag(pTaskContext, flg)                           (Dcm_UtiBitOpSet(Dcm_TskTaskFlagType, (pTaskContext)->TaskFlags, (flg)))        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskClrFlag(pTaskContext, flg)                           (Dcm_UtiBitOpClr(Dcm_TskTaskFlagType, (pTaskContext)->TaskFlags, (flg)))        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_TskIsFlagSet(pTaskContext)                              FALSE /* not used */
# define Dcm_TskSetFlag(pTaskContext, flg)                           /* not used */
# define Dcm_TskClrFlag(pTaskContext, flg)                           /* not used */
#endif

/*! Task activation tracing utilities. Used to detect whether a function call (API) is performed while any or a specific task is (not) running */
#if (DCM_TSK_TRACING_ENABLED == STD_ON)
# define Dcm_TskTraceInit()                                          (Dcm_UtiStackInit(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskTraceTskPush(taskId)                                 (Dcm_UtiStackPush(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack, (Dcm_TskMgrTraceStackBaseType)(taskId))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskTraceTskPop()                                        (Dcm_UtiStackPop(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskTraceIsFull()                                        (Dcm_UtiStackIsFull(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack, Dcm_TskMgrTraceStackBaseType)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskTraceIsEmpty()                                       (Dcm_UtiStackIsEmpty(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))        /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Returns the ID of the task currently executed */
# define Dcm_TskTraceGetCurrTskId()                                  (Dcm_UtiStackTop(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_TskTraceInit()                                          /* not used */
# define Dcm_TskTraceTskPush(taskId)                                 /* not used */
# define Dcm_TskTraceTskPop()                                        /* not used */
# define Dcm_TskTraceIsFull()                                        /* not used */
# define Dcm_TskTraceIsEmpty()                                       /* not used */

# define Dcm_TskTraceGetCurrTskId()                                  /* not used */
#endif
/*! Gets the value of a timer of the given timerId */
#define Dcm_TmrGetTimer(timerId)                                     ( Dcm_SingletonContext.TimerMgr.Timer[(timerId)] )                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_TmrIsTimerRunning(timerId)                               ( Dcm_UtiBitOpTest(Dcm_TmrMaskMemType, Dcm_SingletonContext.TimerMgr.RunningMask, Dcm_UtiGetBitFromIndex(Dcm_TmrMaskMemType, (timerId))) ) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_TmrSetTimerStopped(timerId)                              ( Dcm_UtiBitOpClr (Dcm_TmrMaskMemType, Dcm_SingletonContext.TimerMgr.RunningMask, Dcm_UtiGetBitFromIndex(Dcm_TmrMaskMemType, (timerId))) ) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_TmrSetTimerRunning(timerId)                              ( Dcm_UtiBitOpSet (Dcm_TmrMaskMemType, Dcm_SingletonContext.TimerMgr.RunningMask, Dcm_UtiGetBitFromIndex(Dcm_TmrMaskMemType, (timerId))) ) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
# define Dcm_DidMgrIsOpSupported(pDidInfo,   op)                     (((op) & (pDidInfo)->Operations) != 0)                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_DidMgrIsOpTypeSupported(pDidOpInfo, opType)             (((opType) & (pDidOpInfo)->CallTypes) != 0)                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_DIDMGR_DYNDID_DEEP_CHECK_ON_READ_ENABLED == STD_ON)
/* a real function is used for optimal code size */
# else
#  define Dcm_DidMgrDynDidStateCheck(pDidInfoContext, pErroCode)     (Dcm_DidMgrStaticDidStateCheck(Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext)->ExecCondRef, (pErroCode))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# define Dcm_DidMgrStaticDidStateCheck(ExecCondRef, pErroCode)       (Dcm_StateCheck((ExecCondRef), DCM_DIAG_CHK_LVL_PARAMETER, (pErroCode)))        /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
#  define Dcm_DidMgrGetCtrlEnblMaskLength(pDidInfo)                  (Dcm_CfgDidMgrOpInfoIoControl[Dcm_DidMgrOpInfoRedirector((pDidInfo)->OpRef, OpRefIoControl)].CtrlEnblMaskLength) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_DidMgrGetCtrlEnblMaskHandling(pDidInfo)                (Dcm_CfgDidMgrOpInfoIoControl[Dcm_DidMgrOpInfoRedirector((pDidInfo)->OpRef, OpRefIoControl)].CtrlEnblMaskHandling) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_DidMgrGetCtrlEnblMaskLength(pDidInfo)                  0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_DidMgrGetCtrlEnblMaskHandling(pDidInfo)                DCM_DIDMGR_IO_CEMR_HANDLING_NO                                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
#  define Dcm_DidMgrGetCtrlOpInfoRef(opRef)                          (Dcm_CfgDidMgrOpInfoIoControl[opRef].RetCtrlToEcuOpRef)                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_DIDMGR_IODID_EXEC_PRECOND_LIMIT_ENABLED == STD_ON)
#  define Dcm_DidMgrGetCtrlOpExecCondRef(opRef)                      (Dcm_CfgDidMgrOpInfoIoControl[opRef].CtrlExecCondRef)                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# define Dcm_DidMgrGetDynDidSize(dynDidHandle)                       (Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].NumItems)                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle)            (Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].SrcItemRef)                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
#  define Dcm_DidMgrGetDynDidReadExecPrecond(dynDidHandle)           (Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].ReadExecCondRef)                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
#  define Dcm_DidMgrGetDynDidIdFromHandle(dynDidHandle)              ((Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].Did))                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/*! Converts sub-function ID to the internal routine operation value */
# define Dcm_RidMgrConvOpOfSubFunc(sf)                               ((Dcm_RidMgrOpType)(((sf) < 4)?Dcm_RidMgrSubFunc2OpMap[(sf)]:0u))               /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Performs a state check for specific RID pre-condition reference */
# define Dcm_RidMgrStateCheckRid(execCondRef, pErrorCode)            (Dcm_StateCheck((execCondRef), DCM_DIAG_CHK_LVL_PARAMETER, (pErrorCode)))       /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Access abstraction for RID information table */
# define Dcm_CfgRidMgrRidInfoOpBaseIdx(idx)                          (Dcm_CfgRidMgrRidInfo[(idx)].OpBaseIdx)                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrRidInfoExecCondRef(idx)                        (Dcm_CfgRidMgrRidInfo[(idx)].ExecCondRef)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrRidInfoOperations(idx)                         (Dcm_CfgRidMgrRidInfo[(idx)].Operations)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrRidInfoRoutineInfoByte(idx)                    (Dcm_CfgRidMgrRidInfo[(idx)].RoutineInfoByte)                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Access abstraction for RID operation information table */
# define Dcm_CfgRidMgrOpInfoOpFunc(idx)                              (Dcm_CfgRidMgrOpInfo[(idx)].OpFunc)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrOpInfoReqMinLength(idx)                        (Dcm_CfgRidMgrOpInfo[(idx)].ReqMinLength)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrOpInfoReqMaxLength(idx)                        (Dcm_CfgRidMgrOpInfo[(idx)].ReqMaxLength)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrOpInfoResMinLength(idx)                        (Dcm_CfgRidMgrOpInfo[(idx)].ResMinLength)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrOpInfoOpType(idx)                              (Dcm_CfgRidMgrOpInfo[(idx)].OpType)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
/*! Splittask related critical section management */
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
# define Dcm_SplitTaskEnterCS()                                      Dcm_UtiArEnvEnterCriticalSection()                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_SplitTaskLeaveCS()                                      Dcm_UtiArEnvLeaveCriticalSection()                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_SplitTaskEnterCS()                                      /* Not used */
# define Dcm_SplitTaskLeaveCS()                                      /* Not used */
#endif
/*! Getter/Setter of the transport object carrying the diagnostic request currently in processing */
#define Dcm_DiagGetTranspObj()                                       (Dcm_NetGetTransportObject(Dcm_InstanceContext.Diag.TObjHdl))                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_DiagSetTranspObj(tObjPtr)                                (Dcm_InstanceContext.Diag.TObjHdl = (tObjPtr)->Handle)                          /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Abstract interface of getter of the transport object carrying the diagnostic request to be processed at next Dcm_DiagTaskWorker() activation */
#if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON)
/*! Get/Set the queued transport object */
# define Dcm_DiagGetQueuedTranspObj()                                (Dcm_NetGetTransportObject(Dcm_InstanceContext.Diag.QueuedSet.TObjHdl))         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
/*! No queuing needed, do directly get the transport object in processing */
# define Dcm_DiagGetQueuedTranspObj()                                (Dcm_DiagGetTranspObj())                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif
/*! Abstract interface of the RCR-RP limiter counter management */
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
/*! Reset the RCR-RP limiter */
# define Dcm_DiagResetRcrRpLimiter()                                 (Dcm_InstanceContext.Diag.NumRcrRpTimeouts = DCM_DIAG_RCRRP_LIMIT_COUNT)        /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Get current RCR-RP limiter value */
# define Dcm_DiagGetRcrRpLimiter()                                   (Dcm_InstanceContext.Diag.NumRcrRpTimeouts)                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Decrement by one RCR-RP limiter value */
# define Dcm_DiagDecrementRcrRpLimiter()                             (--Dcm_InstanceContext.Diag.NumRcrRpTimeouts)                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_DiagResetRcrRpLimiter()                                 /* not used */
# define Dcm_DiagGetRcrRpLimiter()                                   /* not used */
# define Dcm_DiagDecrementRcrRpLimiter()                             /* not used */
#endif
/*! Variant bitmap access */
#define Dcm_VarMgrBitSetCalcSize(bits)                               (Dcm_UtiBitSetCalcSize(Dcm_CfgVarMgrBitSetBaseType, (bits)))                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_VarMgrBitSetTestBit(bitSet, bit)                         (Dcm_UtiBitSetTestBit(Dcm_CfgVarMgrBitSetBaseType, (bitSet), (bit)))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_VarMgrBitSetSetBit(bitSet, bit)                          (Dcm_UtiBitSetSetBit(Dcm_CfgVarMgrBitSetBaseType, (bitSet), (bit)))             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_VarMgrBitSetClrBit(bitSet, bit)                          (Dcm_UtiBitSetClrBit(Dcm_CfgVarMgrBitSetBaseType, (bitSet), (bit)))             /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! EcuM notification for run-time variant initialization errors */
#if(DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_EcuMErrorNotification(errorCode)                        (EcuM_BswErrorHook((uint16) DCM_MODULE_ID, (uint8) (errorCode)))                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_EcuMErrorNotification(errorCode)                        /* not used */
#endif
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! Per default - all patching hooks of DTC status masks are not required */
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusInit)
#  define Dcm_ExtSvc19UtiPatchDtcStatusInit()                        /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest)
#  define Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(dtcStatusPtr)  /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusApplyByResult)
#  define Dcm_ExtSvc19UtiPatchDtcStatusApplyByResult(dtcStatusPtr)   /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusSetForApply)
#  define Dcm_ExtSvc19UtiPatchDtcStatusSetForApply()                 /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter)
#  define Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(dtcStatusMaskPtr) /* not used */
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc27OnStateChanged()                                   (Dcm_Svc27ResetSequence())                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27ResetSequence()                                    (Dcm_InstanceContext.Diag.Services.Svc27.SeedLevel = DCM_SVC_27_SEED_LVL_INVALID) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27IsKeyRequestExpected()                             ((boolean)(Dcm_InstanceContext.Diag.Services.Svc27.SeedLevel != DCM_SVC_27_SEED_LVL_INVALID)) /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_Svc27GetSecLvlRef(subSvcRef)                            ((uint8)((subSvcRef) / 2u))                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27IsKeyRequest(subSvcRef)                            ((boolean)(((subSvcRef) & 0x01u) != 0u)) /* Odd subSvcRef means "send key" request */ /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27IsThisKeyRequestExpected(secLvlRef)                ((boolean)(Dcm_CfgStateSecurityInfo[secLvlRef].Value == Dcm_InstanceContext.Diag.Services.Svc27.SeedLevel)) /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_SVC_27_MULTI_ATTEMPT_COUNTER_ENABLED == STD_ON)
#  define Dcm_Svc27GetCounterIdx(secLvl)                             (secLvl)                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_Svc27GetCounterIdx(secLvl)                             0u
# endif

# if (DCM_SVC_27_MULTI_DELAY_TIMER_ENABLED == STD_ON)
#  define Dcm_Svc27GetTimerIdx(secLvl)                               (secLvl)                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_Svc27GetTimerIdx(secLvl)                               0u
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
#  if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
#   define Dcm_Svc27ReloadReadFailedGet(secLev)                      (Dcm_UtiBitOpTest(uint32, Dcm_InstanceContext.Diag.Services.Svc27.ReloadMask, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, (secLev)))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27ReloadReadFailedSet(secLev)                      (Dcm_UtiBitOpSet(uint32, Dcm_InstanceContext.Diag.Services.Svc27.ReloadMask, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, (secLev)))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  else
#   define Dcm_Svc27ReloadReadFailedGet(secLev)                      /* not used */
#   define Dcm_Svc27ReloadReadFailedSet(secLev)                      /* not used */
#  endif
#  define Dcm_Svc27CounterGet(secLev)                                (Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[Dcm_Svc27GetCounterIdx((secLev))]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc27CounterReset(secLev)                              (Dcm_Svc27CounterSet((secLev), 0u))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc27TimerGet(secLev)                                  (Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[Dcm_Svc27GetTimerIdx((secLev))]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc27TimerReset(secLev)                                (Dcm_Svc27TimerSet((secLev), 0u))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc27TimerActive(secLev)                               ((boolean)(Dcm_Svc27TimerGet((secLev)) != 0u))                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc27TimerJustExpired(mask, secLev)                    ((boolean)(Dcm_UtiBitOpTest(uint32, (mask), Dcm_UtiGetBitFromIndex(uint32_least, Dcm_Svc27GetTimerIdx((secLev)))))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_Svc27CounterGet(secLev)                                /* not used */
#  define Dcm_Svc27CounterReset(secLev)                              /* not used */
#  define Dcm_Svc27TimerGet(secLev)                                  /* not used */
#  define Dcm_Svc27TimerReset(secLev)                                /* not used */
#  define Dcm_Svc27TimerActive(secLev)                               /* not used */
#  define Dcm_Svc27TimerJustExpired(mask, secLev)                    /* not used */
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2ASchdGetFreeSpace()                                 ((Dcm_Svc2ASchdItemHandleMemType)(DCM_SVC_2A_SCHEDULER_SIZE - Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2AGetSchedulingTimeOfEntry(pSchedTableEntry)         (Dcm_CfgSvc2ASchdRateTime[(pSchedTableEntry)->Rate & DCM_SVC2A_RATE_TYPE_MASK]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2AIsPeriodicDid(did)                                 ((((uint16)(did)) & 0xFF00u) == 0xF200u)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2AMakePeriodicDid(didLoByte)                         (Dcm_UtiMake16Bit((uint8)0xF2u, (didLoByte)))                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2AMakeSchdRateFromUdsRate(udsRate)                   (Dcm_Svc2ASchedRateMemType)((udsRate)-1u)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*
 * UDS rates 0 and 5-7 are rejected because respective bits in bitmask are not set
 * UDS rate of 8 and above is rejected because bit-shift always yields 0
 */
# define Dcm_Svc2AIsUdsRateSupported(udsRate)                        ((DCM_SVC_2A_SUPPORTED_RATES & Dcm_UtiGetBitFromIndex(uint8, (udsRate))) != 0)  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2CIsDidSrcItem(srcItemIdx)                           (Dcm_UtiGenericBitSetTestBit(Dcm_InstanceContext.Diag.Services.Svc2C.Sequencer,(srcItemIdx))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2CSetDidSrcItem(srcItemIdx)                          (Dcm_UtiGenericBitSetSetBit(Dcm_InstanceContext.Diag.Services.Svc2C.Sequencer,(srcItemIdx))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2CSetMemSrcItem(srcItemIdx)                          (Dcm_UtiGenericBitSetClrBit(Dcm_InstanceContext.Diag.Services.Svc2C.Sequencer,(srcItemIdx))) /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_Svc2CGetSrcItemIndex(dynDidHandle, offset)              ((Dcm_CfgDidMgrDynDidSrcItemIdxMemType)(Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle) + (offset))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2CIsDynDidDefined(dynDidHandle)                      (Dcm_Svc2CGetItem(dynDidHandle)->Count != 0u)                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2CIsDidDefined(pDidInfo)                             ((!Dcm_DidMgrIsOpSupported((pDidInfo), DCM_DIDMGR_OP_DEFINE)) || Dcm_Svc2CIsDynDidDefined((pDidInfo)->OpRef)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2CGetMaxDynDidProtocolLen()                          ((Dcm_CfgNetBufferSizeMemType)(Dcm_NetGetBufferInfo(Dcm_DiagGetTranspObj()->BufferHdl)->Size - 3u)) /* for response: 0x62 DID_H DID_L <DATA> */ /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2FIsDidActive(ioDidHdl)                              (Dcm_UtiGenericBitSetTestBit(Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids,(ioDidHdl))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2FSetDidActive(ioDidHdl)                             (Dcm_UtiGenericBitSetSetBit(Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids,(ioDidHdl))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2FClrDidActive(ioDidHdl)                             (Dcm_UtiGenericBitSetClrBit(Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids,(ioDidHdl))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Typedefs Exported Level 3
---------------------------------------------- */
/*! Pointer to a execution precondition reference index located in the DCM ROM data */
typedef P2CONST(Dcm_CfgStateRefMemType, TYPEDEF, DCM_CONST)  Dcm_CfgStateRefMemPtrType;

/*! Control data of the sub-component state manager */
struct DCM_STATECONTEXTTYPE_TAG
{
  Dcm_CfgStateDiagStateInfoType Preconditions;   /*!< Current (active) state of all diagnostic state related execution pre-conditions */
  Dcm_CfgStateGroupMemType      PendingSession;  /*!< Pending diagnostic session, still in transition, waiting for the diagnostic service processing confirmation */
};
typedef struct DCM_STATECONTEXTTYPE_TAG Dcm_StateContextType;
/*! Variant reference data type (derived from the execution precondition references since it is part of the pre-conditions and located in the same table) */
typedef Dcm_CfgStateRefMemPtrType  Dcm_VarRefMemPtrType;
typedef uint16 Dcm_VsgSizeType;
/* ----------------------------------------------
 ~&&&   Typedefs Exported Level 2
---------------------------------------------- */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
typedef uint8 Dcm_MemMgrAccessType;
typedef uint8 Dcm_MemMgrMemoryOpType;

/*! Shared memory block descriptor data type for other service processors (e.g. 0x2C) */
struct DCM_MEMMGRMEMBLOCKTYPE_TAG
{
  Dcm_CfgMemMgrReqAddrType  Address;  /*!< The address to access */
  Dcm_CfgMemMgrReqSizeType  Length;   /*!< The number of bytes requested */
# if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
  uint8                     Mid;      /*!< The memory identifier */
# endif
};
typedef struct DCM_MEMMGRMEMBLOCKTYPE_TAG Dcm_MemMgrMemBlockType;
typedef P2VAR(Dcm_MemMgrMemBlockType, TYPEDEF, DCM_VAR_NOINIT)   Dcm_MemMgrMemBlockPtrType;
typedef P2CONST(Dcm_MemMgrMemBlockType, TYPEDEF, DCM_VAR_NOINIT) Dcm_MemMgrMemBlockConstPtrType;
# if (DCM_MEMMGR_RAM_CONTEXT_ENABLED == STD_ON)
/*! Control data of the memory manager */
struct DCM_MEMMANAGERCONTEXTTYPE_TAG
{
#  if(DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
  Dcm_MemMgrAccessType  LockedByClient; /*!< Identifier of client that currently uses the memory manager */
#  endif
};
typedef struct DCM_MEMMANAGERCONTEXTTYPE_TAG Dcm_MemManagerContextType;
# endif
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)
/*! Request parser temporary processing context */
struct DCM_OBDIDMGRDESCTYPE_TAG
{
  Dcm_Uint8ConstDataPtrType    LookUpTable;         /*!< IN: The OBD ID lookup table */
  Dcm_VarRefMemPtrType         LookUpFilterTable;   /*!< IN: List of OBD ID related filters */
  Dcm_ObdMaskConstDataPtrType  MaskData;            /*!< IN: The calibrated OBD ID mask */
  Dcm_ObdIdMgrHandleMemType    Handle;              /*!< OUT: ID specific handle */
};
typedef struct DCM_OBDIDMGRDESCTYPE_TAG Dcm_ObdIdMgrDescType;
typedef P2VAR(Dcm_ObdIdMgrDescType, TYPEDEF, DCM_VAR_NOINIT) Dcm_ObdIdMgrDescPtrType;
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
typedef P2CONST(Dcm_CfgNetBufferInfoType, TYPEDEF, DCM_CONST_PBCFG) Dcm_PbCfgNetBufferInfoPtrType;
typedef P2VAR(Dcm_CfgNetBufferSizeOptType, TYPEDEF, DCM_VAR_NOINIT) Dcm_CfgNetBufferSizePtrType;
typedef boolean Dcm_NetActiveDiagnosticType;

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/*! Periodic message transmitter control states */
struct DCM_NETPERIODICTXCONTEXTTYPE_TAG
{
  DCM_PB_RAM_DATA_DECL(Dcm_NetPeriodicTxObjectType, TxObject, DCM_NET_MAX_NUM_PERIODIC_TX_OBJ) /*!< Periodic message control objects */
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  DCM_VOLATILE_ON_SPLITTASK Dcm_TmrTimerCntrMemType DelayTimer[DCM_NET_DELAY_BULK_TRANSMISSION]; /*!< Array of delay timers that assure gap times between periodic DIDs */
  Dcm_CfgNetPTxObjHandleMemType    DelayCntr;        /*!< Number of remaining messages that can be dispatched before a delay is required */
  uint8                            NextDelayTimer;   /*!< Index of next delay timer to use */
  uint8                            FastestRate;      /*!< The fastest rate in which periodic DIDs are currently scheduled */
# endif
  Dcm_NetConnRefMemType            ConnIdInUse;      /*!< Current owner (diagnostic client) of the periodic transmitter */
  Dcm_CfgNetPTxObjHandleMemType    NextTxObjectHdl;  /*!< Pointer to the next periodic message to be sent. Scope is only the current periodic transmitter owners list of periodic messages */
  Dcm_CfgNetPTxObjHandleMemType    TxObjectSentCntr; /*!< Keeps track of the already sent periodic messages. Scope is only the current periodic transmitter owners list of periodic messages */
};
typedef struct DCM_NETPERIODICTXCONTEXTTYPE_TAG Dcm_NetPeriodicTxContextType;

typedef P2VAR(Dcm_NetPeriodicTxObjectType, TYPEDEF, DCM_RAM_PBCFG) Dcm_NetPeriodicTxObjectPtrType;
#endif

typedef P2VAR(Dcm_NetTransportObjectType, TYPEDEF, DCM_VAR_NOINIT) Dcm_NetTransportObjectPtrType;
typedef P2VAR(Dcm_NetComMContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_NetComMContextPtrType;
typedef P2VAR(Dcm_NetBufferContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_NetBufferContextPtrType;

/*! Control states of the network sub-component */
struct DCM_NETCONTEXTTYPE_TAG
{
  DCM_PB_RAM_DATA_DECL(Dcm_NetBufferContextType, BufferContext, DCM_NET_NUM_BUFFERS)                  /*!< Control states of the USDT message buffers (main and additional) */
  DCM_PB_RAM_DATA_DECL(Dcm_NetTransportObjectType, TransportObject, DCM_NET_MAX_NUM_TRANSP_OBJECTS)   /*!< Transport objects for simultaneous servicing of multiple clients */
  DCM_PB_RAM_DATA_DECL(Dcm_NetComMContextType, ComMContext, DCM_NET_MAX_NUM_COMM_CHANNELS)            /*!< Control states of ComM status notifications per DCM related com-channel (i.e. channel on which DCM communicates with a client */
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  Dcm_NetPeriodicTxContextType  PeriodicTxContext;                                                    /*!< Composition relation to the periodic message transmitter */
#endif
  DCM_PB_RAM_DATA_DECL(Dcm_CfgNetTObjHandleMemType, ConnId2TObjIdMap, DCM_NET_MAX_NUM_CONNECTIONS)    /*!< A map of type <key = connectionId, value = TransportObject>. Used for fast transport object allocation */
#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  DCM_PB_RAM_DATA_DECL(Dcm_CommunicationModeType, ComCtrlChannels, DCM_NET_MAX_NUM_ALL_COMM_CHANNELS) /*!< Communication state [Rx/Tx][On/Off] of each ComM channel known to DCM */
#endif
#if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
  Dcm_NetProtRefMemType         ActiveProtocol;                                                       /*!< The protocol handle last activated */
#endif
  Dcm_NetConnRefMemType         NumActiveConnections;                                                 /*!< Current number of simultaneously serviced clients/connections */
#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  Dcm_NetConnRefMemType         SessionConnection;                                                    /*!< Owner (client) of the non-default session last started */
#endif
  Dcm_NetActiveDiagnosticType   ActiveDiagnostic;                                                     /*!< Guard for prevention of DCMs automatic ComM diag-activate signal notification (this state is managed by the application) */
#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
  boolean                       RxAllowed;                                                            /*!< Guard for global blocking of any request reception */
#endif
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
  boolean                       KeepAlive;                                                            /*!< Guard for prevention of diag-inactive notifications from DCM to ComM (e.g. in the default-session) */
#endif
};
typedef struct DCM_NETCONTEXTTYPE_TAG Dcm_NetContextType;
typedef uint8 Dcm_PagedBufferStateType;
typedef uint8 Dcm_PagedBufferDataProvisionStateType;

/*! Paged-buffer control data */
struct DCM_PAGEDBUFFERCONTEXTTYPE_TAG
{
  Dcm_MsgLenType                        RemainingLen;                 /*!< Keeps track on the data exchange progress */
  Dcm_CfgNetBufferSizeMemType           WriteIndex;                   /*!< Pointer to the next free buffer position ready to be written with new data portion */
  Dcm_CfgNetBufferSizeMemType           ReadIndex;                    /*!< Pointer to the next ready-to-send buffer position */
  Dcm_PagedBufferStateType              State;                        /*!< Paged-buffer state machine */
  Dcm_CfgNetBufferRefMemType            BufferHdl;                    /*!< Zero based reference to the USDT buffer object in use */
  uint8                                 UpdateFuncRef;                /*!< Zero based reference to the data provider handler Xxx_<Name>Update */
  uint8                                 CancelFuncRef;                /*!< Zero based reference to the data provider cancellation notification Xxx_<Name>Cancel */
  boolean                               UpdateFinished;               /*!< Data provider will no longer be called (job done) */
  Dcm_PagedBufferDataProvisionStateType UpdaterDataProvisionState;    /*!< Data provision state of Updater */
  Dcm_OpStatusType                      OpStatus;                     /*!< Current operation status */
};
typedef struct DCM_PAGEDBUFFERCONTEXTTYPE_TAG Dcm_PagedBufferContextType;
typedef uint8 Dcm_RepeaterProgressType;
typedef uint8 Dcm_RepeaterUserType;
typedef P2CONST(Dcm_CfgDiagServiceInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgDiagServiceInfoPtrType;
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
/*! DTC setting control states */
struct DCM_MODECTRLDTCSETTINGCONTEXTTYPE_TAG
{
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
  uint32                             DTCGroup;               /*!< The DTC group associated with the disabled DTC setting state */
#  endif
  Rte_ModeType_DcmControlDtcSetting  Mode;                   /*!< Current DTC setting state (ENABLEDTCSETTING, DISABLEDTCSETTING) */
  uint8                              LastDisableDTCClientID; /*!< ClientID that was last used to disable DTC setting */
};
typedef struct DCM_MODECTRLDTCSETTINGCONTEXTTYPE_TAG Dcm_ModeCtrlDtcSettingContextType;
# endif

/*! Control data of the mode manager sub-component */
struct DCM_MODECONTEXTTYPE_TAG
{
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  Dcm_ModeCtrlDtcSettingContextType CtrlDtcSetting; /*!< DTC setting mode management control data */
# else
  uint8 spare;                                      /*!< Reserved unused place for future extensions */
# endif
};
typedef struct DCM_MODECONTEXTTYPE_TAG Dcm_ModeContextType;
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
typedef uint8        Dcm_TskTaskPrioMemType;
typedef uint8_least  Dcm_TskTaskPrioOptType;

typedef uint8        Dcm_TskTaskAttributeType;
typedef uint8        Dcm_TskTaskFlagType;

typedef Dcm_TskTaskIdMemType  Dcm_TskMgrTraceStackBaseType;
/*! Stack with the running tasks (entry per task priority) */
typedef Dcm_UtiStackType(Dcm_TskMgrTraceStackBaseType, DCM_TSK_NUM_PRIOS) Dcm_TskMgrTraceStackType;

/*! Single task runtime data */
struct DCM_TSKTASKCONTEXTTYPE_TAG
{
  Dcm_TskTaskEvMemType    TaskEvents;  /*!< Task related events */
#if (DCM_TSK_TASK_FLAG_SUPPORT_ENABLED == STD_ON)
  Dcm_TskTaskFlagType     TaskFlags;   /*!< Runtime status */
#endif
};
typedef struct DCM_TSKTASKCONTEXTTYPE_TAG Dcm_TskTaskContextType;
typedef volatile P2VAR(Dcm_TskTaskContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_TskTaskContextPtrType;

/*! Task scheduler (one per task priority) control data */
struct DCM_TSKSCHEDULERCONTEXTTYPE_TAG
{
  boolean SchdIsActive;  /*!< Activity state of scheduler (TRUE - scheduler has at least one active task, FALSE - scheduler is suspended) */
};
typedef struct DCM_TSKSCHEDULERCONTEXTTYPE_TAG Dcm_TskSchedulerContextType;
typedef volatile P2VAR(Dcm_TskSchedulerContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_TskSchedulerContextPtrType;

/*! Control states of the task manager sub-component */
struct DCM_TSKCONTEXTTYPE_TAG
{
  volatile Dcm_TskTaskContextType      TaskContext[DCM_TSK_NUM_TASKS];    /*!< Runtime data of each available task (priority independent) */
  volatile Dcm_TskSchedulerContextType TaskScheduler[DCM_TSK_NUM_PRIOS];  /*!< Control data of each scheduler (one per priority) */
#if (DCM_TSK_TRACING_ENABLED == STD_ON)
  volatile Dcm_TskMgrTraceStackType    CurrentTaskPrioStack;              /*!< Active task ID stack for tracing purposes (e.g. check whether a low prio task is interrupted by another one and which one or just see which task is active at a time) */
#endif
};
typedef struct DCM_TSKCONTEXTTYPE_TAG Dcm_TskContextType;
/*! Control data of the timer sub-component */
struct DCM_TMRCONTEXTTYPE_TAG
{
  volatile Dcm_TmrMaskMemType        RunningMask;                /*!< Running mask for all configured system timers */
  volatile Dcm_TmrTimerCntrMemType   Timer[DCM_TMR_NUM_TIMERS];  /*!< Remaining time of all running system timers */
};
typedef struct DCM_TMRCONTEXTTYPE_TAG Dcm_TmrContextType;
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_CfgRidMgrInfoHandleOptType, AUTOMATIC, DCM_VAR_NOINIT) Dcm_CfgRidMgrInfoHandlePtrType;
typedef P2VAR(Dcm_CfgRidMgrOpHandleOptType, TYPEDEF, DCM_VAR_NOINIT) Dcm_CfgRidMgrOpHandlePtrType;
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)
/*! OBD DTC manager temporary processing context */
struct DCM_OBDDTCMANAGERCONTEXTTYPE_TAG
{
  Dcm_RepeaterProgressType  DcmObdDtcManagerProgress; /*!< Repeater progress state */
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  uint8                     DemClientId;              /*!< DEM ClientId */
# endif
};
typedef struct DCM_OBDDTCMANAGERCONTEXTTYPE_TAG Dcm_ObdDtcManagerContextType;
typedef P2VAR(Dcm_ObdDtcManagerContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_ObdDtcManagerContextPtrType;
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/*! Base type for the diagnostic service verification level */
typedef uint8 Dcm_DiagCheckLvlType;

/*! Control data for diagnostic service post-processing */
struct DCM_DIAGPOSTPROCESSORCONTEXTTYPE_TAG
{
  uint16 SrcAddr; /*!< Source address */
  uint8  Sid;     /*!< Service identifier */
  uint8  ReqType; /*!< Request type (physical/functional) */
};
typedef struct DCM_DIAGPOSTPROCESSORCONTEXTTYPE_TAG Dcm_DiagPostProcessorContextType;

/*! Function pointer prototype for a diagnostic service specific length getter */
typedef P2FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE, Dcm_DiagServiceLengthGetterFuncType) (Dcm_DiagSubServiceRefOptType /* IN: Abstract (diagnostic service processor specific) sub-function handle */);
/*! Function pointer prototype for a diagnostic service with sub-function specific sequence checker */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DiagSubFuncSequenceCheckerFuncType) (Dcm_DiagSubServiceRefOptType);
#if(DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
/*! Package with current communication and diagnostic variant selection (cached variant references) */
struct DCM_VARMANAGERCONTEXTTYPE_TAG
{
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  Dcm_CfgVarMgrComVariantType    ActiveComVariant;      /*!< Points to the COM-criteria */
# endif
# if ((DCM_DIAG_MULTI_SVC_TABLE_ENABLED == STD_ON) && (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON))                                             /* COV_DCM_SUPPORT_PARTIALLY TF tf tx */
  Dcm_CfgVarMgrBridgeVariantType ActiveBridgeVariant;   /*!< Points to the COM-to-CFG-bridge information */
# endif
# if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
  Dcm_CfgVarMgrRamVariantType    ActiveRamVariant;      /*!< Points to the overall variant post-build-loadable RAM data */
  Dcm_CfgVarMgrRomVariantType    ActiveRomVariant;      /*!< Points to the overall variant post-build-loadable ROM data */
# endif
# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
#  if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
  Dcm_CfgVarMgrBitSetBaseType    ActiveCfgVariants[Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_CFG_VARIANTS)];  /*!< Contains all active CFG-criteria IDs */
#  else
  Dcm_CfgVarMgrDiagVariantIdMemType  ActiveCfgVariantId; /*!< Contains the active CFG-criteria ID */
#  endif
# endif
};
typedef struct DCM_VARMANAGERCONTEXTTYPE_TAG Dcm_VarManagerContextType;
#endif
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)
/*! Service 0x01 temporary processing context */
struct DCM_SVC01REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdIdMgrDescType    ParserDesc;  /*!< Parser Descriptor */
};
typedef struct DCM_SVC01REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc01RepeaterProxyContextType;
typedef P2VAR(Dcm_Svc01RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc01RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
/*! Service 0x02 temporary processing context */
struct DCM_SVC02REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdIdMgrDescType      ParserDesc;   /*!< Parser Descriptor */
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  uint8                     DemClientId;  /*!< DEM ClientId */
# endif
};
typedef struct DCM_SVC02REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc02RepeaterProxyContextType;
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)
/*! Service 0x03 temporary processing context */
struct DCM_SVC03REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdDtcManagerContextType  ReadDtcContext; /*!< OBD DTC manager processing context */
};
typedef struct DCM_SVC03REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc03RepeaterProxyContextType;
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)
/*! Service 0x04 temporary processing context */
struct DCM_SVC04REPEATERPROXYCONTEXTTYPE_TAG
{
  uint8 DemClientId;  /*!< Dem Client Id */
};
typedef struct DCM_SVC04REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc04RepeaterProxyContextType;
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/*! Service 0x06 temporary processing context */
struct DCM_SVC06REPEATERPROXYCONTEXTTYPE_TAG
{
  uint8 Spare; /*!< Currently not used */
};
typedef struct DCM_SVC06REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc06RepeaterProxyContextType;
typedef P2VAR(Dcm_Svc06RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc06RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
/*! Service 0x06 temporary processing context */
struct DCM_SVC06REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdIdMgrDescType    ParserDesc; /*!< OBD request parser context */
};
typedef struct DCM_SVC06REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc06RepeaterProxyContextType;
typedef P2VAR(Dcm_Svc06RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc06RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)
/*! Service 0x07 temporary processing context */
struct DCM_SVC07REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdDtcManagerContextType  ReadDtcContext;  /*!< OBD DTC manager processing context */
};
typedef struct DCM_SVC07REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc07RepeaterProxyContextType;
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)
/*! Service 0x08 temporary processing context */
struct DCM_SVC08REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdIdMgrDescType    ParserDesc;  /*!< Request parser processing context data */
};
typedef struct DCM_SVC08REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc08RepeaterProxyContextType;
typedef P2VAR(Dcm_Svc08RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc08RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
/*! Service 0x09 temporary processing context */
struct DCM_SVC09REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdIdMgrDescType ParserDesc; /*!< Parser Descriptor */
};
typedef struct DCM_SVC09REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc09RepeaterProxyContextType;
typedef P2VAR(Dcm_Svc09RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc09RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)
/*! Service 0x0A temporary processing context */
struct DCM_SVC0AREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdDtcManagerContextType  ReadDtcContext;  /*!< OBD DTC manager processing context */
};
typedef struct DCM_SVC0AREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc0ARepeaterProxyContextType;
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
/*! Service 0x10 temporary processing context */
struct DCM_SVC10REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_StateIndexMemType             SesStateIdx;             /*!< Requested new Session State to execute transition in post processor */
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
  Dcm_ProgConditionsType            ProgConditions;          /*!< Programming condition for further processing steps */
  Dcm_ModeMgrArEnvModeEcuResetType  ResetMode;               /*!< Reset mode for Ecu reset */
# endif
};
typedef struct DCM_SVC10REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc10RepeaterProxyContextType;
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/*! Service 0x11 temporary processing context */
struct DCM_SVC11REPEATERPROXYCONTEXTTYPE_TAG
{
  uint8                          SubFuncId;  /*!< Sub-function ID of the current request */
  Dcm_DiagSubServiceRefMemType   SubSvcRef;  /*!< Reference to Dcm_CfgSvc11SubFuncInfo[] entry */
};
typedef struct DCM_SVC11REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc11RepeaterProxyContextType;

typedef P2CONST(Dcm_CfgSvc11SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc11SubFuncInfoPtrType;
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/*! Service 0x14 temporary processing context */
struct DCM_SVC14REPEATERPROXYCONTEXTTYPE_TAG
{
  uint32   Dtc;         /*!< Requested DTC for futher DEM interaction */
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  uint8    DemClientId; /*!< DEM ClientId */
# endif
};
typedef struct DCM_SVC14REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc14RepeaterProxyContextType;
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! Service 0x19 paged-buffer updater dispatching item ID type */
typedef uint8 Dcm_Svc19SubUpdaterType;

/*! Service 0x19 temporary processing context */
struct DCM_19_REPEATERPROXYCONTEXTTYPE_TAG
{
  P2CONST(Dcm_RepeaterProgressType, TYPEDEF, DCM_CONST)  FuncChain;     /*!< Pointer to valid list of processing DEM API list */
# if (DCM_SVC_19_RECORD_ITER_ENABLED == STD_ON)
  Dcm_Uint8ConstDataPtrType                              RecordNumList; /*!< Pointer to DEM (extended/freeze-frame) record list */
# endif
  uint32                                                 Dtc;           /*!< Requested DTC for futher DEM interaction */
  uint16                                                 NumDtc;        /*!< Read number of DTCs reported by DEM to be passed to next processing stage */
  Dem_DTCOriginType                                      Origin;        /*!< Requested DTC origin */
  uint8                                                  SubUpdater;    /*!< Current paged-buffer updater within this diagnostic service */
  uint8                                                  RecordNum;     /*!< Either the requested or next record number to be read out from DEM */
  Dcm_DiagSubServiceRefMemType                           SubSvcRef;     /*!< A validly dispatched sub-function requested for this diagnostic service */
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  uint8                                                  DemClientId;   /*!< DEM ClientId */
# endif
  DCM_EXT_SVC19_PATCH_CONTEXT                                           /*!< A placeholder for optional on the fly DTC report patching (applicable in some specific customer requirements) */
};
typedef struct DCM_19_REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc19RepeaterProxyContextType;
typedef P2VAR(Dcm_Svc19RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc19RepeaterProxyContextPtrType;

typedef P2CONST(Dcm_CfgSvc19SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc19SubFuncInfoPtrType;
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
/*! Service 0x22 temporary processing context */
struct DCM_SVC22REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType     DidInfoContextList[DCM_SVC_22_MAX_DID_LIST_LEN];         /*!< Array of DidInfoContext */
  Dcm_DidMgrDidOpTypeContextType   DidOpTypeContext;                                        /*!< Did configuration operation context */
  Dcm_MsgLenType                   ActualLength;                                            /*!< Actual response data length  */
  Dcm_MsgLenType                   ReservedLength;                                          /*!< Reserved buffer size needed for reading the data */
  uint8                            DidInfoContextIdx;                                       /*!< Reference to DidInfoContextList[] entry */
  uint8                            NumDids;                                                 /*!< Number of Dids to process */
  uint8                            DidIter;                                                 /*!< Current Did to process */
};
typedef struct DCM_SVC22REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc22RepeaterProxyContextType;
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)
/*! Service 0x23 temporary processing context */
struct DCM_SVC23REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_MemMgrMemBlockType  MemBlock;  /*!< Memory block descriptor */
};
typedef struct DCM_SVC23REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc23RepeaterProxyContextType;
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
/*! Service 0x24 temporary processing context */
struct DCM_SVC24REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType      DidInfoContext;    /*!< DidInfoContext */
  Dcm_DidMgrDidOpTypeContextType    DidOpTypeContext;  /*!< Did configuration operation context */
};
typedef struct DCM_SVC24REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc24RepeaterProxyContextType;
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
typedef uint16 Dcm_Svc27TimerType;
# endif

/*! Service 0x27 temporary processing context */
struct DCM_SVC27REPEATERPROXYCONTEXTTYPE_TAG
{
  boolean                       IsZeroSeed;  /*!< Inidication for zero seed (unloced security level) */
  Dcm_DiagSubServiceRefMemType  SubSvcRef;   /*!< Reference to Dcm_CfgSvc27SubFuncInfo[] entry */
  uint8                         SecLvlRef;   /*!< Reference to Dcm_CfgSvc27SecLevelInfo[] entry */
  Dcm_NegativeResponseCodeType  ErrorCode;   /*!< Error code */
};
typedef struct DCM_SVC27REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc27RepeaterProxyContextType;
typedef P2VAR(Dcm_Svc27RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc27RepeaterProxyContextPtrType;

/*! Context for attempt counter handling */
struct DCM_SVC27CONTEXTTYPE_TAG
{
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
                            uint32              GetAttCntrEventMask;                            /*!< State of attempt counter read operations */
                            uint32              SetAttCntrEventMask;                            /*!< State of attempt counter write operations */
#  endif
#  if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
                            uint32              ReloadMask;                                     /*!< Infinite delay timer mask */
#  endif
  DCM_VOLATILE_ON_SPLITTASK Dcm_Svc27TimerType  DelayTime[DCM_SVC_27_NUM_DELAY_TIMERS];         /*!< Array of delay timers for UUDT messages */
                            uint8               AttemptCount[DCM_SVC_27_NUM_ATTEMPT_COUNTERS];  /*!< Array of attempt counters */
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
                            Dcm_OpStatusType    GetAttOpStatus;                                 /*!< Operation state of attempt counter read operation */
                            Dcm_OpStatusType    SetAttOpStatus;                                 /*!< Operation state of attempt counter write operation */
#  endif
# endif
                            uint8               SeedLevel;                                      /*!< Last requested security level for which a seed was sent (0 = invalid (no seed) -> 1..7F - active seed) */
};
typedef struct DCM_SVC27CONTEXTTYPE_TAG Dcm_Svc27ContextType;

typedef P2CONST(Dcm_CfgSvc27SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc27SubFuncInfoPtrType;
typedef P2CONST(Dcm_CfgSvc27SecLevelInfoType, TYPEDEF, DCM_CONST)  Dcm_CfgSvc27SecLevelInfoPtrType;
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/*! Service 0x28 temporary processing context */
struct DCM_SVC28REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_CommunicationModeType  ComMode;               /*!< Calculated CommunicationControl ModeDeclarationGroup mode value of the current service request */
  Dcm_CfgNetNetIdRefMemType  NetworkRef;            /*!< ComM channel of the current service request */
  uint8                      SubServiceId;          /*!< Sub-function ID of the current service request */
# if (DCM_SVC_28_USER_ENABLED == STD_ON)
  boolean                    IsInternallyProcessed; /*!< Specifies whether the processed sub-function is internally handled (TRUE) or within application code (FALSE)*/
# endif
  Dcm_DiagSubServiceRefMemType  SubSvcRef;          /*!< A validly dispatched sub-function requested for this diagnostic service */
};
typedef struct DCM_SVC28REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc28RepeaterProxyContextType;

typedef P2CONST(Dcm_CfgSvc28SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc28SubFuncInfoPtrType;
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
typedef uint8       Dcm_Svc2ASchedRateMemType;
typedef uint8_least Dcm_Svc2ASchedRateOptType;
typedef uint8       Dcm_Svc2ASchdItemHandleMemType;
typedef uint8_least Dcm_Svc2ASchdItemHandleOptType;

/*! Service 0x2A scheduler entry data */
struct DCM_SVC2ASCHDENTRYTYPE_TAG
{
                            Dcm_DidMgrDidInfoContextType DidContext; /*!< Information about the scheduled DID */
  DCM_VOLATILE_ON_SPLITTASK Dcm_TmrTimerCntrMemType      Timer;      /*!< Timer for the periodic transmission */
                            Dcm_Svc2ASchedRateMemType    Rate;       /*!< Requested transmission rate */
};
typedef struct DCM_SVC2ASCHDENTRYTYPE_TAG Dcm_Svc2ASchdEntryType;

typedef P2VAR(Dcm_Svc2ASchdEntryType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2ASchdEntryPtrType;

/*! Service 0x2A scheduler data */
struct DCM_SVC2ASCHEDULERTYPE_TAG
{
  Dcm_Svc2ASchdEntryType          Table[DCM_SVC_2A_SCHEDULER_SIZE];        /*!< Table of scheduled DIDs */
  Dcm_DidMgrDidOpTypeContextType  DidOpTypeContext;                        /*!< Information about operations on current DID */
  Dcm_CfgNetBufferSizeMemType     WriteIndex;                              /*!< Number of bytes that were already read */
  Dcm_Svc2ASchdItemHandleMemType  NumActiveEntries;                        /*!< Number of active entries in scheduler table */
  Dcm_Svc2ASchdItemHandleMemType  CurrentEntryIndex;                       /*!< Scheduler table entry that is currently processed */
  Dcm_CfgNetPTxObjHandleMemType   MsgTxHandle;                             /*!< Index of current tx object */
  Dcm_OpStatusType                OpStatus;                                /*!< Current operation status */
};
typedef struct DCM_SVC2ASCHEDULERTYPE_TAG Dcm_Svc2ASchedulerType;
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
typedef uint8 Dcm_Svc2ATransmissionModeType;

/*! Service 0x2A temporary processing context */
struct DCM_SVC2AREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType    DidInfoContext;          /*!< Info context of the currently requested DID */
  Dcm_DidMgrDidOpTypeContextType  DidOpTypeContext;        /*!< Operation type context of the currently requested DID */
  Dcm_NetConnRefMemType           ConnId;                  /*!< Connection ID of the current request */
  Dcm_Svc2ATransmissionModeType   UdsRate;                 /*!< Requested UDS rate */
  boolean                         HasAnySupportedDids;     /*!< Flag whether current request contains a supported DID */
};
typedef struct DCM_SVC2AREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc2ARepeaterProxyContextType;

/*! Context for handling of periodic transmision */
struct DCM_SVC2ACONTEXTTYPE_TAG
{
  Dcm_Svc2ASchedulerType Scheduler;                        /*!< Scheduler for periodic transmission */
};
typedef struct DCM_SVC2ACONTEXTTYPE_TAG Dcm_Svc2AContextType;
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/* Define by DID properties */
typedef uint8 Dcm_Svc2CSrcDidOffsetType;
typedef uint8 Dcm_Svc2CSrcDidSizeType;
typedef Dcm_UtiBitSetBaseType Dcm_Svc2CSrcClassType;

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/*! Information about source DID of a DynDID */
struct DCM_SVC2CSRCDIDITEMINFOTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType DidContext; /*!< DID information context */
  Dcm_Svc2CSrcDidOffsetType    Offset;     /*!< Configured offset in DID data */
  Dcm_Svc2CSrcDidSizeType      Size;       /*!< Configured size of DID data */
};
typedef struct DCM_SVC2CSRCDIDITEMINFOTYPE_TAG Dcm_Svc2CSrcDidItemInfoType;

typedef P2VAR(Dcm_Svc2CSrcDidItemInfoType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2CSrcDidItemInfoPtrType;
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/*! Information about source memory item of a DynDID */
struct DCM_SVC2CSRCMEMITEMINFOTYPE_TAG
{
  Dcm_MemMgrMemBlockType MemBlock; /*!< Memory block information */
};
typedef struct DCM_SVC2CSRCMEMITEMINFOTYPE_TAG Dcm_Svc2CSrcMemItemInfoType;
# endif

typedef union
{                                                                                                                                                    /* PRQA S 0750 */ /* MD_Dcm_Optimize_0750 */
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2CSrcDidItemInfoType      DidDescriptor; /*!< Descriptor for DID items */
# endif
# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2CSrcMemItemInfoType      MemDescriptor; /*!< Descriptor for Memory items */
# endif
}Dcm_Svc2CDynDidSrcItemType;

typedef P2VAR(Dcm_Svc2CDynDidSrcItemType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2CDynDidSrcItemPtrType;

/*! Information about a DynDID */
struct DCM_SVC2CDYNDIDITEMTYPE_TAG
{
  Dcm_DidMgrDidLengthType         Length; /*!< Total length of the DynDID */
  uint8                           Count;  /*!< Number of source items */
};
typedef struct DCM_SVC2CDYNDIDITEMTYPE_TAG Dcm_Svc2CDynDidItemType;

typedef P2VAR(Dcm_Svc2CDynDidItemType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2CDynDidItemPtrType;

/*! Context for the processing of a specific DynDID */
struct DCM_SVC2CDYNDIDPROCESSCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidOpTypeContextType       DidOpTypeContext; /*!< Operation type context */
  Dcm_CfgDidMgrDynDidSrcItemIdxMemType ItemInProgress;   /*!< Index of the currently processed source item */
  Dcm_CfgDidMgrDynDidSrcItemIdxMemType ItemToStop;       /*!< Index of the item after the last source item */
};
typedef struct DCM_SVC2CDYNDIDPROCESSCONTEXTTYPE_TAG Dcm_Svc2CDynDidProcessContextType;

typedef P2VAR(Dcm_Svc2CDynDidProcessContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2CDynDidProcessContextPtrType;

/*! Context for the handling of the read access to a DynDID */
struct DCM_SVC2CDYNDIDACCESSCONTEXT_TAG
{
  Dcm_Svc2CDynDidProcessContextType ProcessContext[DCM_SVC_2C_NUM_PROCESS_CONTEXTS]; /*!< Process contexts for DynDIDs */
  Dcm_CfgDidMgrDynDidHandleMemType  DynDidHandleInUse;                               /*!< Handle of currently processed DynDID */
  Dcm_MsgItemType                   Buffer[DCM_SVC_2C_READ_BUFFER_SIZE];             /*!< DynDID read buffer */
};
typedef struct DCM_SVC2CDYNDIDACCESSCONTEXT_TAG Dcm_Svc2CDynDidReadAccessContext;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/*! Context for the handling of DynDIDs */
struct DCM_SVC2CCONTEXTTYPE_TAG
{
  Dcm_Svc2CDynDidSrcItemType        SrcItems[DCM_NUM_DYNDID_ITEMS];                                 /*!< List of source items */
  Dcm_Svc2CSrcClassType             Sequencer[Dcm_UtiGenericBitSetCalcSize(DCM_NUM_DYNDID_ITEMS)];  /*!< BitMask of enabled source items */
  Dcm_Svc2CDynDidItemType           Items[DCM_NUM_DYNDIDS];                                         /*!< List of DIDs */
  Dcm_Svc2CDynDidReadAccessContext  DynDidAccessContext;                                            /*!< Access context of the DynDID */
  Dcm_MsgLenType                    ReadIndex;                                                      /*!< Number of bytes that are alredy read */
};
typedef struct DCM_SVC2CCONTEXTTYPE_TAG Dcm_Svc2CContextType;

typedef P2CONST(Dcm_CfgSvc2CSubFuncInfoType, TYPEDEF, DCM_CONST) Dcm_CfgSvc2CSubFuncInfoPtrType;
/*! Service 0x2C temporary processing context */
struct DCM_SVC2CREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType           DynDidInfoContext;    /*!< DynDID info context */
  Dcm_DidMgrDidOpTypeContextType         DynDidOpTypeContext;  /*!< DynDID operation type context */
  Dcm_CfgDidMgrDynDidSrcItemIdxMemType   SrcItemIndex;         /*!< Index of currently processed source item */
  Dcm_CfgDidMgrDynDidHandleMemType       DynDidHandle;         /*!< Handle of the currently processed DynDID */
  Dcm_DidMgrDidLengthType                MaxAllowedLength;     /*!< Maximum allowed response length (depending on the protocol) */
  Dcm_DidMgrDidLengthType                DynDidLength;         /*!< Length of the DynDID */
  uint8                                  DynDidItemCount;      /*!< Number of source items in current request */
  uint8                                  ReqNumOfItems;        /*!< Number of requested items that are not yet processed */
  Dcm_DiagSubServiceRefMemType           SubSvcRef;            /*!< Index of the requested subfunction */
};
typedef struct DCM_SVC2CREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc2CRepeaterProxyContextType;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
/*! Service 0x2E temporary processing context */
struct DCM_SVC2EREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType       DidInfoContext;     /*!< Did configuration information context */
  Dcm_DidMgrDidOpTypeContextType     DidOpTypeContext;   /*!< Did configuration operation context */
};
typedef struct DCM_SVC2EREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc2ERepeaterProxyContextType;
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/*! Context for the handling of IODIDs */
struct DCM_SVC2FCONTEXTTYPE_TAG
{
  Dcm_DiagDataContextType DataContext;                                                /*!< Data context */
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_UtiBitSetBaseType   ActiveIoDids[Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS)]; /*!< Bit masks of active IO operations */
  boolean                 HasAnyActiveIoDid;                                          /*!< Active IODID operation flag */
# else
  uint8 spare;                                                                        /*!< not used */
# endif
};
typedef struct DCM_SVC2FCONTEXTTYPE_TAG Dcm_Svc2FContextType;
/*! Repeater context for the handling of a 2F request */
struct DCM_SVC2FREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType    DidInfoContext;   /*!< DID information context */
  Dcm_DidMgrDidOpTypeContextType  DidOpTypeContext; /*!< DID operation type context */
  Dcm_DidMgrOpMemType             OpType;           /*!< Requested operation type */
};
typedef struct DCM_SVC2FREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc2FRepeaterProxyContextType;
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
/*! Service 0x31 temporary processing context */
struct DCM_SVC31REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_CfgRidMgrInfoHandleOptType RidInfoIdx;      /*!< Reference to Dcm_CfgRidMgrRidInfo[] entry */
  Dcm_CfgRidMgrOpHandleOptType   RidOpInfoIdx;    /*!< Reference to Dcm_CfgRidMgrOpInfo[] entry */
};
typedef struct DCM_SVC31REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc31RepeaterProxyContextType;
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)
/*! Service 0x3D temporary processing context */
struct DCM_SVC3DREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_MemMgrMemBlockType  MemBlock; /*!< Shared memory block information */
};
typedef struct DCM_SVC3DREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc3DRepeaterProxyContextType;
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/*! Service 0x85 temporary processing context */
struct DCM_SVC85_REPEATERPROXYCONTEXTTYPE_TAG
/*! Service 0x85 temporary processing context */
{
  uint32                             DTCGroup;    /*!< Requested DTC for the ModeSwitch operation during the post-processing */
  Rte_ModeType_DcmControlDtcSetting  ReqMode;     /*!< Requested mode for the ModeSwitch operation during the post-processing */
  Dcm_DiagSubServiceRefOptType       SubSvcRef;   /*!< Reference to Dcm_CfgSvc85SubFuncInfo[] entry */
  uint8                              DemClientId; /*!< DEM ClientId */
};
typedef struct DCM_SVC85_REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc85RepeaterProxyContextType;
typedef P2CONST(Dcm_CfgSvc85SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc85SubFuncInfoPtrType;
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/*! Service 0x86 temporary processing context */
struct DCM_SVC86REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ExtSvc86RepeaterContextType ExtSvc86RepeaterContext; /*!< OEM-specific temporary processing context for service 0x86 */
  Dcm_DiagSubServiceRefMemType    SubSvcRef;               /*!< Index of the requested subfunction */
};
typedef struct DCM_SVC86REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc86RepeaterProxyContextType;

typedef P2CONST(Dcm_CfgSvc86SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc86SubFuncInfoPtrType;
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Typedefs Exported Level 1
---------------------------------------------- */
typedef Std_ReturnType Dcm_NetTransmissionResultType;
/*! Base data type for the application notification levels */
typedef uint8 Dcm_DiagApplNotificationType;
/*! Base data type for the diagnostic kernel processing state flags */
typedef uint8 Dcm_DiagProcessorFlagType;

/*! Control data of the unsolicited response at ECU start-up task */
struct DCM_STARTUPRESPONSECONTEXTTYPE_TAG
{
  Dcm_ProgConditionsType          ProgConditions;                             /*!< Dedicated programming condition storage in case a parallel request needs the repeater proxy pool */
  Dcm_MsgItemType                 ResBuffer[DCM_DIAG_START_UP_FBL_RES_SIZE];  /*!< Dedicated response buffer for the final response */
  boolean                         IsResponseRequired;                         /*!< Response-required information extracted from the pre-boot time context */
  Dcm_NetTransmissionResultType   TxStatus;                                   /*!< Transports the response transmission result to the Dcm_DiagTaskFblRes() */
  sint8                           SessStateRef;                               /*!< Diagnostic session index (values <0 mean no session transition). Use sint8 since no more than 127 sessions are possible */
  Dcm_NetConnRefMemType           ConnId;                                     /*!< Connection handle on which the unsolicited response was sent for post-processing purposes */
};
typedef struct DCM_STARTUPRESPONSECONTEXTTYPE_TAG Dcm_DiagStartUpResContextType;

#if(DCM_DIAG_SVC_CONTEXT_ENABLED == STD_ON)
/*! Storage of all diagnostic services contexts that shall be kept in memory not only during a diagnostic request but during the whole ECU operation cycle */
struct DCM_DIAGSERVICESCONTEXTTYPE_TAG
{
# if(DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc27ContextType          Svc27;  /*!< Storage place for all "SecurityAccess" data */
# endif
# if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2AContextType          Svc2A;  /*!< Storage place for all "ReadDataByPeriodicId" data */
# endif
# if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2CContextType          Svc2C;  /*!< Storage place for all "DynamicallyDefineIdentifier" data */
# endif
# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2FContextType          Svc2F;  /*!< Storage place for all "IOControlByIdentifier" data */
# endif
};
typedef struct DCM_DIAGSERVICESCONTEXTTYPE_TAG Dcm_DiagServicesContextType;
#endif

#if (DCM_DIAG_SYNCH_DATA_SET_ENABLED == STD_ON)
/*! Diagnostic kernel synchronization data */
struct DCM_DIAGSYNCHDATATYPE_TAG
{
# if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON)
  Dcm_CfgNetTObjHandleMemType      TObjHdl;        /*!< A single element queue for the transport object handle that holds the request data to be processed at next Dcm_DiagTaskWorker() activation */
#  if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
  Dcm_TskTaskEvMemType             QueuedTObjects; /*!< Bitmask of queued transport objects */
#  endif
# endif
# if (DCM_DIAG_PROCESSOR_FLAGS_ENABLED == STD_ON)                                                                                                    /* COV_DCM_SUPPORT_ALWAYS TX */
  Dcm_DiagProcessorFlagType        Flags;          /*!< The diagnostic kernel status flags (Valid values: DCM_DIAG_QUEUE_FLAG_*) */
# endif
};
typedef struct DCM_DIAGSYNCHDATATYPE_TAG Dcm_DiagSynchDataType;
#endif

/*! Control data of the sub-component diagnostic kernel */
struct DCM_DIAGCONTEXTTYPE_TAG
{
  Dcm_MsgContextType               MsgContext;            /*!< The diagnostic service/sub-service processor message context */
#if (DCM_DIAG_SYNCH_DATA_SET_ENABLED == STD_ON)
volatile Dcm_DiagSynchDataType     QueuedSet;             /*!< Diagnostic kernel processing synchronization data */
#endif
#if(DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
  Dcm_DiagPostProcessorContextType PostProcessorContext;  /*!< Post-processing context */
#endif
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  Dcm_DiagStartUpResContextType    StartUpFbl;            /*!< The global data of the unsolicited response task (Dcm_DiagTaskFblRes()) */
#endif
  Dcm_CfgNetTObjHandleMemType      TObjHdl;               /*!< The transport object handle of the diagnostic request in processing */
  Dcm_DiagP2TimingsType            P2Timings;             /*!< Currently active set of the P2/P2* timings */
  Dcm_NetTransmissionResultType    TxStatus;              /*!< Transports the (RCR-RP and final) USDT response transmission result to the Dcm_DiagTaskWorker() */
  Dcm_DiagApplNotificationType     ApplNotification;      /*!< Application notification level reached for current diagnostic request (Valid values: DCM_DIAG_APPL_NOTIFICATION_*) */
  volatile Dcm_DiagProcessorStateType State;              /*!< Keeps track of the diagnostic kernel processing state per diagnostic request */
  Dcm_NegativeResponseCodeType     ErrorRegister;         /*!< Keeps the NRC for the current diagnostic service in processing */
  uint8                            SidIndex;              /*!< Reference to Dcm_CfgDiagServiceInfo[] entry */
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
  uint8                            NumRcrRpTimeouts;      /*!< Keeps track of the number of RCR-RPs sent for the current diagnostic service processing */
#endif
#if(DCM_DIAG_SVC_CONTEXT_ENABLED == STD_ON)
  Dcm_DiagServicesContextType      Services;              /*!< Diagnostic service processors "long term" memory */
#endif
#if (DCM_DIAG_SERVICE_DISPATCHER_ENABLED == STD_ON)
  boolean                          ProcessServiceExtern;  /*!< Diagnostic service dispatching */
#endif
#if(DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  boolean                          IsInternRequest;       /*!< Specifies whether current request in processing is internal i.e. send via Dcm_ProcessVirtualRequest() or internal Dcm_NetRxIndInternal() API (TRUE - internal, FALSE - external (normal)) */
#endif
  boolean                          DoSuppressResponse;    /*!< Used dedicated flag instead of "NRC 0x11 and func_req" combination with the same effect, because of possible application confirmation functions! */
};
typedef struct DCM_DIAGCONTEXTTYPE_TAG Dcm_DiagContextType;
/* ----------------------------------------------
 ~&&&   Typedefs
---------------------------------------------- */
typedef union
{                                                                                                                                                    /* PRQA S 0750 */ /* MD_Dcm_Optimize_0750 */
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc01RepeaterProxyContextType Svc01;
#endif
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc02RepeaterProxyContextType Svc02;
#endif
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc03RepeaterProxyContextType Svc03;
#endif
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc04RepeaterProxyContextType Svc04;
#endif
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc06RepeaterProxyContextType Svc06;
#endif
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc07RepeaterProxyContextType Svc07;
#endif
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc08RepeaterProxyContextType Svc08;
#endif
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc09RepeaterProxyContextType Svc09;
#endif
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc0ARepeaterProxyContextType Svc0A;
#endif
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
  Dcm_Svc10RepeaterProxyContextType Svc10;
#endif
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc11RepeaterProxyContextType Svc11;
#endif
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc14RepeaterProxyContextType Svc14;
#endif
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc19RepeaterProxyContextType Svc19;
#endif
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc22RepeaterProxyContextType Svc22;
#endif
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc23RepeaterProxyContextType Svc23;
#endif
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc24RepeaterProxyContextType Svc24;
#endif
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc27RepeaterProxyContextType Svc27;
#endif
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc28RepeaterProxyContextType Svc28;
#endif
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2ARepeaterProxyContextType Svc2A;
#endif
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2CRepeaterProxyContextType Svc2C;
#endif
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2ERepeaterProxyContextType Svc2E;
#endif
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2FRepeaterProxyContextType Svc2F;
#endif
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc31RepeaterProxyContextType Svc31;
#endif
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc3DRepeaterProxyContextType Svc3D;
#endif
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc85RepeaterProxyContextType Svc85;
#endif
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc86RepeaterProxyContextType Svc86;
#endif
#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
  Dcm_RecoveryContextType           Recovery;
#endif
  uint8 reserved; /* just in case no other element is available */
}Dcm_RepeaterProxySvcContextType;

/*! Service processor repeater state */
struct DCM_REPEATERPROXYCONTEXTPOOLTYPE_TAG
{
  Dcm_RepeaterProxySvcContextType Context;  /*!< Service specific repeater contexts */                                                               /* PRQA S 0759 */ /* MD_Dcm_Optimize_0759 */
  Dcm_OpStatusType                OpStatus; /*!< Current operation status */
  Dcm_RepeaterProgressType        Progress; /*!< Progress of the repeater */
#if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  Dcm_RepeaterUserType            User;     /*!< Current user of the repeater */
#endif
};
typedef struct DCM_REPEATERPROXYCONTEXTPOOLTYPE_TAG Dcm_RepeaterProxyContextPoolType;

/*! Diagnostic service processor repeater context */
struct DCM_REPEATERCONTEXTTYPE_TAG
{
  uint8                            CalleeIdx; /*!< Index of the next function to call */
  Dcm_RepeaterProxyContextPoolType Contexts;  /*!< Current state of the repeater including service specific contexts */
};
typedef struct DCM_REPEATERCONTEXTTYPE_TAG Dcm_RepeaterContextType;
/*! Function pointer prototype for a system task handler */
typedef P2FUNC(void, DCM_CODE, Dcm_TskTaskFuncType) (Dcm_TskTaskEvOptType /* IN: currently active events */
                                                    ,Dcm_TskTaskEvPtrType /* INOUT: events to be activated at next main-function cycle */);

/*! Single task configuration data */
struct DCM_TSKTASKINFOTYPE_TAG
{
  Dcm_TskTaskFuncType      TskFunc;        /*!< Pointer to the task handler Dcm_<SubComp>Task<Name>() (e.g. Dcm_NetTaskRx()) */
  Dcm_TskTaskAttributeType TskAtr;         /*!< Configuration attributes (e.g. can be terminated, number of executions per Dcm_MainFunction() call etc.) */
  Dcm_TskTaskPrioMemType   TskPrio;        /*!< The priority of the task (e.g. DEFAULT, HIGH, LOW etc.) */
  Dcm_TskTaskEvMemType     NonKillEvents;  /*!< If a task is determined as a killable one (DCM_TSK_ATR_KILL_ALWAYS) here are kept all events that shall not be reset during task termination */
};
typedef struct DCM_TSKTASKINFOTYPE_TAG Dcm_TskTaskInfoType;

typedef P2CONST(Dcm_TskTaskInfoType, TYPEDEF, DCM_CONST) Dcm_TskTaskInfoPtrType;
/*! Function pointer prototype for a system timer related time-out notification */
typedef P2FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE, Dcm_TmrTimeoutFuncType) (void);
/*! Single timer configuration data */
struct DCM_TMRTIMERINFOTYPE_TAG
{
  Dcm_TmrTimeoutFuncType ToFunc;  /*!< Pointer to the timeout notification handler of kind Dcm_OnTimeout<TimerName>() (e.g. Dcm_OnTimeoutP2()) */
};
typedef struct DCM_TMRTIMERINFOTYPE_TAG Dcm_TmrTimerInfoType;

typedef P2CONST(Dcm_TmrTimerInfoType, TYPEDEF, DCM_CONST) Dcm_TmrTimerInfoPtrType;
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
typedef uint8 Dcm_DidMgrDidLockOwnerType;
/*! Lock information of the Did manager */
struct DCM_DIDMGRDIDLOCKTYPE_TAG
{
  uint16                      Did;    /*!< Identifier value of a Did */
  Dcm_DidMgrDidLockOwnerType  Owner;  /*!< Did lock owner */
};
typedef struct DCM_DIDMGRDIDLOCKTYPE_TAG Dcm_DidMgrDidLockType;

/*! Context information of the DID Manager */
struct DCM_DIDMANAGERCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidLockType  DidLockList[DCM_DIDMGR_DID_LOCK_LIST_SIZE];            /*!< List of Dids which can be handled in parallel */
# if (DCM_DIDMGR_IODID_NBYTE_EXT_CEMR_ENABLED == STD_ON)
  Dcm_MsgItemType IoControlCemrSessionMask[DCM_DIDMGR_IODID_MAX_EXT_CEMR_SIZE]; /*!< CEMR session mask for service 0x2F */
# endif
};
typedef struct DCM_DIDMANAGERCONTEXTTYPE_TAG Dcm_DidManagerContextType;

/* Read port operations */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadSyncType)(Dcm_MsgType);

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadAsyncType)(Dcm_OpStatusType
                                                                       ,Dcm_MsgType);

# if (DCM_DIDMGR_SR_SUPPORT_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadSRType)(Dcm_DiagDataContextPtrType);
# endif

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadPagedDidType)(Dcm_OpStatusType
                                                                          ,Dcm_MsgType
                                                                          ,Dcm_DidMgrDidLengthPtrType);
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadDidRangeType)(uint16
                                                                          ,Dcm_MsgType
                                                                          ,Dcm_OpStatusType
                                                                          ,Dcm_DidMgrDidLengthPtrType
                                                                          ,Dcm_NegativeResponseCodePtrType);
# endif

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadWrapperType)(uint16
                                                                         ,Dcm_OpStatusType
                                                                         ,Dcm_DiagDataContextPtrType);

# if (DCM_DIDMGR_VID_SUPPORT_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadVidType)(Dcm_OpStatusType
                                                                     ,Dcm_MsgType
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
                                                                     ,Dcm_Uint8VarDataPtrType
#  endif
                                                                     );
# endif

/* Read Length port operations */
# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadDidRangeLengthType)(uint16
                                                                                ,Dcm_OpStatusType
                                                                                ,Dcm_DidMgrDidLengthPtrType);
# endif

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadLengthSyncType)(Dcm_DidMgrDidLengthPtrType);

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadLengthAsyncType)(Dcm_OpStatusType
                                                                             ,Dcm_DidMgrDidLengthPtrType);

/* Read CheckCondition port operations */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadCheckCondSyncType)(Dcm_NegativeResponseCodePtrType);

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadCheckCondAsyncType)(Dcm_OpStatusType
                                                                                ,Dcm_NegativeResponseCodePtrType);

/* ScalingInformation port operations */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncGetScalingInfoSyncType)(Dcm_MsgType
                                                                                ,Dcm_NegativeResponseCodePtrType);

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncGetScalingInfoAsyncType)(Dcm_OpStatusType
                                                                                 ,Dcm_MsgType
                                                                                 ,Dcm_NegativeResponseCodePtrType);

/* Write port operations */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteNLenSyncNResErrorType)(Dcm_MsgType
                                                                                    ,Dcm_NegativeResponseCodePtrType);

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteNLenAsyncNResErrorType)(Dcm_MsgType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,Dcm_NegativeResponseCodePtrType);

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteLenAsyncNResErrorType)(Dcm_MsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,Dcm_OpStatusType
                                                                                    ,Dcm_NegativeResponseCodePtrType);

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteLenSyncNResErrorType)(Dcm_MsgType
                                                                                   ,Dcm_DidMgrDidLengthType
                                                                                   ,Dcm_NegativeResponseCodePtrType);
# if (DCM_DIDMGR_WRITE_SUPPORTEDDID_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteWrapperType)(Dcm_MsgContextPtrType
                                                                          ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_DIDMGR_SR_SUPPORT_ENABLED == STD_ON) || (DCM_DIDMGR_ATOMIC_NV_DATA_SUPPORT_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteNLenSyncNResNErrorType)(Dcm_MsgType);                                                  /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteDidRangeType)(uint16
                                                                           ,Dcm_MsgType
                                                                           ,Dcm_OpStatusType
                                                                           ,Dcm_DidMgrDidLengthType
                                                                           ,Dcm_NegativeResponseCodePtrType);
#  if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
/* IsAvailable range DID port operations */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncRangeIsAvailDidType)(uint16
                                                               ,Dcm_OpStatusType
                                                               ,P2VAR(Dcm_DidSupportedType, AUTOMATIC, DCM_VAR_NOINIT));
#  endif
# endif

/* IO Control port operations */

/* No CEMR */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncNCemrErrorType)(Dcm_NegativeResponseCodePtrType);
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncNCemrErrorType)(Dcm_OpStatusType
                                                                                      ,Dcm_NegativeResponseCodePtrType);
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncNCemrErrorType)(Dcm_ReadOnlyMsgType
                                                                                     ,Dcm_NegativeResponseCodePtrType);
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncNCemrErrorType)(Dcm_ReadOnlyMsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,Dcm_NegativeResponseCodePtrType);
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncNCemrErrorType)(Dcm_ReadOnlyMsgType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,Dcm_NegativeResponseCodePtrType);
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncNCemrErrorType)(Dcm_ReadOnlyMsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,Dcm_NegativeResponseCodePtrType);

/* CEMR 8Bit */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemr8ErrorType)(uint8
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemr8ErrorType)(Dcm_OpStatusType
                                                                                      ,uint8
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemr8ErrorType)(Dcm_ReadOnlyMsgType
                                                                                     ,uint8
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemr8ErrorType)(Dcm_ReadOnlyMsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,uint8
                                                                                    ,Dcm_NegativeResponseCodePtrType);                               /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemr8ErrorType)(Dcm_ReadOnlyMsgType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,uint8
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemr8ErrorType)(Dcm_ReadOnlyMsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,uint8
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */

/* CEMR 16Bit */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemr16ErrorType)(uint16
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemr16ErrorType)(Dcm_OpStatusType
                                                                                      ,uint16
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemr16ErrorType)(Dcm_ReadOnlyMsgType
                                                                                      ,uint16
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemr16ErrorType)(Dcm_ReadOnlyMsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,uint16
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemr16ErrorType)(Dcm_ReadOnlyMsgType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,uint16
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemr16ErrorType)(Dcm_ReadOnlyMsgType
                                                                                      ,Dcm_DidMgrDidLengthType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,uint16
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */

/* CEMR 32Bit */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemr32ErrorType)(uint32
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemr32ErrorType)(Dcm_OpStatusType
                                                                                      ,uint32
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemr32ErrorType)(Dcm_ReadOnlyMsgType
                                                                                      ,uint32
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemr32ErrorType)(Dcm_ReadOnlyMsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,uint32
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemr32ErrorType)(Dcm_ReadOnlyMsgType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,uint32
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemr32ErrorType)(Dcm_ReadOnlyMsgType
                                                                                      ,Dcm_DidMgrDidLengthType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,uint32
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */

/* CEMR NBit */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemrNErrorType)(Dcm_ReadOnlyMsgType
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemrNErrorType)(Dcm_OpStatusType
                                                                                      ,Dcm_ReadOnlyMsgType
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemrNErrorType)(Dcm_ReadOnlyMsgType
                                                                                     ,Dcm_ReadOnlyMsgType
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemrNErrorType)(Dcm_ReadOnlyMsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,Dcm_ReadOnlyMsgType
                                                                                    ,Dcm_NegativeResponseCodePtrType);                               /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemrNErrorType)(Dcm_ReadOnlyMsgType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,Dcm_ReadOnlyMsgType
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemrNErrorType)(Dcm_ReadOnlyMsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,Dcm_ReadOnlyMsgType
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# if (DCM_DIDMGR_WRITE_SUPPORTEDDID_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoWrapperType)(Dcm_MsgContextPtrType pMsgContext
                                                                       ,Dcm_NegativeResponseCodePtrType ErrorCode);                                  /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/*! Routine operation function prototype with no request and response data */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncNoParamsType)(Dcm_OpStatusType
                                                                           ,Dcm_NegativeResponseCodePtrType);

/*! Routine operation function prototype with only request data both with static length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqType)(Dcm_ReadOnlyMsgType
                                                                      ,Dcm_OpStatusType
                                                                      ,Dcm_NegativeResponseCodePtrType);

/*! Routine operation function prototype with request and response data with static length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqResType)(Dcm_ReadOnlyMsgType
                                                                         ,Dcm_OpStatusType
                                                                         ,Dcm_MsgType
                                                                         ,Dcm_NegativeResponseCodePtrType);

/*! Routine operation function prototype with only response data with static length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncResType)(Dcm_OpStatusType
                                                                      ,Dcm_MsgType
                                                                      ,Dcm_NegativeResponseCodePtrType);

/*! Routine operation function prototype with only request data with dynamic length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqDynLenType)(Dcm_ReadOnlyMsgType
                                                                            ,Dcm_OpStatusType
                                                                            ,Dcm_RidMgrRidLengthType
                                                                            ,Dcm_NegativeResponseCodePtrType);

/*! Routine operation function prototype with request data with dynamic length and response data with static length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqDynLenResType)(Dcm_ReadOnlyMsgType
                                                                               ,Dcm_OpStatusType
                                                                               ,Dcm_MsgType
                                                                               ,Dcm_RidMgrRidLengthType
                                                                               ,Dcm_NegativeResponseCodePtrType);

/*! Routine operation function prototype with request data with dynamic/static length and response data with dynamic length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqAnyLenResDynLenType)(Dcm_ReadOnlyMsgType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,Dcm_MsgType
                                                                                     ,Dcm_RidMgrRidLengthPtrType
                                                                                     ,Dcm_NegativeResponseCodePtrType);

/*! Routine operation function prototype with response data with dynamic length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncResDynLenType)(Dcm_OpStatusType
                                                                            ,Dcm_MsgType
                                                                            ,Dcm_RidMgrRidLengthPtrType
                                                                            ,Dcm_NegativeResponseCodePtrType);

/*! Generic routine operation function prototype which implementation will be generated depending on the RID configuration */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncWrapperType)(Dcm_OpStatusType
                                                                          ,Dcm_MsgContextPtrType
                                                                          ,Dcm_RidMgrRidLengthPtrType
                                                                          ,Dcm_NegativeResponseCodePtrType);
# if (DCM_DIDMGR_IO_CONTROL_SUPPORTEDDID_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncSuppIDWrapperType)(Dcm_MsgContextPtrType);
# endif
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
/*! Data container with all instantiatable elements (i.e. for multi-server mode)  */
struct DCM_INSTANCECONTEXTTYPE_TAG
{
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_PagedBufferContextType    PagedBuffer;    /*!< Paged-buffer manager sub-component per-instance memory */
#endif
  Dcm_DiagContextType           Diag;           /*!< Diagnostic kernel sub-component per-instance memory */
  Dcm_RepeaterContextType       Repeater;       /*!< Diagnostic service processor repeater sub-component per-instance memory */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
  Dcm_DidManagerContextType     DidMgr;         /*!< DID manager sub-component per-instance memory */
#endif
#if (DCM_MEMMGR_RAM_CONTEXT_ENABLED == STD_ON)
  Dcm_MemManagerContextType     MemMgr;         /*!< Direct memory access manager sub-component per-instance memory */
#endif
};
typedef struct DCM_INSTANCECONTEXTTYPE_TAG Dcm_InstanceContextType;

/*! Data container for data shared among all DCM instances (in multi-server mode)  */
struct DCM_SINGLETONCONTEXTTYPE_TAG
{
  Dcm_NetContextType         Network;         /*!< Network sub-component shared memory */
  Dcm_TskContextType         TaskMgr;         /*!< System task manager sub-component shared memory */
  Dcm_TmrContextType         TimerMgr;        /*!< System timer manager sub-component shared memory */
  Dcm_StateContextType       StateMgr;        /*!< Diagnostic state manager sub-component shared memory */
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
  Dcm_ModeContextType        ModeMgr;         /*!< Mode manager sub-component shared memory */
#endif
#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
  Dcm_VarManagerContextType  VarMgr;          /*!< Variant manager sub-component shared memory */
#endif
};
typedef struct DCM_SINGLETONCONTEXTTYPE_TAG Dcm_SingletonContextType;
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc02RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc02RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc04RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc04RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
typedef P2VAR(Dcm_Svc10RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc10RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc11RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc11RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc14RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc14RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! DEM filter configuration selector type */
typedef uint8 Dcm_Svc19DemSetFilterClassType;
/*! Report DTC by status mask engine mask usage type */
typedef uint8 Dcm_Svc19DemSetFilterMaskUsageType;
/*! Abstract DTC record iterator result type */
typedef uint8 Dcm_Svc19UtiRecordIterResultType;

/*! Descriptor of a DEM filter configuration */
struct DCM_SVC19DEMDTCFILTERINFOTYPE_TAG
{
# if (DCM_DEM_API_430_ENABLED == STD_OFF)
  Dem_DTCKindType                Kind;             /*!< DTC kind */
# endif
  Dem_DTCOriginType              Origin;           /*!< DTC origin */
  Dcm_DemFilterWithSeverityType  ConsiderSeverity; /*!< DTC severity */
};
typedef struct DCM_SVC19DEMDTCFILTERINFOTYPE_TAG Dcm_Svc19DemDtcFilterInfoType;
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc22RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc22RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc23RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)    Dcm_Svc23RepeaterProxyContextPtrType;
typedef P2CONST(Dcm_Svc23RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc23RepeaterProxyContextConstPtrType;
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc24RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc24RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/*! Function pointer prototype for a Get-Seed handler with Security-Access-Data-Record */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_Svc27OpFuncSeedWAdr)(Dcm_MsgType
                                                                 ,Dcm_OpStatusType
                                                                 ,Dcm_MsgType
                                                                 ,Dcm_NegativeResponseCodePtrType);

/*! Function pointer prototype for a Get-Seed handler without Security-Access-Data-Record */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_Svc27OpFuncSeedWoAdr)(Dcm_OpStatusType
                                                                  ,Dcm_MsgType
                                                                  ,Dcm_NegativeResponseCodePtrType);
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc28RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc28RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc2ARepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2ARepeaterProxyContextPtrType;
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc2CRepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2CRepeaterProxyContextPtrType;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc2ERepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc2ERepeaterProxyContextPtrType;
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc2FRepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc2FRepeaterProxyContextPtrType;
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc31RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc31RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc3DRepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)    Dcm_Svc3DRepeaterProxyContextPtrType;
typedef P2CONST(Dcm_Svc3DRepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc3DRepeaterProxyContextConstPtrType;
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc85RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc85RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc86RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc86RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Module internal inlined function declarations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initialization of the direct memory access sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_MemMgrInit(void);

/**********************************************************************************************************************
 *  Dcm_MemMgrConvMemOpResult()
 *********************************************************************************************************************/
/*! \brief          Converts memory operation result to standard result type.
 *  \details        -
 *  \param[in]      memOpResult   Memory operation result
 *  \param[in]      opStatus      Current operation status
 *  \param[in,out]  ErrorCode     The NRC from application and result to diag core
 *  \param[in]      DefaultNrc    Default NRC in case application is not able to report any particular one
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrConvMemOpResult(Dcm_MemMgrOpResultType memOpResult
                                                                         ,Dcm_OpStatusType opStatus
                                                                         ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                         ,Dcm_NegativeResponseCodeType DefaultNrc);

/**********************************************************************************************************************
 *  Dcm_MemMgrGetMemMap()
 *********************************************************************************************************************/
/*! \brief          Returns a memory map descriptor or reports error.
 *  \details        -
 *  \param[in]      pMemBlock          The memory block descriptor for validation
 *  \param[out]     pMemMapDescriptor  Returns the corresponding memory map descriptor
 *  \param[out]     ErrorCode          The NRC result to diag core
 *  \return         DCM_E_OK     - returned memory map is valid
 *  \return         DCM_E_NOT_OK - returned memory map is not valid (ErrorCode contains NRC)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrGetMemMap(Dcm_MemMgrMemBlockConstPtrType pMemBlock
                                                                   ,Dcm_CfgMemMgrMemIdInfoPtrType pMemMapDescriptor
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode);

/**********************************************************************************************************************
 *  Dcm_MemMgrCheckMemoryRange()
 *********************************************************************************************************************/
/*! \brief          Validates memory range within a particular memory map.
 *  \details        -
 *  \param[in]      pMemBlock          The memory block descriptor for validation
 *  \param[in]      memOp              The memory block operation type
 *  \param[in]      pMemMapDescriptor  The the corresponding memory map to be searched in
 *  \param[out]     ErrorCode          The NRC
 *  \return         DCM_E_OK     - memory range is valid
 *  \return         DCM_E_NOT_OK - memory range validation failed (ErrorCode contains NRC)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrCheckMemoryRange(Dcm_MemMgrMemBlockConstPtrType pMemBlock
                                                                   ,Dcm_MemMgrMemoryOpType memOp
                                                                   ,Dcm_CfgMemMgrMemIdInfoConstPtrType pMemMapDescriptor
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode);

/**********************************************************************************************************************
 *  Dcm_MemMgrDwordExtract()
 *********************************************************************************************************************/
/*! \brief          Extracts a double word from request.
 *  \details        -
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in]      numBytes           The number of bytes to extract from the request
 *  \return                            The extracted double word
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_MemMgrDwordExtract(Dcm_MsgContextPtrType pMsgContext
                                                              ,uint8_least           numBytes);
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId()
 *********************************************************************************************************************/
/*! \brief          Read operation for a Supported OBD MID Mask.
 *  \details        -
 *  \param[in]      ObdMID         Supported OBD Monitor Id
 *  \param[in,out]  pDataContext   The pointer to the data context
 *  \return         DCM_E_OK       Read operation was successful
 *  \return         DCM_E_NOT_OK   Read operation was not successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            Obd MID is a supported MID (0x00, 0x20, 0x40,..)
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId(uint8 ObdMID
                                                                                         ,Dcm_DiagDataContextPtrType pDataContext);
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_DataId()
 *********************************************************************************************************************/
/*! \brief          Read operation for a OBD MID.
 *  \details        Reads test result for given OBD MID
 *  \param[in]      ObdMID         OBD Monitor Id
 *  \param[in,out]  pDataContext   The pointer to the data context
 *  \return         DCM_E_OK       Read operation was successful
 *  \return         DCM_E_NOT_OK   Read operation was not successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            Obd MID is not a supported MID (0x00, 0x20, 0x40,..)
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_DataId(uint8 ObdMID
                                                                                    ,Dcm_DiagDataContextPtrType pDataContext);
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if (DCM_UTI_NVM_READ_ENABLED  == STD_ON) || \
     (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_UtiArEnvNvMGetErrorStatus()
 *********************************************************************************************************************/
/*! \brief          Adapter function for AR 3.XX NvM_GetErrorStatus().
 *  \details        -
 *  \param[in]      blockId    Id of the NvRam block
 *  \param[out]     nvmStatus  Delegates the result from the NvM_GetErrorStatus()
 *  \return         E_OK       This value is always returned.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiArEnvNvMGetErrorStatus(uint16 blockId
                                                        ,P2VAR(NvM_RequestResultType, AUTOMATIC, AUTOMATIC) nvmStatus);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_UTI_LOOKUP_RANGE_U16_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_UtiLookUpRangeUint16()
 *********************************************************************************************************************/
/*! \brief          Searches a word in a table of ranges.
 *  \details        -
 *  \param[in]      lookUpTable    Pointer to the table to be scanned (first element is table-size!)
 *  \param[in]      value          Value to be found
 *  \return         -1             Look up failed (no match)
 *  \return         >=0            Success, index of the matched position
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            Total number of elements for look up shall be < 32768.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpRangeUint16(P2CONST(Dcm_UtiU16RangeType, AUTOMATIC, DCM_CONST) lookUpTable
                                                                      ,uint16 value);
#endif
#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_NetIsRxPduIdValid()
 *********************************************************************************************************************/
/*! \brief          Checks the received rxPduId.
 *  \details        -
 *  \param[in]      rxPduId    The rxPduId of the request
 *  \return         TRUE       The rxPduId is valid
 *  \return         FALSE      The rxPduId is not valid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsRxPduIdValid(PduIdType rxPduId);
#endif

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_NetIsTxPduIdValid()
 *********************************************************************************************************************/
/*! \brief          Checks the received txPduId.
 *  \details        -
 *  \param[in]      txPduId    The txPduId of the request
 *  \return         TRUE       The txPduId is valid
 *  \return         FALSE      The txPduId is not valid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsTxPduIdValid(PduIdType txPduId);
#endif

/**********************************************************************************************************************
 *  Dcm_NetGetComMContext()
 *********************************************************************************************************************/
/*! \brief          Returns a ComM context element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a ComM context
 *  \return         ComM context object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetComMContextPtrType, DCM_CODE) Dcm_NetGetComMContext(Dcm_CfgNetNetIdRefOptType index);

/**********************************************************************************************************************
 *  Dcm_NetGetBufferContext()
 *********************************************************************************************************************/
/*! \brief          Returns a buffer context element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a buffer context
 *  \return         Buffer context object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetBufferContextPtrType, DCM_CODE) Dcm_NetGetBufferContext(Dcm_CfgNetBufferRefOptType index);

/**********************************************************************************************************************
 *  Dcm_NetGetTransportObject()
 *********************************************************************************************************************/
/*! \brief          Returns a transport object element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a transport object
 *  \return         Transport object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetGetTransportObject(
                                                                                    Dcm_CfgNetTObjHandleOptType index);

#if (DCM_NET_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetSetComControlChannelState()
 *********************************************************************************************************************/
/*! \brief          Sets the state of a communication control channel of the given index.
 *  \details        -
 *  \param[in]      index    Index to the communication control channel
 *  \param[in]      value    New communication mode
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetSetComControlChannelState(uint8_least index
                                                                      ,Dcm_CommunicationModeType value);
#endif

/**********************************************************************************************************************
 *  Dcm_NetPutToConn2TObjMap()
 *********************************************************************************************************************/
/*! \brief          Sets a transport object handle of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a transport object handle
 *  \param[in]      value    New handle
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPutToConn2TObjMap(Dcm_NetConnRefOptType index
                                                              ,Dcm_CfgNetTObjHandleMemType value);

/**********************************************************************************************************************
 *  Dcm_NetWriteAddBufferU8At()
 *********************************************************************************************************************/
/*! \brief          Writes into the additional buffer of a transport object.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object
 *  \param[in]      index         Index to the additional buffer
 *  \param[in]      value         New value of the transport object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetWriteAddBufferU8At(Dcm_NetTransportObjectPtrType pTranspObj
                                                               ,uint8_least index
                                                               ,Dcm_MsgItemType value);

/**********************************************************************************************************************
 *  Dcm_NetGetBufferInfo()
 *********************************************************************************************************************/
/*! \brief          Returns a buffer information element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a buffer information element
 *  \return         Buffer info object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_PbCfgNetBufferInfoPtrType, DCM_CODE) Dcm_NetGetBufferInfo(Dcm_CfgNetBufferRefOptType index);

/**********************************************************************************************************************
 *  Dcm_NetCommonInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the common network related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetCommonInit(void);

/**********************************************************************************************************************
 *  Dcm_NetComMInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the ComM related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComMInit(void);

/**********************************************************************************************************************
 *  Dcm_NetBufferInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the buffer related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetBufferInit(void);

/**********************************************************************************************************************
 *  Dcm_NetConnectionInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the connection related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetConnectionInit(void);

/**********************************************************************************************************************
 *  Dcm_NetTranspObjInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the transport object related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTranspObjInit(void);

/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the periodic message related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgInit(void);

/**********************************************************************************************************************
 *  Dcm_NetInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the network sub-module.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetInit(void);

/**********************************************************************************************************************
 *  Dcm_NetRegisterActiveConnection()
 *********************************************************************************************************************/
/*! \brief          Registers an active connection.
 *  \details        Function will be called from Dcm_NetStartOfReception.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRegisterActiveConnection(Dcm_NetTransportObjectPtrType pTranspObj);

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetOnRequestDetection()
 *********************************************************************************************************************/
/*! \brief          Cancels any pending job if detected another ECU to be requested from the same client.
 *  \details        Function will be called from Dcm_NetStartOfReception.
 *  \param[in]      connId        The connection ID of the foreign ECU request
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetOnRequestDetection(Dcm_NetConnRefMemType connId);
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisation_FindWinner()
 *********************************************************************************************************************/
/*! \brief          Determination of request with highest priority.
 *  \details        -
 *  \param[in]      ev                      The active event(s) of the task Dcm_NetTaskRx
 *  \param[out]     pBusyEvents             Bitfield for busy requests
 *  \return         ID of the winner
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetTObjHandleOptType, DCM_CODE) Dcm_NetRxPrioritisation_FindWinner(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pBusyEvents);
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessWinner()
 *********************************************************************************************************************/
/*! \brief          Processing of the request with the highest priority.
 *  \details        -
 *  \param[in]      TranspObjWinnerId       ID of the winner
 *  \param[in]      pBusyEvents             Bitfield for busy requests
 *  \return         Updated bitfield for busy requests
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_NetRxPrioritisationProcessWinner(
                                                                          Dcm_CfgNetTObjHandleOptType TranspObjWinnerId
                                                                         ,Dcm_TskTaskEvOptType BusyEvents);
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessLoosers()
 *********************************************************************************************************************/
/*! \brief          Processing of requests that were preempted.
 *  \details        -
 *  \param[in]      BusyEvents             Bitfield for busy requests
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisationProcessLoosers(Dcm_TskTaskEvOptType BusyEvents);
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisation()
 *********************************************************************************************************************/
/*! \brief          Prioritization of received requests.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task Dcm_NetTaskRx
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisation(Dcm_TskTaskEvOptType ev
                                                             ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if(DCM_NET_PROTOCOL_SWITCH_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetExecStartProtocolOp()
 *********************************************************************************************************************/
/*! \brief          Executes a protocol start up.
 *  \details        -
 *  \param[in]      newProtocol    The new protocol ID to be evaluated for starting
 *  \return         TRUE           Proceed with protocol starting
 *  \return         FALSE          Skip any further service processing after return
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetExecStartProtocolOp(Dcm_ProtocolType newProtocol);
#endif

/**********************************************************************************************************************
 *  Dcm_NetComposeAddNegResponse()
 *********************************************************************************************************************/
/*! \brief          Composes a negative response.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object
 *  \param[in]      resType       The response type
 *  \param[in]      nrc           The negative response code
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComposeAddNegResponse(Dcm_NetTransportObjectPtrType pTranspObj
                                                                  ,Dcm_NetResponseType resType
                                                                  ,Dcm_NegativeResponseCodeType nrc);

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetProcessStartProtocol()
 *********************************************************************************************************************/
/*! \brief          Starts a new protocol.
 *  \details        Delegates a new request with a new protocol and terminates the old one.
 *  \param[in]      pTranspObj    The transport object
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetProcessStartProtocol(Dcm_NetTransportObjectPtrType pTranspObj);
#endif

/**********************************************************************************************************************
 *  Dcm_NetTransmitUsdtResponse()
 *********************************************************************************************************************/
/*! \brief          Start transmission on this connection.
 *  \details        Start an USDT transmission over a specific connection.
 *  \param[in]      pTranspObj            The transport object to be used during the transmission.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            All the items of the structure must be validly initialized:
 *                  hBuffer               Shall be the TxBuffer handle
 *                  pduInfo.SduDataPtr    Shall point to the TxBuffer
 *                  pduInfo.SduLength     Shall contain the length of the data to be sent
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTransmitUsdtResponse(Dcm_NetTransportObjectPtrType pTranspObj);

#if (DCM_NET_CONN_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetLockConnectionOrNull()
 *********************************************************************************************************************/
/*! \brief          Allocates a transport object for a concrete client connection.
 *  \details        -
 *  \param[in]      connId    The connection to be locked
 *  \return         Allocated transport object
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetLockConnectionOrNull(Dcm_NetConnRefMemType connId);
#endif

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationNotOk()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception with no success.
 *  \details        This function is called by Dcm_NetTpRxIndication.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationNotOk(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationOk()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception with success.
 *  \details        This function is called by Dcm_NetTpRxIndication.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationOk(Dcm_NetTransportObjectPtrType pTranspObj);

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerGet()
 *********************************************************************************************************************/
/*! \brief          Get remaining delay time.
 *  \details        Returns the remaining delay time of the given timer
 *  \param[in]      timer       ID of the timer
 *  \return         Remaining delay time
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerCntrOptType, DCM_CODE) Dcm_NetDelayTimerGet(uint8_least timer);
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerSet()
 *********************************************************************************************************************/
/*! \brief          Set delay timeout.
 *  \details        Sets the timout for the given delay timer
 *  \param[in]      timer       ID of the timer
 *  \param[in]      timeout     Timeout value
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetDelayTimerSet(uint8_least timer, Dcm_TmrTimerCntrOptType timeout);
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerExpired()
 *********************************************************************************************************************/
/*! \brief          Check if the delay timer timed out.
 *  \details        Returns whether the given delay timer timed out
 *  \param[in]      timer       ID of the timer
 *  \return         TRUE        Timer has expired
 *  \return         FALSE       Timer is running
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetDelayTimerExpired(uint8_least timer);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerSet()
 *********************************************************************************************************************/
/*! \brief          Set the timeout for the given periodic transport object.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \param[in]      timeout           Timout of the timer
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerSet(Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
                                                           ,Dcm_TmrTimerCntrOptType timeout);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerStart()
 *********************************************************************************************************************/
/*! \brief          Start the timer for the given periodic transport object.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \param[in]      timeout           Timout of the timer
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerStart(Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
                                                             ,Dcm_TmrTimerCntrOptType timeout);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerStop()
 *********************************************************************************************************************/
/*! \brief          Stop the timer for the given periodic transport object.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerStop(Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj);
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgIncNextDelayTimer()
 *********************************************************************************************************************/
/*! \brief          Set delay timer index to next timer.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgIncNextDelayTimer(void);
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgSetFastestRate()
 *********************************************************************************************************************/
/*! \brief          Sets a new fastest rate.
 *  \details        -
 *  \param[in]      Rate    The periodic rate
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgSetFastestRate(Dcm_Svc2ASchedRateOptType Rate);
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxDelayTimerStart()
 *********************************************************************************************************************/
/*! \brief          Starts a delay timer for periodic message transmission.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxDelayTimerStart(void);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutTxObjectHandler()
 *********************************************************************************************************************/
/*! \brief          Executes jobs on timeout of a transport object timer.
 *  \details        -
 *  \return         Flag whether timer needs to be reloaded
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutTxObjectHandler(void);
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutDelayTimerHandler()
 *********************************************************************************************************************/
/*! \brief          Executes jobs on timeout of a delay timer.
 *  \details        -
 *  \return         Flag whether timer needs to be reloaded
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutDelayTimerHandler(void);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetGetPeriodicTxObject()
 *********************************************************************************************************************/
/*! \brief          Returns a periodic transport object element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a periodic transport object
 *  \return         Periodic transport object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetPeriodicTxObjectPtrType, DCM_CODE) Dcm_NetGetPeriodicTxObject(
                                                                                   Dcm_CfgNetPTxObjHandleOptType index);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgGetTxBuffer()
 *********************************************************************************************************************/
/*! \brief          Return the tx buffer of the periodic message with the given index.
 *  \details        -
 *  \param[in]      perTxObjHandle    Handle of periodic transport object to be transmitted
 *  \return         Tx buffer of periodic transport object
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The periodic message shall first be allocated via Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_MsgType, DCM_CODE) Dcm_NetPeriodicMsgGetTxBuffer(Dcm_CfgNetPTxObjHandleOptType perTxObjHandle);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmitTxObj()
 *********************************************************************************************************************/
/*! \brief          Transmits a periodic message.
 *  \details        -
 *  \param[in]      perTxObjHandle    Handle of periodic transport object to be transmitted
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The periodic message shall first be allocated via Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmitTxObj(Dcm_CfgNetPTxObjHandleOptType perTxObjHandle);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgResetConnection()
 *********************************************************************************************************************/
/*! \brief          Resets the periodic message connection.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgResetConnection(void);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgStopDid()
 *********************************************************************************************************************/
/*! \brief          Stops transmission of DID and also removes queued transport objects.
 *  \details        -
 *  \param[in]      Did      DID that is to be stopped
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgStopDid(uint16 Did);
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTpTxConfirmation()
 *********************************************************************************************************************/
/*! \brief          Confirmation for a specific TxPduId TP channel.
 *  \details        This function is called by Dcm_TpTxConfirmation.
 *  \param[in]      txPduId    The confirmation TxPDUID of the response
 *  \param[in]      result     Request reception status
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpTxConfirmation(PduIdType txPduId
                                                             ,Dcm_NetArEnvNotifResultType result);
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_NetIsPduInfoValid()
 *********************************************************************************************************************/
/*! \brief          Checks the received PduInfo.
 *  \details        -
 *  \param[in]      info       Message context (data and length of the portion)
 *  \return         TRUE       The info element is valid
 *  \return         FALSE      The info element is not valid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsPduInfoValid(P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info);
# endif

/**********************************************************************************************************************
 *  Dcm_NetCopyRxData()
 *********************************************************************************************************************/
/*! \brief          Copies request data from the lower layer.
 *  \details        This function is called by Dcm_CopyRxData.
 *  \param[in]      pTranspObj         The transport object
 *  \param[in]      info               Message context (data and length of the portion)
 *  \param[out]     bufferSizePtr      Available buffer size
 *  \return         BUFREQ_OK          A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK    No free buffer is available - ignore request
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyRxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                        ,P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info
                                                        ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr);

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndication()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception.
 *  \details        This function is called by Dcm_TpRxIndication.
 *  \param[in]      rxPduId    The RxPDUID of the request.
 *  \param[in]      result     Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndication(PduIdType rxPduId
                                                           ,Dcm_NetArEnvNotifResultType result);

/**********************************************************************************************************************
 *  Dcm_NetCopyLinearTxData()
 *********************************************************************************************************************/
/*! \brief          Copies transmit data in linear form to the lower layer.
 *  \details        This function is called by Dcm_NetCopyTxData for the linear response data case.
 *  \param[in]      pTranspObj          The transport object
 *  \param[in]      info                Pointer to a PduInfoType, which indicates the number of bytes to be copied
 *                                      (SduLength) and the location where the data have to be copied to (SduDataPtr).
 *                                      An SduLength of 0 is possible in order to poll the available transmit data
 *                                      count. In this case no data are to be copied and SduDataPtr might be invalid.
 *  \param[in]      availableDataPtr    Remaining Tx data after completion of this call
 *  \return         BUFREQ_OK           A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK     Some error occurred (i.e. internal error detected)
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyLinearTxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                      ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                             /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                      ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr);

/**********************************************************************************************************************
 *  Dcm_NetCopyTxData()
 *********************************************************************************************************************/
/*! \brief          Copies transmit data to the lower layer.
 *  \details        This function is called by Dcm_CopyTxData.
 *  \param[in]      pTranspObj          The transport object
 *  \param[in]      info                Pointer to a PduInfoType, which indicates the number of bytes to be copied
 *                                      (SduLength) and the location where the data have to be copied to (SduDataPtr).
 *                                      An SduLength of 0 is possible in order to poll the available transmit data
 *                                      count. In this case no data are to be copied and SduDataPtr might be invalid.
 *  \param[in]      availableDataPtr    Remaining Tx data after completion of this call.
 *  \return         BUFREQ_OK           Response data is available - all requested data are copied
 *  \return         BUFREQ_E_BUSY       The required amount of data is not available - try later again
 *  \return         BUFREQ_E_NOT_OK     Some error occurred (e.g. no more data, internal error detected etc.)
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyTxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                     ,P2VAR(PduInfoType,   AUTOMATIC, DCM_APPL_DATA) info                                            /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                     ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr);
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_PagedBufferInit()
 *********************************************************************************************************************/
/*! \brief          Initialize paged-buffer any time.
 *  \details        Initialization of the paged-buffer.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInit(void);

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDefragmentPage()
 *********************************************************************************************************************/
/*! \brief          Defragments the current paged-buffer page.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferDefragmentPage(void);
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferUpdatePage()
 *********************************************************************************************************************/
/*! \brief          Dispatches the UpdatePage call.
 *  \details        Dispatches the UpdatePage call regarding the paged-buffer.
 *  \param[out]     ErrorCode             The NRC
 *  \return         DCM_E_OK              All data has been copied - evaluate the out parameters
 *  \return         DCM_E_PENDING         No result yet, retry later
 *  \return         DCM_E_NOT_OK          Something went wrong, stop updating(only in DET situation)
 *  \return         DCM_E_BUFFERTOOLOW    Some data copied but no place, retry later on TP buffer under-run
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferUpdatePage(Dcm_NegativeResponseCodePtrType ErrorCode);
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*! \brief          Copy from paged-buffer to the TP layer.
 *  \details        -
 *  \param[in,out]  PduInfo             PduR message context
 *  \param[in]      Length              Remained data in the buffer
 *  \return         BUFREQ_OK           A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK     No free buffer is available - ignore request
 *  \return         BUFREQ_E_BUSY       No free buffer at this time - try later again
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
                                                                   P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) PduInfo
                                                                  ,PduLengthType Length);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*! \brief          Copy from paged-buffer to the TP layer.
 *  \details        -
 *  \param[in]      info                Message context (data and length of the portion)
 *  \param[in]      availableDataPtr    Remaining Tx data after completion of this call
 *  \return         BUFREQ_OK           A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK     No free buffer is available - ignore request
 *  \return         BUFREQ_E_BUSY       No free buffer at this time - try later again
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
                                                      P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info
                                                     ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_RepeaterNextStep()
 *********************************************************************************************************************/
/*! \brief          Sets next step of repeater proxy.
 *  \details        -
 *  \param[in]      nextStep    Next step to be processed
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_RepeaterNextStep(Dcm_RepeaterProgressType nextStep);

/**********************************************************************************************************************
 *  Dcm_CfgDiagServiceInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get Service info descriptor.
 *  \details        -
 *  \param[in]      SidIndex      Index to a Service info descriptor
 *  \return         Service info descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgDiagServiceInfoPtrType, DCM_CODE) Dcm_CfgDiagServiceInfoGetEntryOrNull(uint8_least SidIndex);
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgModeMgrRulesGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get module rule.
 *  \details        -
 *  \param[in]      modeRuleRef    A reference to a mode rule
 *  \return         Module Rule function
 *  \return         NULL_PTR       On invalid mode rule reference (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_ModeRuleFuncType, DCM_CODE) Dcm_CfgModeMgrRulesGetEntryOrNull(Dcm_CfgModeMgrRuleRefOptType modeRuleRef);
# endif

# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeCheck()
 *********************************************************************************************************************/
/*! \brief          Performs a mode rule check.
 *  \details        -
 *  \param[in]      modeRuleRef    A reference to a mode rule
 *  \param[out]     ErrorCode      The NRC
 *  \return         DCM_E_OK       Mode rule check was successful
 *  \return         DCM_E_NOT_OK   Mode rule check was not successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeCheck(Dcm_CfgModeMgrRuleRefOptType modeRuleRef
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif

# if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeMonitorControlDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Verifies that the DTCsetting auto-recovery condition is not yet met.
 *  \details        -
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_ModeTaskMonitor task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeMonitorControlDtcSetting(Dcm_TskTaskEvPtrType pPostEv);
# endif

# if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeMonitorCommunicationControl()
 *********************************************************************************************************************/
/*! \brief          Verifies that the CommunicationControl auto-recovery condition is not yet met.
 *  \details        -
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_ModeTaskMonitor task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeMonitorCommunicationControl(Dcm_TskTaskEvPtrType pPostEv);
# endif

/**********************************************************************************************************************
 *  Dcm_ModeInit()
 *********************************************************************************************************************/
/*! \brief          Initializes DCM mode manager sub-module.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts must be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeInit(void);
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON) || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switch acknowledgment for an ECU Reset/RapidPowershutDown command.
 *  \details        -
 *  \return         DCM_E_OK - This value is always returned.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(void);
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON) || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switching for an ECU Reset/RapidPowershutDown command.
 *  \details        -
 *  \param[in]      mode    The mode
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(Dcm_ResetModeType mode);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)   || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckResultInterpreter()
 *********************************************************************************************************************/
/*! \brief          Converts a ModeSwitchAck API return value to a DCM standard result.
 *  \details        -
 *  \param[in]      modeSwitchAckResult    The ModeSwitchAck API result
 *  \return         The DCM standard result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckResultInterpreter(Std_ReturnType modeSwitchAckResult);
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switch acknowledgment for an ECU reset command.
 *  \details        -
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(void);
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switching for an ECU reset command.
 *  \details        -
 *  \param[in]      mode    The mode
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(Rte_ModeType_DcmEcuReset mode);
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckRapidShutDown()
 *********************************************************************************************************************/
/*! \brief          Mode switch acknowledgment for a rapid power shutdown command.
 *  \details        -
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckRapidShutDown(void);
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchRapidShutDown()
 *********************************************************************************************************************/
/*! \brief          Mode switching for an ECU reset rapid shut down command.
 *  \details        -
 *  \param[in]      mode    The mode
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchRapidShutDown(Rte_ModeType_DcmModeRapidPowerShutDown mode);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_StateInit()
 *********************************************************************************************************************/
/*! \brief          State initialization.
 *  \details        Initialization of the state manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateInit(void);

#if (DCM_STATE_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateExecOnStateChangeFunc()
 *********************************************************************************************************************/
/*! \brief          Executes all registered on state change functions if precondition no more fulfilled.
 *  \details        -
 *  \param[in]      notifList        The notification list
 *  \param[in]      formerStateId    The former state
 *  \param[in]      newStateId       The new state
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateNotificationInfoPtrType notifList
                                                                    ,uint8 formerStateId
                                                                    ,uint8 newStateId);
#endif

#if (DCM_STATE_SECURITY_LOOKUP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateFindStateIndexFromSecLevel()
 *********************************************************************************************************************/
/*! \brief          Map an external state identifier to an internal state index.
 *  \details        -
 *  \param[in]      secLevel    The security level (incl. LOCKED)
 *  \return         -1          Not found
 *  \return         >= 0        Internal state index
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint8_least, DCM_CODE) Dcm_StateFindStateIndexFromSecLevel(Dcm_SecLevelType secLevel);
#endif

#if ((DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)  &&  (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON))
/**********************************************************************************************************************
*  Dcm_StateVsgGetSecurityFixedByteStateIdx()
*********************************************************************************************************************/
/*! \brief         Returns referencs to active security fixed byte.
*  \details        Returns a reference to a security fixed byte that is assigned to a active VSG
*  \param[in,out]  pStateIndex      Index to security fixed byte VSG configuration in
*                                   Dcm_CfgStateVsgMaskSecurityFixedByte
*  \return         DCM_E_OK         Operation succeeded
*  \return         DCM_E_NOT_OK     No active security fixed byte available
*  \context        TASK
*  \reentrant      TRUE
*  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateVsgGetSecurityFixedByteStateIdx(
                                                            P2VAR(sint32_least, AUTOMATIC, DCM_APPL_DATA) pStateIndex);
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateGetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*! \brief          Provides fixed bytes set up for a specific security level.
 *  \details        This function provides the fixed bytes for the requested security level.
 *                  A security level without configured fixed bytes will return E_OK and no bytes (bufferSize = 0)
 *  \param[in]      secLevel              The requested security level
 *  \param[out]     fixedBytes            Buffer to receive the fixed byte values
 *  \param[in,out]  bufferSize
 *                  IN                    The provided buffer size
 *                  OUT                   The number of fixed bytes for the requested level
 *  \return         E_OK                  The security bytes were copied to the provided buffer
 *  \return         DCM_E_NOT_OK          The security level is not configured
 *  \return         DCM_E_BUFFERTOOLOW    The buffer was too small, bufferSize will contain the number of bytes needed
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateGetSecurityLevelFixedBytes(Dcm_SecLevelType secLevel
                                                                   ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) fixedBytes
                                                                   ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) bufferSize);
#endif

/**********************************************************************************************************************
 *  Dcm_StateNotifyServiceProcessors()
 *********************************************************************************************************************/
/*! \brief          Notifies all related service processors for a state change (of any state group).
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateNotifyServiceProcessors(void);
/**********************************************************************************************************************
 *  Dcm_TskGetTaskInfoOrNull()
 *********************************************************************************************************************/
/*! \brief          Returns a task info element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a task info
 *  \return         Dcm task descriptor entry corresponding to the index
 *  \return         NULL_PTR      On invalid task index (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskInfoPtrType, DCM_CODE) Dcm_TskGetTaskInfoOrNull(Dcm_TskTaskIdOptType index);

/**********************************************************************************************************************
 *  Dcm_TskGetTaskContextOrNull()
 *********************************************************************************************************************/
/*! \brief          Returns a task context element of the given index.
 *  \details        -
 *  \param[in]      taskId    The task ID the context will be returned.
 *  \return         Dcm task context entry corresponding to the index
 *  \return         NULL_PTR      On invalid task index (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskContextPtrType, DCM_CODE) Dcm_TskGetTaskContextOrNull(Dcm_TskTaskIdOptType taskId);

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskRegisterActiveTask()
 *********************************************************************************************************************/
/*! \brief          Registers a task as an active one on top of the task stack.
 *  \details        -
 *  \param[in]      taskId    The task ID to be registered as active.
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE only in case split task is supported.
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskRegisterActiveTask(Dcm_TskTaskIdOptType taskId);
#else
# define Dcm_TskRegisterActiveTask(taskId)                           /* not used */
#endif

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskUnRegisterActiveTask()
 *********************************************************************************************************************/
/*! \brief          Removes an activated task from the task stack.
 *  \details        -
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE only in case split task is supported.
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskUnRegisterActiveTask(void);
#else
# define Dcm_TskUnRegisterActiveTask()                               /* not used */
#endif

/**********************************************************************************************************************
 *  Dcm_TskExecuteActiveTask()
 *********************************************************************************************************************/
/*! \brief          Executes a specific task until all its jobs are finished.
 *  \details        -
 *  \param[in]      taskId    The ID of the task to be executed.
 *  \param[in]      taskEv    A current snapshot of the task's events.
 *  \context        TASK
 *  \reentrant      TRUE only in case split task is supported.
 *  \pre            Must be called only from the Dcm_TskScheduler().
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskExecuteActiveTask(Dcm_TskTaskIdOptType taskId
                                                              ,Dcm_TskTaskEvOptType taskEv);

/**********************************************************************************************************************
 *  Dcm_TskGetSchedulerContextOrNull()
 *********************************************************************************************************************/
/*! \brief          Returns a scheduler context element of the given priority.
 *  \details        -
 *  \param[in]      schedulerPrio    Scheduler priority matching to a specific scheduler context
 *  \return         The scheduler context
 *  \return         NULL_PTR      On invalid scheduler priority (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskSchedulerContextPtrType, DCM_CODE) Dcm_TskGetSchedulerContextOrNull(
                                                                                 Dcm_TskTaskPrioOptType schedulerPrio);

/**********************************************************************************************************************
 *  Dcm_TskInit()
 *********************************************************************************************************************/
/*! \brief          Task initialization.
 *  \details        Initialization of the task manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskInit(void);

#if (DCM_TSK_TASK_KILL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskKillAllTasks()
 *********************************************************************************************************************/
/*! \brief          Kills all killable tasks.
 *  \details        Suspends all internal tasks according to their configuration in Dcm_TskTaskInfo[].
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskKillAllTasks(void);
#endif

#if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskReviveAllTasks()
 *********************************************************************************************************************/
/*! \brief          Revives all killed tasks.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            Must be called within a critical section.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskReviveAllTasks(void);
#else
# define Dcm_TskReviveAllTasks()                                     /* not used */
#endif
/**********************************************************************************************************************
 *  Dcm_TmrGetTimerInfoOrNull()
 *********************************************************************************************************************/
/*! \brief          Returns a timer info element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a timer info
 *  \return         The timer info element corresponding to the index
 *  \return         NULL_PTR      On invalid array boundaries (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerInfoPtrType, DCM_CODE) Dcm_TmrGetTimerInfoOrNull(Dcm_TmrTimerIdOptType index);

/**********************************************************************************************************************
 *  Dcm_TmrSetTimer()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a timer of the given index.
 *  \details        -
 *  \param[in]      timerId       The ID of the timer to be updated
 *  \param[in]      value         New value of the timer
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrSetTimer(Dcm_TmrTimerIdOptType timerId, Dcm_TmrTimerCntrMemType value);

/**********************************************************************************************************************
 *  Dcm_TmrInit()
 *********************************************************************************************************************/
/*! \brief          Timer initialization.
 *  \details        Initialization of the timer manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrInit(void);
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initializes the DID manager sub-component.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrInit(void);

/**********************************************************************************************************************
 *  Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Returns a signal operation class info element of the given index.
 *  \details        -
 *  \param[in]      opInfoRef  The index of the signal operation class info
 *  \return         Signal operation class info entry
 *  \return         NULL_PTR    On invalid reference (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrSignalOpClassInfoPtrType, DCM_CODE) Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(
                                                                        Dcm_CfgDidMgrSignalOpClassRefOptType opInfoRef);

/**********************************************************************************************************************
 *  Dcm_CfgDidMgrDidOpClassInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Returns a DID operation class info element of the given index.
 *  \details        -
 *  \param[in]      opInfoRef  The index of the operation class info
 *  \return         Operation class info entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrDidOpClassInfoPtrType, DCM_CODE) Dcm_CfgDidMgrDidOpClassInfoGetEntry(
                                                                        Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef);

# if (DCM_DIDMGR_SR_IO_CONTROL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to a struct of SR IO-control handlers.
 *  \details        -
 *  \param[in]      ioControlSRHandlerRef  The index of the IO control handlers
 *  \return         Pointer to a struct of SR IO-control handlers
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrIoCtrlSRHandlersPtrType, DCM_CODE) Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry(
                                                         Dcm_CfgDidMgrIoCtrlSRHandlersRefOptType ioControlSRHandlerRef);
# endif

# if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidRangeGap()
 *********************************************************************************************************************/
/*! \brief          Verifies whether the DID is supported within a range.
 *  \details        -
 *  \param[in]      opStatus                    Current operation status
 *  \param[in]      pDidInfoContext             The DID configuration context
 *  \param[in]      pDidOpTypeContext           The context of the DID operation
 *  \return         DCM_E_OK                    Positive look up result
 *  \return         DCM_E_NOT_OK                Negative look up result
 *  \return         DCM_E_LOOKUP_MATCH_FOUND    DID range match, but found a gap
 *  \return         DCM_E_PENDING               Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidRangeGap(Dcm_OpStatusType         opStatus
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDidRangeLookUp()
 *********************************************************************************************************************/
/*! \brief          Searches for the DID in a range to get its corresponding handle (up to 32768 items).
 *  \details        -
 *  \param[in]      opStatus                    Current operation status
 *  \param[in,out]  pDidInfoContext             The DID to be found and its context
 *  \param[in,out]  pDidOpTypeContext           The context of the DID operation
 *  \param[in]      didOp                       The DID operation
 *  \return         DCM_E_OK                    Positive look up result
 *  \return         DCM_E_NOT_OK                Negative look up result
 *  \return         DCM_E_LOOKUP_MATCH_FOUND    DID range match, but found a gap
 *  \return         DCM_E_PENDING               Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDidRangeLookUp(Dcm_OpStatusType             opStatus
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_DidMgrOpOptType               didOp);
# endif

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED== STD_ON) && \
     (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED  == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetRequiredSignalBufSize()
 *********************************************************************************************************************/
/*! \brief          Returns the required buffer size for a read callout of a signal.
 *  \details        -
 *  \param[in]      pDidInfoContext    The context of the DID configuration
 *  \param[in]      pDidOpTypeContext  The context of the DID operation
 *  \return         The required buffer size
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            OpClass of the requested DID must be set.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetRequiredSignalBufSize(
                                                              Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                             ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteSignal()
 *********************************************************************************************************************/
/*! \brief          Writes a single DID signal for service 0x2E.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWriteSignal(Dcm_OpStatusType               opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWrite()
 *********************************************************************************************************************/
/*! \brief          Executes DID writing.
 *  \details        Iterates over all signals of a DID.
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWrite(Dcm_OpStatusType                  opStatus
                                                               ,Dcm_MsgContextPtrType             pMsgContext
                                                               ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                               ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                               ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfoSignal()
 *********************************************************************************************************************/
/*! \brief          Returns a scaling information item of a given DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfoSignal(Dcm_OpStatusType        opStatus
                                                                    ,Dcm_MsgContextPtrType             pMsgContext
                                                                    ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                    ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                    ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfo()
 *********************************************************************************************************************/
/*! \brief          Returns the scaling information of a given DID.
 *  \details        Iterates over all signals of a DID.
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfo(Dcm_OpStatusType            opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   ErrorCode);

# endif

# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlSignal()
 *********************************************************************************************************************/
/*! \brief          DID IO control operator.
 *  \details        -
 *  \param[in]      opStatus            The operation status
 *  \param[in,out]  pMsgContext         The current request context
 *  \param[in,out]  pDidInfoContext     The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext   The context of the DID operation
 *  \param[out]     ErrorCode           Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlSignal(Dcm_OpStatusType           opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControl()
 *********************************************************************************************************************/
/*! \brief          DID IO control operator.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControl(Dcm_OpStatusType                  opStatus
                                                                   ,Dcm_MsgContextPtrType             pMsgContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_INT_CEMR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlWithMask()
 *********************************************************************************************************************/
/*! \brief          DID IO control with control enable mask record support operator.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlWithMask(Dcm_OpStatusType         opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2EcuSignal()
 *********************************************************************************************************************/
/*! \brief          Optimized function for ReturnControlToEcu only!.
 *  \details        -
 *  \param[in]      opInfoRef    Operation information
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(
                                                                       Dcm_CfgDidMgrSignalOpClassRefOptType opInfoRef);
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2Ecu()
 *********************************************************************************************************************/
/*! \brief          Optimized function for ReturnControlToEcu only!.
 *  \details        -
 *  \param[in]      opInfoRef    Operation information
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef);
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalRange()
 *********************************************************************************************************************/
/*! \brief          Reads a specific DID range.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalRange(Dcm_OpStatusType            opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalAsync()
 *********************************************************************************************************************/
/*! \brief          Reads an asynchronous signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalAsync(Dcm_OpStatusType            opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalSync()
 *********************************************************************************************************************/
/*! \brief          Reads a synchronous signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalSync(Dcm_OpStatusType             opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalPaged()
 *********************************************************************************************************************/
/*! \brief          Reads a paged signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalPaged(Dcm_OpStatusType            opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_DIDMGR_VID_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalVid()
 *********************************************************************************************************************/
/*! \brief          Reads a paged signal of a VID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalVid(Dcm_OpStatusType              opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_DIDMGR_SR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalSR()
 *********************************************************************************************************************/
/*! \brief          Reads a signal of a DID with a SR interface.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalSR(Dcm_OpStatusType               opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalGap()
 *********************************************************************************************************************/
/*! \brief          Reads a gap signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalGap(Dcm_OpStatusType              opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalWrapper()
 *********************************************************************************************************************/
/*! \brief          Reads a signal of a DID using a generated wrapper.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalWrapper(Dcm_OpStatusType          opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignal()
 *********************************************************************************************************************/
/*! \brief          Reads a signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignal(Dcm_OpStatusType                  opStatus
                                                                    ,Dcm_DiagDataContextPtrType        pDataContext
                                                                    ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                    ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                    ,Dcm_NegativeResponseCodePtrType   ErrorCode);
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrReadLengthSignal()
 *********************************************************************************************************************/
/*! \brief          Returns the length of a signal.
 *  \details        Reads the length of a specific signal of a DID.
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     pResLength         The returned length
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_PENDING      Job processing is not yet finished
 *  \return         DCM_E_OK           Job processing finished, send positive response
 *  \return         DCM_E_NOT_OK       Job processing finished, send NRC from the ErrorCode
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLengthSignal(Dcm_OpStatusType            opStatus
                                                                    ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                    ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                    ,Dcm_DidMgrDidLengthPtrType        pResLength
                                                                    ,Dcm_NegativeResponseCodePtrType   ErrorCode);

/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCondSignal()
 *********************************************************************************************************************/
/*! \brief          Reads the check condition of a specific signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK           Check condition of signal failed
 *  \return         DCM_E_PENDING      Check condition not yet finished
 *  \return         DCM_E_NOT_OK       Check condition of signal succeeded
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCondSignal(Dcm_OpStatusType        opStatus
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode);

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrGetSignalLength()
 *********************************************************************************************************************/
/*! \brief          Returns the length of the current signal.
 *  \details        -
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetSignalLength(
                                                                Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                               ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidLookUp()
 *********************************************************************************************************************/
/*! \brief          Verifies whether a supported DID is currently enabled for a specific DID operation.
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration information
 *  \param[in]      didOp              The lookup DID operation context
 *  \return         DCM_E_OK           Positive look up result
 *  \return         DCM_E_NOT_OK       Negative look up result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidLookUp(
                                                                        Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                       ,Dcm_DidMgrOpOptType             didOp);

/**********************************************************************************************************************
 *  Dcm_DidMgrConcreteDidLookUp()
 *********************************************************************************************************************/
/*! \brief          Look up for a concrete DID number (no range).
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration context
 *  \param[in]      didOp              The lookup DID operation context
 *  \return         DCM_E_OK           Positive look up result
 *  \return         DCM_E_NOT_OK       Negative look up result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrConcreteDidLookUp(
                                                                        Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                       ,Dcm_DidMgrOpOptType             didOp);

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrCheckSignalSize()
 *********************************************************************************************************************/
/*! \brief          Checks whether the DCM buffer is large enough to read the next signal.
 *  \details        -
 *  \param[in]      pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The DID configuration context
 *  \param[in,out]  pDidOpTypeContext  The DID operation context
 *  \return         TRUE               The buffer is large enough
 *  \return         FALSE              The buffer is too small
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DidMgrCheckSignalSize(Dcm_DiagDataContextConstPtrType  pDataContext
                                                                ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrReadMultiSignal()
 *********************************************************************************************************************/
/*! \brief          Reads all signals for a specific DID using the paged-buffer.
 *  \details        -
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The DID configuration context
 *  \param[in,out]  pDidOpTypeContext  The DID operation context
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadMultiSignal(Dcm_DiagDataContextPtrType pDataContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   ErrorCode);
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgRidMgrOpInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get operation descriptor.
 *  \details        -
 *  \param[in]      ridOpInfoIdx   Index to a operation descriptor of a RID operation
 *  \return         Operation descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RidMgrOpInfoPtrType, DCM_CODE) Dcm_CfgRidMgrOpInfoGetEntryOrNull(Dcm_CfgRidMgrOpHandleOptType ridOpInfoIdx);

/**********************************************************************************************************************
 *  Dcm_RidMgrExecuteRoutine()
 *********************************************************************************************************************/
/*! \brief          Executes a routine operation.
 *  \details        -
 *  \param[in]      opStatus       The operations status
 *  \param[in]      pMsgContext    Current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrExecuteRoutine(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc31RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_RidMgrGetOpInfo()
 *********************************************************************************************************************/
/*! \brief          Returns the operation descriptor of a RID operation.
 *  \details        -
 *  \param[in]      ridInfoIdx       Index to the RID info object
 *  \param[in]      ridOp            The requested RID operation
 *  \param[out]     pRidOpInfoIdx    Index to the RID operation information in the configuration table
 *  \return         DCM_E_OK         Returning descriptor is successful (pRidOpInfoIdx value shall be evaluated)
 *  \return         DCM_E_NOT_OK     Returning descriptor is not successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrGetOpInfo(Dcm_CfgRidMgrInfoHandleOptType ridInfoIdx
                                                                   ,Dcm_RidMgrOpType ridOp
                                                                   ,Dcm_CfgRidMgrOpHandlePtrType pRidOpInfoIdx);

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUp()
 *********************************************************************************************************************/
/*! \brief          Looks for the RID to get its corresponding RID information reference.
 *  \details        -
 *  \param[in]      opStatus        The operations status
 *  \param[in]      rid             The RID to be found
 *  \param[in,out]  pRidInfoIdx     Index to the RID information in the configuration table
 *  \return         DCM_E_NOT_OK    No RID has been found
 *  \return         DCM_E_OK        Look up success
 *  \return         DCM_E_PENDING   Look up result is pending, try again
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUp(Dcm_OpStatusType opStatus
                                                                   ,uint16 rid
                                                                   ,Dcm_CfgRidMgrInfoHandlePtrType pRidInfoIdx);

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUpFilter()
 *********************************************************************************************************************/
/*! \brief          Filters the RID look up result.
 *  \details        If the look-up has found a match, this filter may override this result and specify the RID as
 *                  not-supported.
 *  \param[in]      rid             The RID to be found
 *  \param[in]      ridInfoIdx      Index to the RID information
 *  \return         DCM_E_NOT_OK    No RID has been found
 *  \return         DCM_E_OK        Look up success
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUpFilter(uint16 rid
                                                                         ,Dcm_CfgRidMgrInfoHandleOptType ridInfoIdx);
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrSetNextStep()
 *********************************************************************************************************************/
/*! \brief          Set next progress step.
 *  \details        -
 *  \param[in]      NextStep         Next step to be processed by local Repeater
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ObdDtcMgrSetNextStep(Dcm_RepeaterProgressType NextStep
                                                              ,Dcm_ObdDtcManagerContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrGetNextStep()
 *********************************************************************************************************************/
/*! \brief          Get next progress step.
 *  \details        -
 *  \return         Next step to be processed by local Repeater
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RepeaterProgressType, DCM_CODE) Dcm_ObdDtcMgrGetNextStep(
                                                                          Dcm_ObdDtcManagerContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Calls the GetNumberOfFilteredDTC function.
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Stop Repeater Proxy
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemGetNumFltrdDtc(Dcm_OpStatusType opStatus
                                                                          ,Dcm_MsgContextPtrType pMsgContext                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                          ,Dcm_ObdDtcManagerContextPtrType pRepContext);

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCopyLinearData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Copies some linear data.
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCopyLinearData(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_ObdDtcManagerContextPtrType pRepContext);
# endif
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_DiagSetNewReqBaseToCurProgress()
 *********************************************************************************************************************/
/*! \brief          Sets the request context base to the current progress.
 *  \details        Updates all request related members to an initial value, starting with buffer that skips the already
 *                  consumed request bytes.
 *  \param[in,out]  pMsgContext   Current message context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewReqBaseToCurProgress(Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_DiagSetQueuedTranspObj()
 *********************************************************************************************************************/
/*! \brief          Setter of the transport object carrying the diagnostic request to be processed at next.
 *                  Dcm_DiagTaskWorker() activation
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM external/internal connection
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetQueuedTranspObj(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_DiagSetNewResBaseToCurProgress()
 *********************************************************************************************************************/
/*! \brief          Sets the response context base to the current progress.
 *  \details        Updates all response related members to an initial value, starting with buffer that skips the already
 *                  provided response bytes.
 *  \param[in,out]  pMsgContext   Current message context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewResBaseToCurProgress(Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessorFunc()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to a post-processor function of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a post-processor function
 *  \return         Post-handler
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcConfirmationFuncType, DCM_CODE) Dcm_DiagGetPostProcessorFunc(uint8_least index);

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetUpdateFunc()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to an update function of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to an update function
 *  \return         Paged-buffer update-handler
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcUpdateFuncType, DCM_CODE) Dcm_DiagGetUpdateFunc(uint8_least index);
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetCancelFunc()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to a cancellation function of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a cancellation function
 *  \return         Paged-buffer cancel-handler
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcCancelFuncType, DCM_CODE) Dcm_DiagGetCancelFunc(uint8_least index);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagInit()
 *********************************************************************************************************************/
/*! \brief          Initializes DCM diagnostic sub-module.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts must be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInit(void);

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagPutStartUpFblResBuffer()
 *********************************************************************************************************************/
/*! \brief          Writes into the global start up FBL response buffer.
 *  \details        -
 *  \param[in]      index         Index to the start up FBL response buffer
 *  \param[in]      value         New value of the start up FBL response buffer
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagPutStartUpFblResBuffer(uint8_least index, Dcm_MsgItemType value);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagAcceptNewRequest()
 *********************************************************************************************************************/
/*! \brief          Checks whether a new request will be accepted.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM USDT connection
 *  \return         TRUE          New request is accepted
 *  \return         FALSE         New request is not accepted
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagAcceptNewRequest(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_DiagOnTxFinished()
 *********************************************************************************************************************/
/*! \brief          Notifies the diagnostic sub-module that an ongoing transmission just finished.
 *  \details        Called by the TP once an ongoing transmission is finished.
 *  \param[in]      pTranspObj    Currently active DCM USDT connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagOnTxFinished(Dcm_NetTransportObjectPtrType pTranspObj
                                                          ,Dcm_NetTransmissionResultType txStatus);

#if(DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagExecConfirmationFunc()
 *********************************************************************************************************************/
/*! \brief          Executes a confirmation callback and evaluates its return values.
 *  \details        -
 *  \param[in]      notifList     The diagnostic request confirmation list to be executed
 *  \param[in]      confStatus    The post-processing status
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The last element of the passed notifList must be marked by NULL_PTR.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagExecConfirmationFunc(Dcm_CfgDiagNotificationInfoPtrType notifList
                                                                  ,Dcm_ConfirmationStatusType confStatus);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessResult()
 *********************************************************************************************************************/
/*! \brief          Calculates the Dcm_ConfirmationType value for the post processors.
 *  \details        -
 *  \return         The confirmation status
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_ConfirmationStatusType, DCM_CODE) Dcm_DiagGetPostProcessResult(void);

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoverySignature()
 *********************************************************************************************************************/
/*! \brief          Composes the recovery information control check-sum signature.
 *  \details        -
 *  \return         The control checksum
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_DiagGetRecoverySignature(void);
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagProvideRecoveryStates()
 *********************************************************************************************************************/
/*! \brief          Takes the restored DCM state over.
 *  \details        Takes the external stored and recovered DCM state over.
 *  \param[in,out]  RecoveryInfo    Reference to structure that stores recovery info
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagProvideRecoveryStates(
                                                   P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo);
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagProcessRecoveryInfo()
 *********************************************************************************************************************/
/*! \brief          Takes the restored DCM state over.
 *  \details        Takes the external stored and recovered DCM state over.
 *  \param[in,out]  RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      opStatus        Current operation status
 *  \context        TASK
 *  \return         DCM_E_OK        Processing succeeded
 *  \return         DCM_E_PENDING   Disable DTC API call is pending
 *  \return         DCM_E_NOT_OK    Disable DTC API call failed
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagProcessRecoveryInfo(
                                                P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo
                                               ,Dcm_OpStatusType opStatus);
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagSafeProcessRecoveryInfo()
 *********************************************************************************************************************/
/*! \brief          Checks and takes the restored DCM state over.
 *  \details        Checks and takes the external stored and recovered DCM state over.
 *  \param[in,out]  RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      opStatus        Current operation status
 *  \context        TASK
 *  \return         DCM_E_OK        Processing succeeded
 *  \return         DCM_E_PENDING   Disable DTC API call is pending
 *  \return         DCM_E_NOT_OK    Processing failed
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSafeProcessRecoveryInfo(
                                                 P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo
                                                ,Dcm_OpStatusType opStatus);
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcCancelOpenJobs()
 *********************************************************************************************************************/
/*! \brief          Cancel open diagnostic jobs.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcCancelOpenJobs(void);
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcReviveKilledTasks()
 *********************************************************************************************************************/
/*! \brief          Revive tasks that were killed during cancellation.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcReviveKilledTasks(void);
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcessing()
 *********************************************************************************************************************/
/*! \brief          Performs diagnostic job cancellation.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerDoCancelProcessing(Dcm_TskTaskEvOptType ev
                                                                                      ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoPostProcessing()
 *********************************************************************************************************************/
/*! \brief          Performs post processing of currently finished request.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoPostProcessing(void);

/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetDefSessionExtern()
 *********************************************************************************************************************/
/*! \brief          Performs session transition to the default session on external request.
 *  \details        Synchronizes an external session change request with the internal DCM state. If a diagnostic job is
 *                  still in processing, the session change request will be postponed till the job is finished. This is
 *                  required in order to guarantee clean sequence flow on session change and active diagnostic jobs.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerSetDefSessionExtern(Dcm_TskTaskEvOptType ev
                                                                                       ,Dcm_TskTaskEvPtrType pPostEv);

/**********************************************************************************************************************
 *  Dcm_DiagSwitchProcessingContext()
 *********************************************************************************************************************/
/*! \brief          Performs a context switch of the current working serivice processing set.
 *  \details        -
 *  \context        TASK
 *  \return         DCM_E_OK                Initialization succeeded, proceed with next step
 *  \return         DCM_E_NOT_OK            Initialization failed, repeat again next time
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSwitchProcessingContext(void);

/**********************************************************************************************************************
 *  Dcm_DiagInitiateServiceProcessing()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic kernel for new request processing.
 *  \details        -
 *  \param[in,out]  pMsgContext             Current request context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *  \note           The parameter pMsgContext is passed to this function for initialization.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInitiateServiceProcessing(Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_DiagHandleSuppressBit()
 *********************************************************************************************************************/
/*! \brief          Handles the SPRMIB if set and supported by the requested service.
 *  \details        -
 *  \param[in]      pTranspObj     The transport object
 *  \param[in,out]  pMsgContext    Current request context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleSuppressBit(Dcm_NetTransportObjectPtrType pTranspObj
                                                               ,Dcm_MsgContextPtrType         pMsgContext);

/**********************************************************************************************************************
*  Dcm_DiagHandleDispatching()
*********************************************************************************************************************/
/*! \brief          Handles the service dispatching.
*  \details        -
*  \param[in]      sid            The SID of the request
*  \param[in,out]  pMsgContext    Current request context
*  \context        TASK
*  \reentrant      FALSE
*  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleDispatching(uint8                 sid
                                                               ,Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_DiagValidateAndDispatchService()
 *********************************************************************************************************************/
/*! \brief          Validates received SID and dispatches further processing.
 *  \details        -
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The error code to be returned
 *  \return         DCM_E_OK                Validation succeeded. Initiate recognized service processing
 *  \return         DCM_E_NOT_OK            Validation failed. Finish service processing with the ErrorCode result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Dcm_DiagInitiateServiceProcessing() shall be called first.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagValidateAndDispatchService(
                                                                           Dcm_MsgContextPtrType           pMsgContext
                                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode);

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessNewRequest()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic service processing once a new request is received.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerProcessNewRequest(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pPostEv);

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessRcrRpTxEnd()
 *********************************************************************************************************************/
/*! \brief          Prepares for application notification after enforced RCR-RP transmission.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerProcessRcrRpTxEnd(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pPostEv);

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON) && \
    (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerCancelOperation()
 *********************************************************************************************************************/
/*! \brief          Cancels any ongoing diagnostic operation.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerCancelOperation(Dcm_TskTaskEvOptType ev
                                                                                   ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoRepeat()
 *********************************************************************************************************************/
/*! \brief          Triggers a scheduled diagnostic job activity.
 *  \details        Each registered diagnostic job activity will be called out from this point.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerDoRepeat(Dcm_TskTaskEvOptType ev
                                                                            ,Dcm_TskTaskEvPtrType pPostEv);

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoGetProgCond()
 *********************************************************************************************************************/
/*! \brief          Gets the programming conditions from FBL/Application.
 *  \details        Checks and takes the external stored and recovered DCM state over.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskFblRes task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskFblRes task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskFblRes task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoGetProgCond(Dcm_TskTaskEvOptType ev
                                                                                 ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoWaitTxComm()
 *********************************************************************************************************************/
/*! \brief          Waits until the ComM has processed the DCM communication request.
 *  \details        Waits for either P2Star timeout of ComM acknowledge of channel wake up.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskFblRes task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskFblRes task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskFblRes task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoWaitTxComm(Dcm_TskTaskEvOptType ev
                                                                                ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoResetFlags()
 *********************************************************************************************************************/
/*! \brief          Resets all FBL flags.
 *  \details        Resets all FBL related flags so at next power-on/reset no final response to be sent.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskFblRes task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskFblRes task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskFblRes task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoResetFlags(Dcm_TskTaskEvOptType ev
                                                                                ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoProcessTxConfirmation()
 *********************************************************************************************************************/
/*! \brief          Performs a session transition after a final positive response.
 *  \details        If the final response was for SID 0x10, the corresponding session transition is performed here.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskFblRes task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskFblRes task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskFblRes task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoProcessTxConfirmation(Dcm_TskTaskEvOptType ev
                                                                                           ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagTxPostponeFinalPagedResponse()
 *********************************************************************************************************************/
/*! \brief          Postpones the diagnostic service final response transmission if paged-buffer used.
 *  \details        The postponing is required only if the SPRMIB was set. Since the SPMRIB=TRUE means
 *                  "execute job, but do not send a response", in the case of paged-buffer the response is sent during
 *                  the "job execution". So if the P2 time is exceeded while performing the job, the final response may
 *                  not be able to provide all of the response data (the previous data pages are already lost)
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskTx task.
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagTxPostponeFinalPagedResponse(
                                                                                   Dcm_TskTaskEvOptType ev
                                                                                  ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTxStartFinalResponse()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic service final response transmission.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskTx task.
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagTxStartFinalResponse(Dcm_TskTaskEvOptType ev
                                                                                  ,Dcm_TskTaskEvPtrType pPostEv);

/**********************************************************************************************************************
 *  Dcm_DiagTxStartRcrRpResponse()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic service RCR-RP response transmission.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxStartRcrRpResponse(void);

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoveryInfoComMChannelState()
*********************************************************************************************************************/
/*! \brief          Returns a pointer to a ComM channel state of the recovery info.
 *  \details        -
 *  \param[in]      RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      index           Index to a ComM channel state
 *  \return         A valid pointer to a ComM channel state
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RecoveryInfoComMChannelStatePtrType, DCM_CODE) Dcm_DiagGetRecoveryInfoComMChannelState(
                                                  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo
                                                 ,Dcm_CfgNetNetIdRefOptType index);
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON && DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoveryInfoCommControlState()
*********************************************************************************************************************/
/*! \brief          Returns a pointer to the communication state of a ComM channel of the recovery info.
 *  \details        -
 *  \param[in]      RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      index           Index to the communication state of a ComM channel
 *  \return         A valid pointer to the communication state of a ComM channel
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RecoveryInfoCommControlStatePtrType, DCM_CODE) Dcm_DiagGetRecoveryInfoCommControlState(
                                                  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo
                                                 ,Dcm_CfgNetNetIdRefOptType index);
#endif
#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initialization of variant manager sub-module.
 *  \param[in]      configPtr    Pointer to a concrete configuration root
 *  \return         TRUE         Configuration root pointer is valid
 *  \return         FALSE        Configuration root pointer is invalid
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_VarMgrInit(Dcm_ConfigPtrType configPtr);
#endif

#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON) && \
    (DCM_DEV_RAM_SHREDDER_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF tf xf */
/**********************************************************************************************************************
 *  Dcm_VarMgrRamShredder()
 *********************************************************************************************************************/
/*! \brief          Destroys default global memory content by a pattern for test purposes.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrRamShredder(void);
#else
# define Dcm_VarMgrRamShredder()                                     /* not used */
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrInitActiveCfgVariants()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initialization of variant manager ActiveCfgVariants global variable.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrInitActiveCfgVariants(void);
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrVsgSetSingle()
 *********************************************************************************************************************/
/*! \brief          Sets the status of a single VSG.
 *  \details        -
 *  \param[in]      VsgId         Unique handle of the VSG.
 *  \param[in]      State         DCM_VSG_ENABLED:  Set VSG to active
 *                                DCM_VSG_DISABLED: Set VSG to inactive
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrVsgSetSingle(Dcm_VsgIdentifierType VsgId, Dcm_VsgStateType State);
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrVsgIsActive()
 *********************************************************************************************************************/
/*! \brief          Returns status of a single VSG.
 *  \details        -
 *  \param[in]      VsgId         Unique handle of the VSG.
 *  \param[out]     State         DCM_VSG_ENABLED:  VSG is active
 *                                DCM_VSG_DISABLED: VSG is inactive
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrVsgIsActive(Dcm_VsgIdentifierType VsgId
                                                           ,P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State);
#endif
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc01ServiceInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get service info descriptor.
 *  \details        -
 *  \param[in]      index      Index to a service info descriptor
 *  \return         Service info descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc01ServiceInfoPtrType, DCM_CODE) Dcm_CfgSvc01ServiceInfoGetEntryOrNull(
                                                                                                    uint8_least index);

/**********************************************************************************************************************
 *  Dcm_Svc01Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x01 Handler.
 *  \details        -
 *  \param[in]      opStatus        The operations status
 *  \param[in,out]  pMsgContext     Current message context
 *  \param[out]     ErrorCode       The NRC
 *  \param[in,out]  pRepContext     Current repeater proxy context
 *  \return         DCM_E_NOT_OK    Send negative response
 *  \return         DCM_E_LOOP      Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc01Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc01RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc01_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x01 worker.
 *  \details        -
 *  \param[in]      opStatus         The operations status
 *  \param[in]      pMsgContext      Current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \return         DCM_E_OK         Send response
 *  \return         DCM_E_NOT_OK     Send negative response
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc01_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc01RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_Svc02Handler()
*********************************************************************************************************************/
/*! \brief          Service 0x02 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc02Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc02RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc02_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x02 worker.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send positive response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc02_XX_RepeaterProxy(
                                                                     Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc02RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc02ReadPidData()
 *********************************************************************************************************************/
/*! \brief          Reads a single valid PID data.
 *  \details        -
 *  \param[in]      pid          The PID which data shall be read
 *  \param[in,out]  pMsgContext  The message context
 *  \param[in,out]  pRepContext  Current repeater proxy context
 *  \return         DCM_E_OK        Send positive response
 *  \return         DCM_E_NOT_OK    Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc02ReadPidData(uint8 pid
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_Svc02RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_Svc03Handler()
*********************************************************************************************************************/
/*! \brief          Service 0x03 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc03Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_ObdDtcManagerContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc03UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*! \brief          Wrapper function for Dem_SetDTCFilter API.
 *  \details        Sets the DTC filter using the respective DEM API.
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc03UtiDemSetDTCFilter(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext);
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc04Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x04 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                ,Dcm_Svc04RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x04 worker.
 *  \details        Calls the ClearDTC function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy(Dcm_OpStatusType                opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc04RepeaterProxyContextPtrType pRepContext);

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy_SelectDTC()
 *********************************************************************************************************************/
/*! \brief          Service 0x04 worker.
 *  \details        Calls the SelectDTC function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy_SelectDTC(Dcm_OpStatusType      opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc04RepeaterProxyContextPtrType pRepContext);
# endif
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_Svc06Handler()
*********************************************************************************************************************/
/*! \brief          Service 0x06 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc06RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
*  Dcm_Svc06_XX_RepeaterProxy()
*********************************************************************************************************************/
/*! \brief          Service 0x06 worker.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send positive response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc06RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Service06ProcessSupportedMidRequest()
 *********************************************************************************************************************/
/*! \brief          Check and process if every MID in request is an availability MID (0x00, 0x20, 0x40...).
 *  \details        -
 *  \param[in,out]  pMsgContext             The current request context
 *  \param[out]     ErrorCode               Negative response code
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service06ProcessSupportedMidRequest
                                                                           (Dcm_MsgContextPtrType pMsgContext
                                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode);

/**********************************************************************************************************************
 *  Dcm_Service06Process_SupportedMids()
 *********************************************************************************************************************/
/*! \brief          Reading supported MIDs.
 *  \details        -
 *  \param[in,out]  pMsgContext             The current request context
 *  \param[out]     ErrorCode               Negative response code
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service06Process_SupportedMids(Dcm_MsgContextPtrType pMsgContext
                                                                         ,Dcm_NegativeResponseCodePtrType ErrorCode);
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc06MidTidInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get Mid Tid info descriptor.
 *  \details        -
 *  \param[in]      index      Index to a service info descriptor
 *  \return         Service info descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc06MidTidInfoPtrType, DCM_CODE) Dcm_CfgSvc06MidTidInfoGetEntryOrNull(uint8_least index);

/**********************************************************************************************************************
 *  Dcm_Svc06Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x06 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc06RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc06_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x06 worker.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc06RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_Svc07Handler()
*********************************************************************************************************************/
/*! \brief          Service 0x07 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc07Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_ObdDtcManagerContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc07UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*! \brief          Wrapper function for Dem_SetDTCFilter API.
 *  \details        Sets the DTC filter using the respective DEM API.
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc07UtiDemSetDTCFilter(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext);
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc08ServiceInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Returns a service info element of the given index.
 *  \details        -
 *  \param[in]      index  The service info element index
 *  \return         Service info element
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc08ServiceInfoPtrType, DCM_CODE) Dcm_CfgSvc08ServiceInfoGetEntryOrNull(
                                                                                                  uint8_least index);

/**********************************************************************************************************************
 *  Dcm_Svc08Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x08 Handler.
 *  \details        -
 *  \param[in]      opStatus        The operations status
 *  \param[in,out]  pMsgContext     Current message context
 *  \param[out]     ErrorCode       The NRC
 *  \param[in,out]  pRepContext     Current repeater proxy context
 *  \return         DCM_E_NOT_OK    Send negative response
 *  \return         DCM_E_LOOP      Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc08Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc08RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc08_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x08 worker.
 *  \details        -
 *  \param[in]      opStatus         The operations status
 *  \param[in]      pMsgContext      Current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \return         DCM_E_OK         Send response
 *  \return         DCM_E_NOT_OK     Send negative response
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc08_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc08RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc09ServiceInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get service info descriptor.
 *  \details        -
 *  \param[in]      index      Index to a service info descriptor
 *  \return         Service info descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc09ServiceInfoPtrType, DCM_CODE) Dcm_CfgSvc09ServiceInfoGetEntryOrNull(
                                                                                                    uint8_least index);

/**********************************************************************************************************************
 *  Dcm_Svc09Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x09 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc09RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc09_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x09 worker.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc09RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_Svc0AHandler()
*********************************************************************************************************************/
/*! \brief          Service 0x0A Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc0AHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_ObdDtcManagerContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc0AUtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*! \brief          Wrapper function for Dem_SetDTCFilter API.
 *  \details        Sets the DTC filter using the respective DEM API.
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc0AUtiDemSetDTCFilter(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext);
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForResetAck()
 *********************************************************************************************************************/
/*! \brief          Wait for Ecu Reset acknowledgment.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_FORCE_RCRRP       Enforce a RCR-RP transmission
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForResetAck(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
#  if (DCM_DIAG_RCRRP_ON_BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForRcrRpAck()
 *********************************************************************************************************************/
/*! \brief          Wait for RCR-RP acknowledgment.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForRcrRpAck(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext);
#  endif
# endif

# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_SetProgConditions()
 *********************************************************************************************************************/
/*! \brief          Sets programming conditions.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Trigger to stop repeater (programming conditions set)
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_SetProgConditions(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc10Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x10 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send final positive response
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_NOT_OK            Operation failed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc11SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc11SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc11SubFuncInfoGetEntryOrNull(
                                                                              Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_Svc11Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc11SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 SubFunction Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11SubFuncHandler(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext);

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_EcuRst_WaitForAck()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 repeater.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_EcuRst_WaitForAck(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_RapPwrDwn_WaitForAck()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 repeater.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_RapPwrDwn_WaitForAck(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext);
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x14 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x14 worker.
 *  \details        Calls the ClearDTC function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send positive response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxy(Dcm_OpStatusType               opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext);

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxySelectDTC()
 *********************************************************************************************************************/
/*! \brief          Service 0x14 worker.
 *  \details        Calls the SelectDTC function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxySelectDTC(
                                                                      Dcm_OpStatusType                     opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext);                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
# endif

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult()
 *********************************************************************************************************************/
/*! \brief          Service 0x14 worker.
 *  \details        Calls the GetDTCSelectionResult function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult(
                                                                      Dcm_OpStatusType                     opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext);                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
# endif
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc19SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Gets a subfunction descriptor for service 0x19.
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc19SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc19SubFuncInfoGetEntryOrNull(
                                                                              Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_Svc19Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x19 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc19SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x19 SubFunction Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19SubFuncHandler(Dcm_OpStatusType                 opStatus
                                                                   ,Dcm_MsgContextPtrType                pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                   ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectDTC()
 *********************************************************************************************************************/
/*! \brief          Wrapper function for Dem_SelectDTC API.
 *  \details        Performs the DTC selection using the respective DEM API.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Selection API never fails
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectDTC(Dcm_OpStatusType                  opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_SETDTCFILTER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*! \brief          Wrapper function for Dem_SetDTCFilter API.
 *  \details        Sets the DTC filter using the respective DEM API.
 *  \param[out]     ErrorCode               The NRC
 *  \param[in]      DsfClass                DEM SetFilter class type
 *  \param[in]      DtcStatusMask           DTC status mask
 *  \param[in]      DtcSeverityMask         DTC severity mask
 *  \param[in]      FilterForFDC            Filter for fault detection counter
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Filter successully set
 *  \return         DCM_E_OK                Setting filter failed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSetDTCFilter(
                                                                   Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                  ,Dcm_Svc19DemSetFilterClassType       DsfClass
                                                                  ,uint8                                DtcStatusMask
                                                                  ,Dem_DTCSeverityType                  DtcSeverityMask
                                                                  ,Dcm_DemFilterForFDCType              FilterForFDC
                                                                  ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);

# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Sv19UtiStartReporting()
 *********************************************************************************************************************/
/*! \brief          Dispatches the current update job to the corresponding sub-updater function.
 *  \details        This is shared utility function of the Repeater and PagedBuffer.
 *  \param[in]      subUpdater      The reporting engine to be invoked
 *  \param[in]      reportSize      Calculated report size (used only for paged buffer)
 *  \param[in,out]  pRepContext     Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Let the page-buffer do the job
 *  \return         DCM_E_OK                Send response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Sv19UtiStartReporting(uint8                           subUpdater
                                                                    ,Dcm_MsgLenType                       reportSize
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_ABSTRACT_RECORD_ITER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Sv19UtiRecordIterNext()
 *********************************************************************************************************************/
/*! \brief          Returns the next DTC record or end of iteration result.
 *  \details        -
 *  \param[in,out]  pRepContext     Current repeater proxy context
 *  \return         DCM_SVC19_UTI_REC_ITER_RSLT_OK                Next record has been found
 *  \return         DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS   End of iteration (record ID shall not be evaluated from now on)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            A non-empty list of records has to be passed to this utility
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc19UtiRecordIterResultType, DCM_CODE) Dcm_Svc19UtiRecordIterNext(
                                                                     Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19UtiCopyData()
 *********************************************************************************************************************/
/*! \brief          Dispatches the current update job to the corresponding sub-updater function.
 *  \details        This is shared utility function of the Repeater and PagedBuffer.
 *  \param[in,out]  pDataContext    Pointer to the data context
 *  \param[out]     ErrorCode       The NRC
 *  \param[in,out]  pRepContext     Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_NOT_OK                Error occured
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service19UtiCopyData(Dcm_DiagDataContextPtrType       pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCopyLinearData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Utility to copy linear data.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCopyLinearData(Dcm_OpStatusType               opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemDisableRecordUpdate()
 *********************************************************************************************************************/
/*! \brief          Disables the update of records of a particular DTC.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemDisableRecordUpdate(Dcm_OpStatusType       opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetStatusOfDtc()
 *********************************************************************************************************************/
/*! \brief          Reads the DTC status bits.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetStatusOfDtc(Dcm_OpStatusType            opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfFFRecord()
 *********************************************************************************************************************/
/*! \brief          Calculates the size of one or multiple freeze-frame data record(s).
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Let the page-buffer do the job
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfFFRecord(Dcm_OpStatusType         opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEM_API_SELECT_EDR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectExtRecord()
 *********************************************************************************************************************/
/*! \brief          Selects the extended data record(s).
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Let the page-buffer do the job
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectExtRecord(Dcm_OpStatusType           opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfExtRecord()
 *********************************************************************************************************************/
/*! \brief          Calculates the size of one or multiple extended data record(s).
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Let the page-buffer do the job
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfExtRecord(Dcm_OpStatusType        opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          Retrieves the number of filtered DTCs.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNumFltrdDtc(Dcm_OpStatusType            opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          Initiates reading filtered DTCs severity.
 *  \details        Depending of enabled/disabled paged buffer, starts corresponding reporting process.
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER       Stop polling
 *  \return         DCM_E_LOOP                Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdSeverity(Dcm_OpStatusType       opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSeverityOfDtc()
 *********************************************************************************************************************/
/*! \brief          Reads the next filtered DTCs severity.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSeverityOfDtc(Dcm_OpStatusType          opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetFuncUnitOfDtc()
 *********************************************************************************************************************/
/*! \brief          Reads the functional unit of the requested DTC.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetFuncUnitOfDtc(Dcm_OpStatusType          opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);

# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          Read the next filtered DTC and its status mask.
 *  \details        -
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \return         DCM_E_NOT_OK                Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdDtc(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEM_API_SELECT_FFR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectFFData()
 *********************************************************************************************************************/
/*! \brief          Selects a freeze-frame data record.
 *  \details        -
 *  \param[in,out]  pRepContext           Current repeater proxy context
 *  \return         DCM_E_LOOP            Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectFFData(
                                                                      Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetFFRecord()
 *********************************************************************************************************************/
/*! \brief          Read the next DTCs freeze-frame data record.
 *  \details        -
 *  \param[in,out]  pDataContext          Pointer to the data context
 *  \param[out]     ErrorCode             The NRC
 *  \param[in,out]  pRepContext           Current repeater proxy context
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available space any more
 *  \return         DCM_E_NOT_OK          Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetFFRecord(Dcm_DiagDataContextPtrType  pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*! \brief          Initiates reading filtered DTCs FDC.
 *  \details        Depending of enabled/disabled paged buffer, starts corresponding reporting process.
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER       Stop polling
 *  \return         DCM_E_LOOP                Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdFDC(Dcm_OpStatusType            opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          Initiates reading filtered DTCs status mask.
 *  \details        Depending of enabled/disabled paged buffer, starts corresponding reporting process.
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Stop polling
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          Initiates reading filtered DTCs status mask.
 *  \details        Depending of enabled/disabled paged buffer, starts corresponding reporting process.
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER       All data copied
 *  \return         DCM_E_LOOP                Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdDtc(Dcm_OpStatusType            opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiPutNumFilteredDtc()
 *********************************************************************************************************************/
/*! \brief          Write caclucalted by DEM number of filtered DTCs into the response buffer.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                This value is always returned
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiPutNumFilteredDtc(Dcm_OpStatusType           opStatus
                                                                   ,Dcm_MsgContextPtrType                pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                   ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Calls the GetNextFilteredDTCAndSeverity function.
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Calls the GetNextFilteredDTCAndSeverity function.
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \return         DCM_E_NOT_OK                Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdRecord()
 *********************************************************************************************************************/
/*! \brief          Read the next filtered DTC and its record number.
 *  \details        -
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \return         DCM_E_NOT_OK                Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdRecord(
                                                                    Dcm_DiagDataContextPtrType           pDataContext
                                                                   ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                   ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetExtRecord()
 *********************************************************************************************************************/
/*! \brief          Read the next DTCs extended data record.
 *  \details        -
 *  \param[in,out]  pDataContext          Pointer to the data context
 *  \param[out]     ErrorCode             The NRC
 *  \param[in,out]  pRepContext           Current repeater proxy context
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available space any more
 *  \return         DCM_E_NOT_OK          Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetExtRecord(Dcm_DiagDataContextPtrType pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22GetDidInfoContext()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to a DidInfoContext of the index given by the repeater proxy context.
 *  \details        -
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         A valid pointer to a DidInfoContext
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrDidInfoContextPtrType, DCM_CODE) Dcm_Svc22GetDidInfoContext(
                                                                     Dcm_Svc22RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc22Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x22 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc22ReadDid()
 *********************************************************************************************************************/
/*! \brief          Reads a single paged DID for service 0x22.
 *  \details        -
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pDataContext            The pointer to the data context
 *  \param[in,out]  pDidInfoContext         The DID configuration context
 *  \param[in,out]  pDidOpTypeContext       The DID configuration operation context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK                All data has been copied
 *  \return         DCM_E_PENDING           No result yet, retry later
 *  \return         DCM_E_BUFFERTOOLOW      Some data copied but no place, retry later on TP buffer under-run
 *  \return         DCM_E_FORCE_RCRRP       Enforce a RCR-RP transmission
 *  \return         DCM_E_NOT_OK            The DID reading has failed for some reason. NRC is already set.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadDid(Dcm_OpStatusType                  opStatus
                                                                ,Dcm_DiagDataContextPtrType        pDataContext
                                                                ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                ,Dcm_NegativeResponseCodePtrType   ErrorCode);

/**********************************************************************************************************************
 *  Dcm_Svc22UtiReadData()
 *********************************************************************************************************************/
/*! \brief          Reads the requested DIDs for service 0x22.
 *  \details        This is shared utility function of the Repeater and PagedBuffer.
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  pDataContext            Pointer to the data context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Service 0x22 repeater context
 *  \return         DCM_E_OK                All data has been copied
 *  \return         DCM_E_PENDING           No result yet, retry later
 *  \return         DCM_E_BUFFERTOOLOW      Some data copied but no place, retry later on TP buffer under-run
 *  \return         DCM_E_FORCE_RCRRP       Enforce a RCR-RP transmission
 *  \return         DCM_E_NOT_OK            The DID reading has failed for some reason. NRC is already set.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22UtiReadData(Dcm_OpStatusType                     opStatus
                                                                    ,Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc22DidLookUp()
 *********************************************************************************************************************/
/*! \brief          A generic DID look-up for SID 0x22.
 *  \details        Performs a lookup for a specific DID on any request.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22DidLookUp(Dcm_OpStatusType                     opStatus
                                                                  ,Dcm_MsgContextPtrType                pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                  ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc22CheckCondition()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Checks the conditions of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckCondition(Dcm_OpStatusType                  opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc22GetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Reads the length of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22GetLength(Dcm_OpStatusType                     opStatus
                                                                  ,Dcm_MsgContextPtrType                pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                  ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc22ReadData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Reads the data of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadData(Dcm_OpStatusType                     opStatus
                                                                 ,Dcm_MsgContextPtrType                pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                 ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc23Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x23 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc23RepeaterProxyContextPtrType pRepContext);

# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc23CheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x23.
 *  \details        Checks the service 0x23 access.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23CheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc23RepeaterProxyContextPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc23ReadMemory()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x23.
 *  \details        Reads the data from the memory.
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in]      pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23ReadMemory(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc23RepeaterProxyContextConstPtrType pRepContext);
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc24Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc24RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc24ExecuteOp()
 *********************************************************************************************************************/
/*! \brief          Service 0x24 operation execution unit.
 *  \details        Executes a specific service 0x24 operation.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24ExecuteOp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc24RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc24DidLookUp()
 *********************************************************************************************************************/
/*! \brief          Service 0x24 DID look up client.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Stop polling
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24DidLookUp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc24RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc27SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc27SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc27SubFuncInfoGetEntryOrNull(
                                                                              Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_CfgSvc27SecLevelInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get security level descriptor.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \return         Security level descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc27SecLevelInfoPtrType, DCM_CODE) Dcm_CfgSvc27SecLevelInfoGetEntryOrNull(
                                                                                                   uint8_least secLev);

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27CounterSet()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific security level attempt counter.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \param[in]      value       Attempt counter value
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterSet(uint8_least secLev, uint8 value);
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27CounterInc()
 *********************************************************************************************************************/
/*! \brief          Increments the value of a specific security level attempt counter.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterInc(uint8_least secLev);
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27TimerSet()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific security level timer.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \param[in]      value       Timer value
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerSet(uint8_least secLev, Dcm_Svc27TimerType value);
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27TimerStart()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific security level timer.
 *  \details        Starts the base security level timer.
 *  \param[in]      secLev      Zero based security level index
 *  \param[in]      value       Timer value for the specific security level
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerStart(uint8_least secLev, Dcm_Svc27TimerType value);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc27SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 SubFunction Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27SubFuncHandler(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext);

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiGetAttemptCntr()
 *********************************************************************************************************************/
/*! \brief          Restores the attempt counter values from the application.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  levelMask               Pointer to a security level mask.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27UtiGetAttemptCntr(Dcm_OpStatusType opStatus
                                                                ,P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask);
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27ReadAttemptCounter()
 *********************************************************************************************************************/
/*! \brief          Manages reading of an attempt counter value.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in]      ev         The active event(s) of the Dcm_Svc27Task task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_Svc27Task task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_Svc27Task task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_Svc27ReadAttemptCounter(Dcm_TskTaskEvOptType ev
                                                                                 ,Dcm_TskTaskEvPtrType pPostEv);
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27WriteAttemptCounter()
 *********************************************************************************************************************/
/*! \brief          Manages writing of an attempt counter value.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in]      ev         The active event(s) of the Dcm_Svc27Task task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_Svc27Task task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_Svc27Task task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_Svc27WriteAttemptCounter(Dcm_TskTaskEvOptType ev
                                                                                  ,Dcm_TskTaskEvPtrType pPostEv);
# endif

/**********************************************************************************************************************
 *  Dcm_Service27SeedRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 get seed service port accessor.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SeedRepeater(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Service27KeyRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 send key service port accessor.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send neagative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27KeyRepeater(Dcm_OpStatusType opStatus
                                                                 ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext);

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27CheckAttemptsExceededRepeater()
 *********************************************************************************************************************/
/*! \brief          Checks whether the number of allowed attempts were reached.
 *  \details        Determines the final negative response code (0x35 or 0x36).
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27CheckAttemptsExceededRepeater(Dcm_OpStatusType opStatus
                                                                    ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SetAttemptCntrRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 set attempt counter service port accessor.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SetAttemptCntrRepeater(Dcm_OpStatusType opStatus
                                                                    ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext);
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc28SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc28SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc28SubFuncInfoGetEntryOrNull(
                                                                              Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_Svc28Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x28 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc28Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc28RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc28SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x28 SubFunction Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc28SubFuncHandler(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc28RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc28ApplyCommControl()
 *********************************************************************************************************************/
/*! \brief          Apply concrete operation on network channel(s).
 *  \details        -
 *  \param[in]      networkRef The network handle
 *  \param[in]      mode       The communication mode
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc28ApplyCommControl(Dcm_CfgNetNetIdRefMemType networkRef
                                                               ,Dcm_CommunicationModeType mode);
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/* --- public members ---------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Service2ASchedulerInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initializes the periodic DID scheduler.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service2ASchedulerInit(void);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdAddItemByDid()
 *********************************************************************************************************************/
/*! \brief          Inserts a new item to the scheduler without activating it.
 *  \details        -
 *  \param[in,out]  pDidInfoContext    The context of the DID
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdAddItemByDid(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCommit()
 *********************************************************************************************************************/
/*! \brief          Commits already inserted items to be scheduled with a given rate.
 *  \details        -
 *  \param[in]      rate    The scheduling rate
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdCommit(Dcm_Svc2ASchedRateMemType rate);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdDiscard()
 *********************************************************************************************************************/
/*! \brief          Discards all inserted items.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdDiscard(void);

/**********************************************************************************************************************
 *  Dcm_Svc2AOnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Stops all scheduled DIDs no more allowed by the new states.
 *  \details        Stops all scheduled DIDs that are nor more allowed after the state has been changed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2AOnStateChanged(void);

/* --- private members --------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFindFreeOrInUseItemByDid()
 *********************************************************************************************************************/
/*! \brief          Tries to find already used DID entry slot. If not, returns the last free found.
 *  \details        -
 *  \param[in]      did           The did
 *  \param[in]      schdHandle    Handle of the found slot
 *  \return         TRUE          A slot was found
 *  \return         FALSE         No slot was found - schdHandle output parameter is invalid
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdFindFreeOrInUseItemByDid(uint16 did
                                               ,P2VAR(Dcm_Svc2ASchdItemHandleOptType, AUTOMATIC, AUTOMATIC) schdHandle);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdUpdateTimers()
 *********************************************************************************************************************/
/*! \brief          Updates all active scheduled item timers.
 *  \details        -
 *  \return         TRUE     Activate processor task
 *  \return         FALSE    Don't activate processor task
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdUpdateTimers(void);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdNextEntryIdxInc()
 *********************************************************************************************************************/
/*! \brief          Scheduler item iterator increment.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdNextEntryIdxInc(void);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetEntry()
 *********************************************************************************************************************/
/*! \brief          Obtain a service 0x2A scheduler entry.
 *  \details        -
 *  \param[in]      schdHandle    The scheduler entry handle
 *  \return         Pointer to requested 2A scheduler entry - if handle is invalid, pointer to first entry
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2ASchdEntryPtrType, DCM_CODE) Dcm_Svc2ASchdGetEntry(
                                                                             Dcm_Svc2ASchdItemHandleOptType schdHandle);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdInitDidMgrResources()
 *********************************************************************************************************************/
/*! \brief          Allocate DID manager resources for PDID
 *  \details        -
 *  \param[in,out]  pDataContext    Pointer to the data context
 *  \param[in]      did             The DID that is about to be read
 *  \return         DCM_E_OK        Continue processing
 *  \return         DCM_E_PENDING   DID is currently in use by another service
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdInitDidMgrResources(Dcm_DiagDataContextPtrType pDataContext
                                                                                ,uint16 did);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdProcessEntry()
 *********************************************************************************************************************/
/*! \brief          A single PDID processing step.
 *  \details        Performs PDID reading and sending on expired PDID slots.
 *  \param[in]      pSchedTableEntry    The scheduler entry to be processed
 *  \return         DCM_E_OK        Continue processing
 *  \return         DCM_E_PENDING   Processing was postponed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdProcessEntry(Dcm_Svc2ASchdEntryPtrType pSchedTableEntry);
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AScheduledDidLookUp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Performs a lookup for a specific DID on scheduling requests.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AScheduledDidLookUp(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2AStoppedDidLookUp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Performs a lookup for a specific DID on stop DID requests.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStoppedDidLookUp(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2ADidCheckCondition()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Checks the conditions of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidCheckCondition(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2ADidGetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Returns the length of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Go on with next DID
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidGetLength(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2ADoScheduleDids()
 *********************************************************************************************************************/
/*! \brief          Updates the scheduler content.
 *  \details        -
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADoScheduleDids(Dcm_MsgContextPtrType pMsgContext
                                                                       ,Dcm_NegativeResponseCodePtrType ErrorCode);

/**********************************************************************************************************************
 *  Dcm_Svc2AStopScheduledDids()
 *********************************************************************************************************************/
/*! \brief          Stops requested DIDs.
 *  \details        -
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStopScheduledDids(Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_Svc2AHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2A Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Operation failed
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Service 0x2C DID definition manager initializer.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrInit(void);

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadSrcItems()
 *********************************************************************************************************************/
/*! \brief          Performs reading on a single DynDID source item (DID or memory area).
 *  \details        -
 *  \param[in]      opStatus      Current DynDID read operation status.
 *  \param[in,out]  pDataContext  Pointer to the data context
 *  \return         DCM_E_OK         Read of all source items finished with success.
 *  \return         DCM_E_PENDING    One of the source items needs more time to return final result, call again.
 *  \return         DCM_E_NOT_OK     One of the source items returned an error.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadSrcItems(Dcm_OpStatusType opStatus
                                                                           ,Dcm_DiagDataContextPtrType pDataContext);

/**********************************************************************************************************************
 *  Dcm_Svc2COnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Clears all no more allowed DynDIDs in the new states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2COnStateChanged(void);

/**********************************************************************************************************************
 *  Dcm_Svc2CGetSrcItem()
 *********************************************************************************************************************/
/*! \brief          Return the requested source item
 *  \details        -
 *  \param[in]      srcItemIndex    Index of the source item
 *  \return         The requested source item or any valid source item if the provided index is invalid
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidSrcItemPtrType, DCM_CODE) Dcm_Svc2CGetSrcItem(
                                                                     Dcm_CfgDidMgrDynDidSrcItemIdxOptType srcItemIndex);

/**********************************************************************************************************************
 *  Dcm_Svc2CGetItem()
 *********************************************************************************************************************/
/*! \brief          Return the requested item
 *  \details        -
 *  \param[in]      itemIndex    Index of the item
 *  \return         The requested item or any valid item if the provided index is invalid
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidItemPtrType, DCM_CODE) Dcm_Svc2CGetItem(
                                                                            Dcm_CfgDidMgrDynDidHandleOptType itemIndex);

/**********************************************************************************************************************
 *  Dcm_Svc2CGetDDDidProcessContext()
 *********************************************************************************************************************/
/*! \brief          Return the requested process context
 *  \details        -
 *  \param[in]      processContextIndex    Index of the process context
 *  \return         The process context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidProcessContextPtrType, DCM_CODE) Dcm_Svc2CGetDDDidProcessContext(
                                                                                             uint8 processContextIndex);

# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CStateCheckSrcItems()
 *********************************************************************************************************************/
/*! \brief          Check state and mode group preconditions of each source item.
 *  \details        -
 *  \param[in]      dynDidHandle    DynDID reference to be checked
 *  \param[out]     ErrorCode       The NRC
 *  \return         DCM_E_OK        Check was successful
 *  \return         DCM_E_OK        Check was not successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CStateCheckSrcItems(
                                                                           Dcm_CfgDidMgrDynDidHandleOptType dynDidHandle
                                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01DefMgrRead()
 *********************************************************************************************************************/
/*! \brief          Reads a single DID source item.
 *  \details        -
 *  \param[in]      opStatus        Current DID sourceItem operation status.
 *  \param[in,out]  pDataContext    Pointer to the data context
 *  \return         DCM_E_OK        Reading finished with success.
 *  \return         DCM_E_PENDING   Reading needs some additional time. Call again.
 *  \return         DCM_E_NOT_OK    Reading finished with failed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01DefMgrRead(Dcm_OpStatusType opStatus
                                                                     ,Dcm_DiagDataContextPtrType pDataContext);
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02DefMgrRead()
 *********************************************************************************************************************/
/*! \brief          Reads a single Memory source item.
 *  \details        -
 *  \param[in]      opStatus        Current Memory sourceItem operation status.
 *  \param[in,out]  pDataContext    Pointer to the data context
 *  \return         DCM_E_OK            Reading finished with success.
 *  \return         DCM_E_FORCE_RCRRP   Send RCR-RP response. Once sent, call again.
 *  \return         DCM_E_PENDING       Reading needs some additional time. Call again.
 *  \return         DCM_E_NOT_OK        Reading finished with failed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02DefMgrRead(Dcm_OpStatusType opStatus
                                                                     ,Dcm_DiagDataContextPtrType pDataContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadCheckAccessAndInit()
 *********************************************************************************************************************/
/*! \brief          Check read acces for requested DynDID.
 *  \details        -
 *  \param[in]      dynDidHandle    Current dynDid handle to be read.
 *  \param[in,out]  pOpStatus       Current and modified operation status.
 *  \return         DCM_E_OK            Check succeeded, proceed with read.
 *  \return         DCM_E_PENDING       The DynDID is still in usage, try later
 *  \return         DCM_E_NOT_OK        Check failed, leave the DynDID reading.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadCheckAccessAndInit(
                                                               Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                              ,P2VAR(Dcm_OpStatusType, AUTOMATIC, AUTOMATIC) pOpStatus);
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc2CSubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc2CSubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc2CSubFuncInfoGetEntryOrNull(
                                                                                Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_Svc2CHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2CSubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C SubFunction Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CSubFuncHandler(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidLookUp()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Performs a lookup for a specific source DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidLookUp(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidCheckCondition()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Checks the condition of a specific source DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidCheckCondition(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidGetLength()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Calculates and stores the length of a specific source DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidGetLength(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_02SrcItemsGetLength()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x02.
 *  \details        Calculates the total length of all source items
 *  \param[in]      alfid                   The ALFID of the request
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Calculation succeeded
 *  \return         DCM_E_NOT_OK            Error during calculation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_02SrcItemsGetLength(uint8 alfid
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Svc2C_03DidLookUp()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C 0x03 dedicated DID look up client.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[out]     pRepContext    Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_03DidLookUp(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2C_SetMaxAllowedDynDIDLength()
 *********************************************************************************************************************/
/*! \brief          Set the maximum allowed length for the currently processed DynDID.
 *  \details        -
 *  \param[in]      pRepContext    Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2C_SetMaxAllowedDynDIDLength(
                                                                      Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2EHandler()
 *********************************************************************************************************************/
/*! \brief          Handles Service 0x2E.
 *  \details        Checks if Did information is correct and either ready to write data or pending.
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2ERepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2ECheckAccess()
 *********************************************************************************************************************/
/*! \brief          Checks the service 0x2E access.
 *  \details        Tries to lock a given Did and react accordingly.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[in]      pRepContext      Current repeater proxy context
 *  \param[out]     ErrorCode        The NRC
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ECheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc2ERepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2EWriteData()
 *********************************************************************************************************************/
/*! \brief          Executes service 0x2E operation.
 *  \details        Writes the intended data and releases the lock if the operation result is not pending.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EWriteData(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc2ERepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2F Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING           Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FGetActiveIoDids()
 *********************************************************************************************************************/
/*! \brief          Return the requested active IODIDs bit mask
 *  \details        -
 *  \param[in]      ioDidIndex              Index of the IODID
 *  \return         The active IODIDs bit mask
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_UtiBitSetBasePtrType, DCM_CODE) Dcm_Svc2FGetActiveIoDids(
                                                                            Dcm_CfgDidMgrIoDidHandleOptType ioDidIndex);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FReturnControlToEcu()
 *********************************************************************************************************************/
/*! \brief          Reset all active IO controls.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FReturnControlToEcu(void);

/**********************************************************************************************************************
 *  Dcm_Svc2FOnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Reset all active IO controls no more supported in the active DCM state.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FOnStateChanged(void);

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FExtractCEMR()
 *********************************************************************************************************************/
/*! \brief          Extracts the CEMR from the request.
 *  \details        Extracts the CEMR from a byte stream into a 32bit variable. If CEMRsize > 4 -> value is 0.
 *  \param[in]      cemrStream   Points to the beginning of the CEMR in the request
 *  \param[in]      cemrSize     Specifies the CEMR total length
 *  \return         0            If the CEMR size > 4 or no bit has been set. This value is invalid and will only
 *                               be used as initialization of the CEMR, but not passed to the application for NBit CEMR.
 *  \return         >0           Extracted CEMR. Note: For 3Byte CEMR the result is MSB bound!

 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_Svc2FExtractCEMR(Dcm_ReadOnlyMsgType cemrStream
                                                            ,Dcm_CfgDidMgrIoDidCemrLengthMemType cemrSize);
# endif

# if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FProcessCEMR()
 *********************************************************************************************************************/
/*! \brief          Processes CEMR of IO DID request if the IO DID supports CEMR.
 *  \details        On IO DIDs with CEMR the CEMR will be extracted and verified for non-zero value.
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pRepContext        Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FProcessCEMR(Dcm_MsgContextPtrType pMsgContext
                                                          ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FCalculateExpectedReqLength()
 *********************************************************************************************************************/
/*! \brief          Calculates the expected request length including DID data and CEMR.
 *  \details        -
 *  \param[out]     expLengthMin        Returns the expected request minimum length.
 *  \param[out]     expLengthMax        Returns the expected request maximum length.
 *  \param[in,out]  pRepContext         Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FCalculateExpectedReqLength(Dcm_DidMgrDidLengthPtrType expLengthMin
                                                                     ,Dcm_DidMgrDidLengthPtrType expLengthMax
                                                                     ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckReqLength()
 *********************************************************************************************************************/
/*! \brief          Verifies the request length.
 *  \details        Verifies that the request length is valid for the concrete DID and IO operation incl. CEMR.
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pRepContext        Current repeater proxy context
 *  \return         DCM_E_POSITIVERESPONSE            Request length is valid.
 *  \return         !=DCM_E_POSITIVERESPONSE          A validation error has occurred.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2FCheckReqLength(Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2FIoDidOperationProcessor()
 *********************************************************************************************************************/
/*! \brief          Process a concrete IODID and its requested operation.
 *  \details        -
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[out]     pRepContext      Current repeater proxy context
 *  \return         DCM_E_NOT_OK     Send negative response
 *  \return         DCM_E_LOOP       Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FIoDidOperationProcessor(Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Checks the service 0x2F access.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in]      pRepContext      Current repeater proxy context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FCheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2FExecuteOp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Executes a specific service 0x2F operation.
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \return         Next action to perform
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FExecuteOp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);

# if (DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FGetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Reads the length of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FGetLength(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);
# endif

# if(DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FReadData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[out]     pRepContext    Current repeater proxy context
 *  \return         DCM_E_OK       Send response
 *  \return         DCM_E_NOT_OK   Send negative response
 *  \return         DCM_E_PENDING  Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FReadData(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);
# endif
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc31Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x31 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc31Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc31RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc3DHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x3D Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc3DRepeaterProxyContextPtrType pRepContext);

# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc3DCheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x3D.
 *  \details        Checks the service 0x3D access.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in]      pRepContext      Current repeater proxy context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DCheckAccess(Dcm_OpStatusType opStatus
                                                                ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc3DRepeaterProxyContextConstPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc3DWriteMemory()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x3D.
 *  \details        Writes the data to the memory.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in]      pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DWriteMemory(Dcm_OpStatusType opStatus
                                                                ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc3DRepeaterProxyContextConstPtrType pRepContext);
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc85SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc85SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc85SubFuncInfoGetEntryOrNull(
                                                                              Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_Svc85Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc85RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc86SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc86SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc86SubFuncInfoGetEntryOrNull(
                                                                              Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_Svc86Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x86 Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc86RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc86SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x86 SubFunction Handler.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86SubFuncHandler(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc86RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Module internal function declarations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrValidateAndGetAlfid()
 *********************************************************************************************************************/
/*! \brief          Validates the request memory ALFID and extracts it from request.
 *  \details        -
 *  \param[in,out]  pMsgContext        Requested memory data starting with the ALFID byte.
 *  \param[out]     pAlfid             ALFID byte
 *  \param[out]     pBlockLength       Returns the left part of the stream (i.e. without protocol header)
 *  \param[out]     ErrorCode          The NRC
 *  \return         DCM_E_OK      - no error found
 *  \return         DCM_E_NOT_OK  - invalid ALFID (NRC is set to ErrorCode)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The request data within the pMsgContext must contain an ALFID byte.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrValidateAndGetAlfid(Dcm_MsgContextPtrType pMsgContext
                                                                      ,Dcm_Uint8VarDataPtrType pAlfid
                                                                      ,Dcm_Uint8VarDataPtrType pBlockLength
                                                                      ,Dcm_NegativeResponseCodePtrType ErrorCode);

/**********************************************************************************************************************
 *  Dcm_MemMgrParseMemStream()
 *********************************************************************************************************************/
/*! \brief          Validates the request memory ALFID.
 *  \details        -
 *  \param[in]      alfid         Requested ALFID byte
 *  \param[in,out]  pMsgContext   Current message context with the memory address and size byte stream
 *  \param[out]     pMemBlock     Interpreted memory block information
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            It shall be assured that the ALFID value matches the length of the data stream to be parsed.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_MemMgrParseMemStream(uint8 alfid
                                                       ,Dcm_MsgContextPtrType pMsgContext
                                                       ,Dcm_MemMgrMemBlockPtrType pMemBlock);

/**********************************************************************************************************************
 *  Dcm_MemMgrCheckMemBlock()
 *********************************************************************************************************************/
/*! \brief          Checks a specific memory block.
 *  \details        -
 *  \param[in]      pMemBlock    The memory block descriptor for validation
 *  \param[in]      memOp        The memory block operation type
 *  \param[out]     ErrorCode    The NRC
 *  \return         Result of analysis
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrCheckMemBlock(Dcm_MemMgrMemBlockConstPtrType pMemBlock
                                                                ,Dcm_MemMgrMemoryOpType memOp
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode);

# if (DCM_MEMMGR_MEMOP_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrReadMemory()
 *********************************************************************************************************************/
/*! \brief          Executes a read memory operation.
 *  \details        -
 *  \param[in]      opStatus      Current operation status
 *  \param[in]      pMemBlock     The memory block descriptor for validation
 *  \param[in]      pDataContext  Pointer to the data context
 *  \param[out]     ErrorCode     The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrReadMemory(Dcm_OpStatusType opStatus
                                                             ,Dcm_MemMgrMemBlockConstPtrType pMemBlock
                                                             ,Dcm_DiagDataContextPtrType pDataContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif

# if (DCM_MEMMGR_MEMOP_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrWriteMemory()
 *********************************************************************************************************************/
/*! \brief          Executes a write memory operation.
 *  \details        -
 *  \param[in]      opStatus      Current operation status
 *  \param[in]      pMemBlock     The memory block descriptor for validation
 *  \param[in]      data          data buffer
 *  \param[out]     ErrorCode     The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrWriteMemory(Dcm_OpStatusType opStatus
                                                              ,Dcm_MemMgrMemBlockConstPtrType pMemBlock
                                                              ,Dcm_MsgType data
                                                              ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_22_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_SVC_31_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED   == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrIsIdEnabled()
 *********************************************************************************************************************/
/*! \brief          Returns the calibrated state of an OBD ID.
 *  \details        -
 *  \param[in]      obdId              The OBD ID to be verified.
 *  \param[in]      pMaskData    A pointer to the OBD ID availability range mask list
 *  \return         TRUE               OBD ID is still enabled
 *  \return         FALSE              OBD ID was calibrated to be disabled
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_ObdIdMgrIsIdEnabled(uint8 obdId
                                             ,P2CONST(Dcm_ObdIdMgrMaskValueTableType, AUTOMATIC, DCM_CONST) pMaskData);
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrIdLookUp()
 *********************************************************************************************************************/
/*! \brief          Look up for a given OBD ID.
 *  \details        Considers any variant handling/calibration.
 *  \param[in]      id     The OBD ID to look for
 *  \param[in,out]  pParserDesc
 *                  IN     LookUpTable
 *                  IN     LookUpFilterTable
 *                  IN     MaskData
 *                  OUT    Handle
 *  \return         DCM_E_OK        Look up was successful
 *  \return         DCM_E_NOT_OK    Look up was not successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrIdLookUp(uint8 id
                                                             ,Dcm_ObdIdMgrDescPtrType pParserDesc);

/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetAvailabilityMask()
 *********************************************************************************************************************/
/*! \brief          A utility to provide a lookup result of an OBD ID and returning the corresponding AID mask value.
 *  \details        -
 *  \param[in]      id     The OBD ID to look for
 *  \param[in,out]  pParserDesc
 *                  IN     LookUpTable
 *                  IN     LookUpFilterTable
 *                  IN     MaskData
 *                  OUT    Handle
 *  \return         The generated 32bit mask value (variant independent/calibratable)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The requested id has to be supported and to be an availability one.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(uint32, DCM_CODE) Dcm_ObdIdMgrGetAvailabilityMask(uint8 id
                                                                ,Dcm_ObdIdMgrDescPtrType pParserDesc);

# if (DCM_OBDIDMGR_REQ_PARSER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrProcessSupportedIdRequest()
 *********************************************************************************************************************/
/*! \brief          Validates and processes any OBD ID availability ID request.
 *  \details        Processes a list of IDs and in case of availability ID request writes the response data.
 *  \param[in,out]  pMsgContext               Current request context
 *  \param[in]      pParserDesc
 *                  IN     LookUpTable
 *                  IN     LookUpFilterTable
 *                  IN     MaskData
 *                  OUT    Handle
 *  \param[out]     ErrorCode                 The NRC
 *  \return         DCM_E_OK        Request processing was successful
 *  \return         DCM_E_NOT_OK    Request was not valid
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrProcessSupportedIdRequest(Dcm_MsgContextPtrType pMsgContext
                                                                              ,Dcm_ObdIdMgrDescPtrType pParserDesc
                                                                              ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_UTI_LOOKUP_U16_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_UtiLookUpUint16()
 *********************************************************************************************************************/
/*! \brief          Searches a word table for an element.
 *  \details        -
 *  \param[in]      lookUpTable    Pointer to the table to be scanned (first element is table-size!)
 *  \param[in]      value          Value to be found
 *  \return         -1             Look up failed (no match)
 *  \return         >=0            Success, index of the matched position
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            Total number of elements for look up shall be < 32768.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpUint16(P2CONST(uint16, AUTOMATIC, DCM_CONST) lookUpTable
                                                          ,uint16 value);
#endif

/**********************************************************************************************************************
 *  Dcm_UtiGetBitPosition()
 *********************************************************************************************************************/
/*! \brief          Returns the position of the most left set bit in a bit set.
 *  \details        -
 *  \param[in]      bitSet    A bit-set with only one bit set in it.
 *  \return         Returns the position of the set bit
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(uint8, DCM_CODE) Dcm_UtiGetBitPosition(uint32 bitSet);

#if (DCM_UTI_NVM_READ_ENABLED  == STD_ON) || \
    (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_UtiNvMGetErrorStatus()
 *********************************************************************************************************************/
/*! \brief          Poll the error status from the NvM.
 *  \details        -
 *  \param[in]      blockId    Id of the NvRam block
 *  \return         DCM_E_OK       Operation finished with success.
 *  \return         DCM_E_NOT_OK   Operation finished with failure.
 *  \return         DCM_E_PENDING  Operation needs more time to be accomplished.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            Shall be called only after any NvM read/write operation of the given block is triggered.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMGetErrorStatus(uint16 blockId);
#endif
/**********************************************************************************************************************
 *  Dcm_NetUnRegisterAllComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to unregister all ComM channels activities.
 *  \details        -
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterAllComMActivity(void);

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to unregister a ComM channel activity.
 *  \details        -
 *  \param[in]      connId    The connection which has finished its job
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            Must be called only for external diagnostic requests
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterComMActivity(Dcm_NetConnRefMemType connId);

/**********************************************************************************************************************
 *  Dcm_NetRegisterComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to register a ComM channel activity.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object which starts diagnostic job
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetRegisterComMActivity(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_NetUsdtTxConfirmation()
 *********************************************************************************************************************/
/*! \brief          Transport object transmission finalization.
 *  \details        Finalization of a transmitted USDT message.
 *  \param[in]      pTranspObj    The transport object used during transmission
 *  \param[in]      result        The transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUsdtTxConfirmation(Dcm_NetTransportObjectPtrType pTranspObj
                                                        ,Dcm_NetTransmissionResultType result);

/**********************************************************************************************************************
 *  Dcm_NetAllocateOrGetTranspObjectOrNull()
 *********************************************************************************************************************/
/*! \brief          Transport object allocation.
 *  \details        Allocates a transport object for a concrete client connection.
 *  \param[in]      connId        The connection identifier
 *  \return         Allocated transport object
 *  \return         NULL_PTR      On invalid connection identifier (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Must be called within a critical section to guarantee unique result
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetAllocateOrGetTranspObjectOrNull(Dcm_NetConnRefOptType connId);

/**********************************************************************************************************************
 *  Dcm_NetGetTranspObjOfConnectionOrNull()
 *********************************************************************************************************************/
/*! \brief          Returns the transport object of the given connection.
 *  \details        -
 *  \param[in]      connId    The connection identifier
 *  \return         The transport object assigned to the given connection
 *  \return         NULL_PTR if no transport object is assigned to the given connection
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            Since only getter, can be called outside of a critical section, but for consistent results do call within critical section
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetConnRefOptType connId);

/**********************************************************************************************************************
 *  Dcm_NetTranspObjRelease()
 *********************************************************************************************************************/
/*! \brief          Release transport object resource.
 *  \details        Releases a given transport object.
 *  \param[in]      pTranspObj    The transport object to be released
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTranspObjRelease(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_NetGetConnIdByTesterAddress()
 *********************************************************************************************************************/
/*! \brief          Tries to find the corresponding connection of a diagnostic client.
 *  \details        -
 *  \param[in]      testerAddress    The diagnostic client address to look for
 *  \return         < DCM_NET_INVALID_CONNID    Valid connection id found.
 *  \return         DCM_NET_INVALID_CONNID      No connection found for the source address.
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnIdByTesterAddress(uint16 testerAddress);

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterActiveConnection()
 *********************************************************************************************************************/
/*! \brief          Unregister a connection.
 *  \details        Unregister an active connection referenced by the given transport object.
 *  \param[in]      pTranspObj    The transport object to be released
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterActiveConnection(Dcm_NetTransportObjectPtrType pTranspObj);

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
/*! \brief          Periodic message allocation.
 *  \details        Allocates a resource for a periodic message.
 *  \param[in]      Did     DID of the message that is allocated
 *  \return         DCM_NET_INVALID_PTXOBJ_HANDLE      No free resource found
 *  \return         < DCM_NET_INVALID_PTXOBJ_HANDLE    A concrete valid handle is returned
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_CfgNetPTxObjHandleMemType, DCM_CODE) Dcm_NetPeriodicMsgAllocate(uint16 Did);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgRelease()
 *********************************************************************************************************************/
/*! \brief          Releases a concrete periodic message resource.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgRelease(Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmit()
 *********************************************************************************************************************/
/*! \brief          Transmits a periodic message.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \param[in]      length            The periodic response message length
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmit(Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
                                                         ,PduLengthType length);
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetProvideRxBuffer()
 *********************************************************************************************************************/
/*! \brief          Request reception data manager.
 *  \details        This function is called by Dcm_ProvideRxBuffer.
 *  \param[in]      DcmRxPduId      The RxPduId on the current request transmission
 *  \param[in]      TpSduLength     The required data length from the lower layer
 *  \param[out]     PduInfoPtr      Pointer to the request buffer pointer and buffer size
 *  \param[in]      addTObjFlags    Additional transport object flags from caller.
 *  \return         0               BUFREQ_OK
 *  \return         >0              Failed for some reason
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE for different PduIds
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetProvideRxBuffer(PduIdType DcmRxPduId
                                                              ,PduLengthType TpSduLength
                                                              ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) *PduInfoPtr
                                                              ,Dcm_NetTransportObjectFlagType addTObjFlags);
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetStartOfReception()
 *********************************************************************************************************************/
/*! \brief          Start of new request reception.
 *  \details        This function is called by Dcm_StartOfReception.
 *  \param[in]      rxPduId            The RxPDUID of the request
 *  \param[in]      tpSduLength        The total length of the TP message
 *  \param[out]     bufferSizePtr      Available buffer size
 *  \param[in]      addTObjFlags       Additional transport object flags from caller
 *  \return         BUFREQ_OK          A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK    No free buffer is available - ignore request
 *  \return         BUFREQ_E_OVFL      The request message is too long for the configured buffer
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetStartOfReception(PduIdType rxPduId
                                                          ,PduLengthType tpSduLength
                                                          ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
                                                          ,Dcm_NetTransportObjectFlagType addTObjFlags);

/**********************************************************************************************************************
 *  Dcm_NetSetComModeEntered()
 *********************************************************************************************************************/
/*! \brief          Internal utility for updating the new communication state.
 *  \details        -
 *  \param[in]      networkId      The communication channel on which this state is now active
 *  \param[in]      newComState    The new state of the communication channel (e.g. DCM_NET_COMM_STATE_RX_DIS_TX_DIS)
 *  \context        ISR1|ISR2
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetSetComModeEntered(NetworkHandleType networkId
                                                       ,Dcm_NetComMStateType newComState);
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferExecute()
 *********************************************************************************************************************/
/*! \brief          Starts polling a paged buffer update function.
 *  \details        -
 *  \param[in,out]  pDataContext          The pointer to the data context
 *  \param[out]     ErrorCode             The NRC
 *  \return         DCM_E_OK              All data has been copied - evaluate the out parameters
 *  \return         DCM_E_PENDING         No result yet, retry later
 *  \return         DCM_E_NOT_OK          Something went wrong, stop updating (only in DET situation)
 *  \return         DCM_E_BUFFERTOOLOW    Some data copied but no place, retry later on TP buffer under-run
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferExecute(Dcm_DiagDataContextPtrType      pDataContext
                                                               ,Dcm_NegativeResponseCodePtrType ErrorCode);
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCancel()
 *********************************************************************************************************************/
/*! \brief          Dispatches the CancelPage call.
 *  \details        Dispatches the CancelPage call regarding the paged-buffer.
 *  \param[out]     ErrorCode       The NRC
 *  \return         DCM_E_OK        Operation finished with success
 *  \return         DCM_E_NOT_OK    Operation failed, ErrorCode contains the NRC
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferCancel(Dcm_NegativeResponseCodePtrType ErrorCode);
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferStart()
 *********************************************************************************************************************/
/*! \brief          Activate paged-buffer write process.
 *  \details        -
 *  \param[in]      resDataLen    Specifies how many bytes will be copied using the update page function.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferStart(Dcm_MsgLenType resDataLen);
#endif
/**********************************************************************************************************************
 *  Dcm_RepeaterExecute()
 *********************************************************************************************************************/
/*! \brief          Starts polling a repeater proxy.
 *  \details        -
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_RepeaterExecute(Dcm_NegativeResponseCodePtrType ErrorCode);

/**********************************************************************************************************************
 *  Dcm_RepeaterSetCallee()
 *********************************************************************************************************************/
/*! \brief          Starts polling a repeater proxy.
 *  \details        -
 *  \param[in]      serviceProcessorIdx    The proxy callee
 *  \context        TASK
 *  \reentrant      FALSE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_RepeaterSetCallee(uint8 serviceProcessorIdx);
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Mode management on control DTC setting.
 *  \details        -
 *  \param[in]      newMode       The mode
 *  \param[in]      DTCGroup      The affected DTC group of changed setting
 *  \param[in]      DemClientId   The DEM client id
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchDtcSetting(Rte_ModeType_DcmControlDtcSetting newMode
                                                       ,uint32                            DTCGroup
                                                       ,uint8                             DemClientId);
# endif

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchCommControl()
 *********************************************************************************************************************/
/*! \brief          Mode management on communication control.
 *  \details        -
 *  \param[in]      networkRef The network handle
 *  \param[in]      newMode    The mode
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchCommControl(Dcm_CfgNetNetIdRefOptType networkRef
                                                        ,Dcm_CommunicationModeType newMode);
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_StateCheck()
 *********************************************************************************************************************/
/*! \brief          Performs a state rule check.
 *  \details        -
 *  \param[in]      stateRef                  Reference to the state precondition table
 *  \param[in]      chkLevel                  State level check
 *  \param[out]     ErrorCode                 The NRC
 *  \return         DCM_E_OK                  State rule check was sucessful
 *  \return         DCM_E_NOT_OK              State rule check was not sucessful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_StateCheck(Dcm_CfgStateRefOptType stateRef
                                                       ,Dcm_DiagCheckLvlType chkLevel
                                                       ,Dcm_NegativeResponseCodePtrType ErrorCode);

/**********************************************************************************************************************
 *  Dcm_StateSetSession()
 *********************************************************************************************************************/
/*! \brief          Performs a session state transition.
 *  \details        -
 *  \param[in]      stateRef    The state order number.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSession(Dcm_StateIndexOptType stateRef);

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateSetSecurity()
 *********************************************************************************************************************/
/*! \brief          Performs a security state transition.
 *  \details        -
 *  \param[in]      stateRef    The state order number.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSecurity(Dcm_StateIndexOptType stateRef);
#endif
/**********************************************************************************************************************
 *  Dcm_TskScheduler()
 *********************************************************************************************************************/
/*! \brief          Task scheduling.
 *  \details        Monitors for any tasks to be activated.
 *  \param[in]      tskPrio    The tasks priority to be monitored and activated
 *  \context        TASK
 *  \reentrant      TRUE only in case split task is supported.
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TskScheduler(Dcm_TskTaskPrioMemType tskPrio);
/* --- Timer Tasks ------------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_TmrTaskTimer()
 *********************************************************************************************************************/
/*! \brief          Timer task scheduling.
 *  \details        Scheduling of the timer manager sub-module.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TmrTaskTimer(Dcm_TskTaskEvOptType ev
                                               ,Dcm_TskTaskEvPtrType pPostEv);

/* --- PagedBuffer Tasks ------------------------------------------------------------------------------------------- */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferTask()
 *********************************************************************************************************************/
/*! \brief          Lo priority Tx task of the paged-buffer sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferTask(Dcm_TskTaskEvOptType ev
                                                  ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/* --- Diagnostic Tasks -------------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_DiagTaskRx()
 *********************************************************************************************************************/
/*! \brief          Hi priority Rx task of the network sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRx(Dcm_TskTaskEvOptType ev
                                             ,Dcm_TskTaskEvPtrType pPostEv);

/**********************************************************************************************************************
 *  Dcm_DiagTaskWorker()
 *********************************************************************************************************************/
/*! \brief          Low priority task of the diagnostic sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskWorker(Dcm_TskTaskEvOptType ev
                                                 ,Dcm_TskTaskEvPtrType pPostEv);

#if (DCM_TSK_NUM_DIAG_GARB_COL > 0)
/**********************************************************************************************************************
 *  Dcm_DiagTaskGarbageCollector()
 *********************************************************************************************************************/
/*! \brief          High priority task of the diagnostic sub-module.
 *  \details        Releases all obsolete transport objects after prioritization.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskGarbageCollector(Dcm_TskTaskEvOptType ev
                                                           ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagTaskFblRes()
 *********************************************************************************************************************/
/*! \brief          Low priority task of the diagnostic sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskFblRes(Dcm_TskTaskEvOptType ev
                                                 ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTaskTx()
 *********************************************************************************************************************/
/*! \brief          Hi priority Tx task of the diagnostic sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskTx(Dcm_TskTaskEvOptType ev
                                             ,Dcm_TskTaskEvPtrType pPostEv);

/* --- Net Tasks --------------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_NetTaskTx()
 *********************************************************************************************************************/
/*! \brief          Hi priority task of the network sub-module for transmissions.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTx(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv);

#if (DCM_NET_TASK_RX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTaskRx()
 *********************************************************************************************************************/
/*! \brief          Hi priority task of the network sub-module for request prioritization.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskRx(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTaskTaMonitor()
 *********************************************************************************************************************/
/*! \brief          Hi priority task of the network sub-module for request processing suppression.
 *  \details        This function is used to prevent a request processing or to cancel an ongoing request processing.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTaMonitor(Dcm_TskTaskEvOptType ev
                                                   ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/* --- ModeManager monitoring task --------------------------------------------------------------------------------- */
#if (DCM_TSK_NUM_MODE_MONITOR > 0)
/**********************************************************************************************************************
 *  Dcm_ModeTaskMonitor()
 *********************************************************************************************************************/
/*! \brief          Lo priority monitoring task of the Mode manager sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeTaskMonitor(Dcm_TskTaskEvOptType ev
                                                  ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_SVC2A_SCHEDULER > 0)
/**********************************************************************************************************************
 *  Dcm_Svc2ATaskSchdProcess()
 *********************************************************************************************************************/
/*! \brief          Low priority task.
 *  \details        Task for service 0x2A scheduling.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ATaskSchdProcess(Dcm_TskTaskEvOptType ev
                                                       ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_SVC27 > 0)
/**********************************************************************************************************************
 *  Dcm_Svc27Task()
 *********************************************************************************************************************/
/*! \brief          Low priority task.
 *  \details        Task for service 0x27.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27Task(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_RECOVERY > 0)                                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagTaskRecovery()
 *********************************************************************************************************************/
/*! \brief          Low priority task of the diagnostic sub-module to recover an external stored DCM state.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRecovery(Dcm_TskTaskEvOptType ev
                                                   ,Dcm_TskTaskEvPtrType pPostEv);
#endif
/* --- Timer notification functions -------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutP2()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a P2 timeout occurs.
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutP2(void);

/**********************************************************************************************************************
 *  Dcm_OnTimeoutS3()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a S3 timeout occurs.
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutS3(void);

#if (DCM_TMR_NUM_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutFblRes()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when the P2* time expires after FBL-to-APPL transition
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutFblRes(void);
#endif

#if (DCM_TMR_NUM_SECURITY_0 > 0)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSecurityAccess_0()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a security access timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSecurityAccess_0(void);
#endif

#if (DCM_TMR_NUM_SECURITY_1 > 0)                                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSecurityAccess_1()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a security access timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSecurityAccess_1(void);
#endif

#if (DCM_TMR_NUM_PERIODIC_TX > 0)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutPeriodicTx()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        The periodic transmission timeout is reached
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutPeriodicTx(void);
#endif

#if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSvc2AScheduler()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a service 0x2A scheduler timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSvc2AScheduler(void);
#endif

#if (DCM_TMR_NUM_KEEP_ALIVE > 0)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutKeepAlive()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a keep alive timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutKeepAlive(void);
#endif
#if (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_RETVAL_TO_NRC_MAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiGetNrcForDemRetValue()
 *********************************************************************************************************************/
/*! \brief          Converts a DEM API return value to a concrete NRC.
 *  \details        -
 *  \param[in]      demResult           DEM API returned value
 *  \param[in]      demResult2NrcMap    Pointer to a DEM API specific map (serialized array of pair values)
 *  \return         The associated NRC for the given DEM result value
 *  \return         The panic NRC
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DemApiGetNrcForDemRetValue(uint8 demResult, Dcm_Uint8ConstDataPtrType demResult2NrcMap);
# endif

# if (DCM_DEMAPI_GETNEXTFILTEREDITEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiConvDemRsltGetNextFilteredItem()
 *********************************************************************************************************************/
/*! \brief          Converts a DEM API return value to a concrete DCM return value.
 *  \details        -
 *  \param[in]      demResult                 DEM API returned value
 *  \param[out]     ErrorCode                 The NRC
 *  \return         DCM_E_DATA_READY_PADDING  Force padding of remaining bytes
 *  \return         DCM_E_PENDING             Retry later
 *  \return         DCM_E_BUFFERTOOLOW        Retry later, because of no available space any more
 *  \return         DCM_E_NOT_OK              Error occured
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DemApiConvDemRsltGetNextFilteredItem(
                                                                         Dcm_DemReturnGetNextFilteredItemType demResult
                                                                        ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif
#endif /* (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDidHasLock()
 *********************************************************************************************************************/
/*! \brief          Checks whether the given owner has locked any Did.
 *  \details        -
 *  \param[in]      owner    Service specific owner of the to be locked Did
 *  \return         TRUE     Did is already locked by the given owner
 *  \return         FALSE    Did is not locked by the given owner
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_DidMgrDidHasLock(Dcm_DidMgrDidLockOwnerType owner);

/**********************************************************************************************************************
 *  Dcm_DidMgrDidIsFree()
 *********************************************************************************************************************/
/*! \brief          Checks whether a Did can be locked or not.
 *  \details        -
 *  \param[in]      did      Did to be locked
 *  \return         TRUE     Did is not locked
 *  \return         FALSE    Did is locked or owner has already a lock for another Did
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_DidMgrDidIsFree(uint16 did);

/**********************************************************************************************************************
 *  Dcm_DidMgrDidLock()
 *********************************************************************************************************************/
/*! \brief          Tries to lock a given Did.
 *  \details        -
 *  \param[in]      did              Did to be locked
 *  \param[in]      owner            Service specific owner of the to be locked Did
 *  \return         DCM_E_OK         Did was successfully locked or owner has already a lock for that Did
 *  \return         DCM_E_PENDING    Did is locked
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDidLock(uint16 did, Dcm_DidMgrDidLockOwnerType owner);

/**********************************************************************************************************************
 *  Dcm_DidMgrDidRelease()
 *********************************************************************************************************************/
/*! \brief          Releases a Did locked by the given owner.
 *  \details        -
 *  \param[in]      owner    Service specific owner of the to be released Did
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrDidRelease(Dcm_DidMgrDidLockOwnerType owner);

# if (DCM_DIDMGR_CANCEL_OP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrCancelOperation()
 *********************************************************************************************************************/
/*! \brief          Cancels an ongoing DID operation.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrCancelOperation(void);
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrInitOpInfo()
 *********************************************************************************************************************/
/*! \brief          Initializes the index to Dcm_CfgDidMgrDidOpInfo[].
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration context
 *  \param[in]      didOp              The required DID operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrInitOpInfo(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                   ,Dcm_DidMgrOpOptType             didOp);

/**********************************************************************************************************************
 *  Dcm_DidMgrInitOpClassInfo()
 *********************************************************************************************************************/
/*! \brief          Initializes the index to Dcm_CfgDidMgrDidOpClassInfo[].
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration context
 *  \param[in]      opType             Operation type
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrInitOpClassInfo(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                        ,Dcm_DidMgrOpCallOptType         opType);

/**********************************************************************************************************************
 *  Dcm_DidMgrInitOpTypeHandler()
 *********************************************************************************************************************/
/*! \brief          Initialization function of the  DID handler.
 *  \details        Prepare DID for multi signal processing for a specific operation type (i.e. Read, ReadCheckCond,
 *                  Write, etc.)
 *  \param[in]      pDidInfoContext    The DID configuration context
 *  \param[in]      pDidOpTypeContext  The DID operation context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrInitOpTypeHandler(Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                          ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);

/**********************************************************************************************************************
 *  Dcm_DidMgrReadLength()
 *********************************************************************************************************************/
/*! \brief          Returns the length of a specific DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in]      pDidInfoContext    The DID configuration context
 *  \param[in]      pDidOpTypeContext  The DID operation context
 *  \param[out]     ErrorCode          The error code
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLength(Dcm_OpStatusType                  opStatus
                                                             ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                             ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                             ,Dcm_NegativeResponseCodePtrType   ErrorCode);

/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCond()
 *********************************************************************************************************************/
/*! \brief          Returns the check condition of a specific DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in]      pDidInfoContext    The DID configuration context
 *  \param[in]      pDidOpTypeContext  The DID operation context
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCond(Dcm_OpStatusType                  opStatus
                                                                ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                ,Dcm_NegativeResponseCodePtrType   ErrorCode);

# if (DCM_DIDMGR_DYNDID_DEEP_CHECK_ON_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDynDidStateCheck()
 *********************************************************************************************************************/
/*! \brief          Checks the state of a specific DID.
 *  \details        Checks a DID operation info considering DynDID content.
 *  \param[in]      pDidInfoContext    The DID configuration context
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK           State check was successful
 *  \return         DCM_E_NOT_OK       State check was not successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDynDidStateCheck(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode);
# else
/* a function like macro is used for optimal code size */
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrReadDid()
 *********************************************************************************************************************/
/*! \brief          Reads a DID for service 0x22.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The DID configuration context
 *  \param[in,out]  pDidOpTypeContext  The DID configuration operation context
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadDid(Dcm_OpStatusType                  opStatus
                                                          ,Dcm_DiagDataContextPtrType        pDataContext
                                                          ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                          ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                          ,Dcm_NegativeResponseCodePtrType   ErrorCode);
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemSetDTCFilter()
 *********************************************************************************************************************/
/*! \brief          Sets the DTC Filter in Dem.
 *  \details        -
 *  \param[in]      StatusMask              DTC Statusmask
 *  \param[in]      Origin                  DTC Origin
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemSetDTCFilter(uint8 StatusMask
                                                                 ,Dem_DTCOriginType Origin
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrReadDtcByStatusMask()
 *********************************************************************************************************************/
/*! \brief          Processes a DTC read by status mask service for OBD.
 *  \details        -
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_STOP_REPEATER     Stop Repeater Proxy
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            DTC Filter set in Dem (Dcm_ObdDtcMgrDemSetDTCFilter)
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrReadDtcByStatusMask(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          Data processor of service (0x03/0x07/0x0A).
 *  \details        Calls the GetNextFilteredDTC function.
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_NOT_OK                Error occured
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(Dcm_DiagDataContextPtrType pDataContext
                                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                          ,Dcm_ObdDtcManagerContextPtrType pRepContext);
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_DiagRcrRpTxFinished()
 *********************************************************************************************************************/
/*! \brief          Performs post processing of currently finished RCR-RP transmission.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRcrRpTxFinished(Dcm_NetTransportObjectPtrType pTranspObj
                                                      ,Dcm_NetTransmissionResultType txStatus);

/**********************************************************************************************************************
 *  Dcm_DiagSetP2Timings()
 *********************************************************************************************************************/
/*! \brief          Sets the adjusted P2 timings.
 *  \details        -
 *  \param[in]      sesStateIdx    The index of the current session.
 *  \param[in]      protocolIdx    The index of the current protocol.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagSetP2Timings(Dcm_StateIndexMemType sesStateIdx,
                                                    Dcm_NetProtRefMemType protocolIdx);

/**********************************************************************************************************************
 *  Dcm_DiagRxIndication()
 *********************************************************************************************************************/
/*! \brief          Called once an incoming reception is finished.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM external/internal connection
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRxIndication(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_SetNegResponse()
 *********************************************************************************************************************/
/*! \brief          Registers a NRC to the request in progress if no other NRC already set.
 *  \details        -
 *  \param[in]      nrc    The error code to be registered
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_SetNegResponse(Dcm_NegativeResponseCodeType nrc);

/**********************************************************************************************************************
 *  Dcm_ProcessingDone()
 *********************************************************************************************************************/
/*! \brief          Finalizes the service job processing.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ProcessingDone(void);

/**********************************************************************************************************************
 *  Dcm_DiagLookUpFilter()
 *********************************************************************************************************************/
/*! \brief          Performs a lookup result filtering.
 *  \details        -
 *  \param[in]      lookUpResult         The original result of the lookup
 *  \param[in]      lookUpFilterTable    List of filters
 *  \param[in]      chkLevel             Hierarchy level on which the lookup is performed
 *  \param[out]     errorCode            The error code to be returned
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_DiagLookUpFilter(sint16_least lookUpResult
                                                           ,Dcm_VarRefMemPtrType lookUpFilterTable
                                                           ,Dcm_DiagCheckLvlType chkLevel
                                                           ,Dcm_NegativeResponseCodePtrType errorCode);
#if (DCM_DIAG_SF_ONLY_SERVICE_ENABLED == STD_ON)                                                                                                     /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagSvcWithOnlySubFuncReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Default sub-function length getter.
 *  \details        Always returns length of 1 byte (sub-function byte only expected)
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length (1 byte only)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_DiagSvcWithOnlySubFuncReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif

#if (DCM_DIAG_ANY_SERVICE_WITH_SF_ENABLED == STD_ON)                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagNoSequenceChecker()
 *********************************************************************************************************************/
/*! \brief          Default sub-function sequence checker.
 *  \details        Always returns DCM_E_OK.
 *  \param[in]      subSvcRef            The sub-function zero-based index.
 *  \return         DCM_E_OK             Validation passed
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagNoSequenceChecker(Dcm_DiagSubServiceRefOptType subSvcRef);
#endif

#if (DCM_DIAG_ANY_SERVICE_WITH_SF_ENABLED == STD_ON)                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagSvcWithSubFuncStateCheck()
 *********************************************************************************************************************/
/*! \brief          Performs a state rule check for a service with sub-function.
 *  \details        -
 *  \param[in]      stateRef                  Reference to the state precondition table
 *  \param[in]      subFuncSequenceChecker    Function for accessing a service specific sequence check
 *  \param[in]      subSvcRef                 The sub-function zero-based index
 *  \param[out]     ErrorCode                 The NRC
 *  \return         DCM_E_OK                  State rule check was sucessful
 *  \return         DCM_E_NOT_OK              State rule check was not sucessful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSvcWithSubFuncStateCheck(
                                                        Dcm_CfgStateRefOptType                  stateRef
                                                       ,Dcm_DiagSubFuncSequenceCheckerFuncType  subFuncSequenceChecker
                                                       ,Dcm_DiagSubServiceRefOptType            subSvcRef
                                                       ,Dcm_NegativeResponseCodePtrType         ErrorCode);
#endif

#if (DCM_DIAG_ANY_SERVICE_WITH_SF_ENABLED == STD_ON)                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagVerifyServiceWithSubFunction()
 *********************************************************************************************************************/
/*! \brief          Verifies a service with sub-function.
 *  \details        Implements the ISO14229-1:2013 algorithm for sub-function validation
 *  \param[in,out]  pMsgContext            Current request context
 *  \param[in]      lookUpTable            The sub-service lookup table
 *  \param[in]      lookUpFilterTable      List of sub-service related filters
 *  \param[in]      svcLengthGetter        Functor for accessing a sub-service specific length
 *  \param[in]      subFuncSequenceChecker Function for accessing a service specific sequence check
 *  \param[out]     pSubSvcRef             A zero-based sub-service index for further processing
 *  \param[out]     ErrorCode              The NRC
 *  \return         DCM_E_OK               Validation passed
 *  \return         DCM_E_NOT_OK           Validation failed with the returned ErrorCode
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagVerifyServiceWithSubFunction(
                                                        Dcm_MsgContextPtrType                   pMsgContext
                                                       ,Dcm_Uint8ConstDataPtrType               lookUpTable
                                                       ,Dcm_VarRefMemPtrType                    lookUpFilterTable
                                                       ,Dcm_DiagServiceLengthGetterFuncType     svcLengthGetter
                                                       ,Dcm_DiagSubFuncSequenceCheckerFuncType  subFuncSequenceChecker
                                                       ,Dcm_DiagSubServiceRefOptPtrType         pSubSvcRef
                                                       ,Dcm_NegativeResponseCodePtrType         ErrorCode);
#endif

#if(DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagExecIndicationFunc()
 *********************************************************************************************************************/
/*! \brief          Executes an indication callback and evaluates its return values.
 *  \details        -
 *  \param[in]      sid                 The requested SID
 *  \param[in]      notificationType    The notification kind (OEM, SYS)
 *  \param[in]      notifList           The request indication list to be executed
 *  \param[out]     ErrorCode           The NRC
 *  \return         DCM_E_OK            Proceed with service validation after return
 *  \return         DCM_E_NOT_OK        At least one Xxx_Indication() has rejected further processing
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            The last element of the passed notifList must be marked by NULL_PTR.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagExecIndicationFunc(Dcm_MsgItemType sid
                                                                   ,Dcm_DiagApplNotificationType notificationType
                                                                   ,Dcm_CfgDiagNotificationInfoPtrType notifList
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTxFinalization()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTxFinalization(Dcm_NetTransportObjectPtrType pTranspObj
                                                     ,Dcm_NetTransmissionResultType txStatus);

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagOnFblResTxFinished()
 *********************************************************************************************************************/
/*! \brief          Called by the TP once an ongoing transmission is finished.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagOnFblResTxFinished(Dcm_NetTransportObjectPtrType pTranspObj
                                                         ,Dcm_NetTransmissionResultType txStatus);
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagCancelProcessing()
 *********************************************************************************************************************/
/*! \brief          Cancel any ongoing job.
 *  \details        This function cancels any ongoing service processing.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagCancelProcessing(void);
#endif
/**********************************************************************************************************************
 *  Dcm_VarMgrLookUpFilter()
 *********************************************************************************************************************/
/*! \brief          Performs a lookup result filtering.
 *  \details        Checks whether a diagnostic object is supported in the active variant.
 *  \param[in]      lookUpResult         The original result of the lookup (can also be "NOT_FOUND")
 *  \param[in]      lookUpFilterTable    List of filters
 *  \return         -1     Diagnostic entity not active in current variant
 *  \return         >=0    Success, index of the matched position
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_VarMgrLookUpFilter(sint16_least lookUpResult
                                                             ,Dcm_VarRefMemPtrType lookUpFilterTable);

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrIsEnabledInActiveVariants()
 *********************************************************************************************************************/
/*! \brief          Checks if a diagnostic object is active in at least one variant.
 *  \details        -
 *  \param[in]      cfgVariantRef    Reference to the variant configuration
 *  \return         TRUE             Diagnostic object is active in at least one variant
 *  \return         FALSE            Diagnostic object is not active
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgStateRefOptType cfgVariantRef);
#else
# define Dcm_VarMgrIsEnabledInActiveVariants(cfgVariantRef)          ((boolean)Dcm_VarMgrBitSetTestBit(Dcm_PbCfgVarMgrDiagVariantFilter[(cfgVariantRef)], Dcm_SingletonContext.VarMgr.ActiveCfgVariantId)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessEcuReset()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 EcuReset mode switching management.
 *  \details        Manages the mode switches for service 0x11. If something goes wrong, an appropriate NRC will be sent.
 *  \param[in]      mode                The ECU reset mode to be switched into
 *  \param[out]     ErrorCode           The NRC
 *  \return         DCM_E_NOT_OK        Send response (negative)
 *  \return         DCM_E_LOOP          Process immediately with next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessEcuReset(Dcm_ModeMgrArEnvModeEcuResetType mode
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessRapPwrDwn()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 RapidPowerShutDown mode switching management.
 *  \details        Manages the mode switches for service 0x11. If something goes wrong, an appropriate NRC will be sent.
 *  \param[in]      mode                The ECU reset mode to be switched into
 *  \param[out]     ErrorCode           The NRC
 *  \return         DCM_E_NOT_OK        Send response (negative)
 *  \return         DCM_E_LOOP          Process immediately with next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessRapPwrDwn(Dcm_ModeMgrArEnvModeRapidPowerShutDownType mode
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x19 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc19ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByStatusMaskData()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting number of DTC by status mask.
 *  \details        -
 *  \param[in]      dsfClass                DEM SetFilter class type
 *  \param[in]      dtcStatusMask           DTC status mask
 *  \param[in]      dtcSeverity             If severity specific search - define the severity level
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByStatusMaskData(
                                                                     Dcm_Svc19DemSetFilterClassType       dsfClass
                                                                    ,uint8                                dtcStatusMask
                                                                    ,Dem_DTCSeverityType                  dtcSeverity
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcByStatusMaskData()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting DTC and status mask.
 *  \details        -
 *  \param[in]      dsfClass                DEM SetFilter class type
 *  \param[in]      maskUsage               Specifies how to treat the requested status mask (if any)
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcByStatusMaskData(
                                                                     Dcm_Svc19DemSetFilterClassType       dsfClass
                                                                    ,Dcm_Svc19DemSetFilterMaskUsageType   maskUsage
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportExtDataRecordByDtcNum()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting DTC and its extended data record(s).
 *  \details        -
 *  \param[in]      dtcOrigin               The DTC origin to process
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportExtDataRecordByDtcNum(Dem_DTCOriginType        dtcOrigin
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*! \brief          Read the next filtered DTC and its FDC.
 *  \details        -
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \return         DCM_E_NOT_OK                Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdFDC(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainStart()
 *********************************************************************************************************************/
/*! \brief          Initiates a service processing chain of activities.
 *  \details        -
 *  \param[in]      funcChain     The function chain
 *  \param[in,out]  pRepContext   Current repeater proxy context
 *  \return         DCM_E_LOOP    Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainStart(
                                                   P2CONST(Dcm_RepeaterProgressType, AUTOMATIC, DCM_CONST) funcChain
                                                  ,Dcm_Svc19RepeaterProxyContextPtrType                    pRepContext);
# endif

# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainNext()
 *********************************************************************************************************************/
/*! \brief          Switches to the next processing activity in the chain specified by Dcm_Svc19UtiChainStart.
 *  \details        -
 *  \param[in,out]  pRepContext   Current repeater proxy context
 *  \return         DCM_E_LOOP    Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainNext(Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByOccurenceTime()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting number DTC by occurence time.
 *  \details        -
 *  \param[in]      dtcReqType              The DTC request type
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByOccurenceTime(Dem_DTCRequestType       dtcReqType
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcFFRByDtc()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting DTC and its freze-frame data record(s).
 *  \details        -
 *  \param[in]      dtcOrigin      The DTC origin to process
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_LOOP     Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcFFRByDtc(Dem_DTCOriginType                   dtcOrigin
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiSetAttemptCntr()
 *********************************************************************************************************************/
/*! \brief          Notifies the application about changed attempt counter values.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  levelMask               Pointer to a security level mask.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27UtiSetAttemptCntr(Dcm_OpStatusType opStatus
                                                         ,P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc27ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);

/**********************************************************************************************************************
 *  Dcm_Svc27SubFuncSequenceChecker()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 sub-function sequence checker.
 *  \details        Checks whether the sub-function sequence is correct.
 *  \param[in]      subSvcRef            The sub-function zero-based index.
 *  \return         DCM_E_OK             Validation passed
 *  \return         DCM_E_NOT_OK         Send negative response
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27SubFuncSequenceChecker(Dcm_DiagSubServiceRefOptType subSvcRef);
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc28EnableCommunication()
 *********************************************************************************************************************/
/*! \brief          Enable communication on all affected channels.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc28EnableCommunication(void);

/**********************************************************************************************************************
 *  Dcm_Svc28ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x28 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc28ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/* --- public members ---------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopAll()
 *********************************************************************************************************************/
/*! \brief          Stops all scheduled DIDs.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopAll(void);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByHandle()
 *********************************************************************************************************************/
/*! \brief          Stops a single scheduled item.
 *  \details        -
 *  \param[in]      schdHandle    The handle
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByHandle(Dcm_Svc2ASchdItemHandleOptType schdHandle);

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByDid()
 *********************************************************************************************************************/
/*! \brief          Cancels the reading of a single scheduled item.
 *  \details        -
 *  \param[in]      did    The did
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByDid(uint16 did);
# endif

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AGetConnectionOfDID()
 *********************************************************************************************************************/
/*! \brief          Returns the connection ID of scheduled DID.
 *  \details        -
 *  \param[in]      did    The DID
 *  \return         Valid connection ID (if DID is scheduled)
 *  \return         DCM_NET_INVALID_CONNID (if DID is not scheduled)
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_Svc2AGetConnectionOfDID(uint16 did);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByHandle()
 *********************************************************************************************************************/
/*! \brief          Stops a single scheduled item.
 *  \details        -
 *  \param[in]      schdHandle    The handle
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByHandle(Dcm_Svc2ASchdItemHandleOptType schdHandle);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByDid()
 *********************************************************************************************************************/
/*! \brief          Cancels the reading of a single scheduled item.
 *  \details        -
 *  \param[in]      did    The did
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByDid(uint16 did);

/* --- private members --------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetItemByDid()
 *********************************************************************************************************************/
/*! \brief          Look up for a scheduled DID.
 *  \details        -
 *  \param[in]      did           The did
 *  \param[in]      schdHandle    Handle of the found entry
 *  \return         TRUE          Entry was found
 *  \return         FALSE         Entry was not found - schdHandle output parameter is invalid
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdGetItemByDid(uint16 did
                                               ,P2VAR(Dcm_Svc2ASchdItemHandleOptType, AUTOMATIC, AUTOMATIC) schdHandle);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFinishEntryProcessing()
 *********************************************************************************************************************/
/*! \brief          Finalizes scheduler entry processing (with or without response).
 *  \details        Resets all global states after a scheduler entry was processed. Initiates response transmission
 *                  or releases UUDT message.
 *  \param[in]      doSendResponse    Specifies whether a response shall be sent or not
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdFinishEntryProcessing(boolean doSendResponse);
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ADidLookUp()
 *********************************************************************************************************************/
/*! \brief          A generic DID look-up for SID 0x2A.
 *  \details        Performs a lookup for a specific DID on any request.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \return         DCM_E_OK                Found a DID, make next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidLookUp(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                           ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrClear()
 *********************************************************************************************************************/
/*! \brief          Clear all DDID definitions.
 *  \details        Clears all previously defined DDIDs.
 *  \param[in]      dynDidHandle    DynDID reference to be cleared
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrClear(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle);
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C sub-function length getter.
 *  \details        Always returns length of 0 byte to show that the requests have dynamic length and the concrete
 *                  length will be checked later.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc2CReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);

/**********************************************************************************************************************
 *  Dcm_Svc2CParseAndCheckDynDid()
 *********************************************************************************************************************/
/*! \brief          Parses and validates the DynDID to be defined.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[out]     pRepContext    Current repeater proxy context
 *  \return         DCM_E_OK       Send response
 *  \return         DCM_E_NOT_OK   Send neagative response
 *  \return         DCM_E_PENDING  Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CParseAndCheckDynDid(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2CCheckAndSetNumOfItems()
 *********************************************************************************************************************/
/*! \brief          Check DynDID has enough space to keep all requested definitions.
 *  \details        If the check succeeds also stores the number of requested items for further processing.
 *  \param[in]      numRequestedItems  Number of requested Items
 *  \param[out]     ErrorCode          The NRC
 *  \param[in,out]  pRepContext        Current repeater proxy context
 *  \return         DCM_E_OK        Check succeeded
 *  \return         DCM_E_NOT_OK    Check failed (NRC is stored in ErrorCode)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CCheckAndSetNumOfItems(uint8 numRequestedItems
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc85EnableDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 enabler.
 *  \details        Calls the EnableDtcSetting function.
 *  \param[in]      DemClientId                The DEM ClientId
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85EnableDtcSetting(uint8 DemClientId);

# if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc85DisableDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 disabler.
 *  \details        Calls the DisableDtcSetting function.
 *  \param[in]      DTCGroup                   The DTC Group to be disabled
 *  \param[in]      DemClientId                The DEM ClientId
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85DisableDtcSetting(uint32 DTCGroup
                                                                   ,uint8  DemClientId);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc85ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 sub-function length getter.
 *  \details        Always returns length of 1 or 4 byte depending on whether the optional DTC group is supported.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc85ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);

/**********************************************************************************************************************
 *  Dcm_Svc85_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 worker.
 *  \details        Calls the Enable/DisableDTCSetting function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85_XX_RepeaterProxy(Dcm_OpStatusType      opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc85RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc86ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x86 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc86ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Uninitialized RAM of unspecified size
---------------------------------------------- */
#define DCM_START_SEC_VAR_NO_INIT_UNSPECIFIED
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/*! Sub-components per-instance memory */
DCM_LOCAL VAR(Dcm_InstanceContextType, DCM_VAR_NOINIT)  Dcm_InstanceContext;
/*! Sub-components shared memory */
DCM_LOCAL VAR(Dcm_SingletonContextType, DCM_VAR_NOINIT) Dcm_SingletonContext;
#define DCM_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Initialized RAM 8-Bit
---------------------------------------------- */
#define DCM_START_SEC_VAR_INIT_8
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/*! Dedicated RAM allocation for modules initialization state */
DCM_LOCAL VAR(Dcm_DebugInitStateType, DCM_VAR_INIT) Dcm_DebugInitState = DCM_DEBUG_INITSTATE_UNINIT;
#define DCM_STOP_SEC_VAR_INIT_8
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   ROM 8-Bit
---------------------------------------------- */
#define DCM_START_SEC_CONST_8
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/*! Converts DCMs implementation type definition values into the RTE Mode symbolic name values */
DCM_LOCAL CONST(Dcm_CommunicationModeType, DCM_CONST) Dcm_ModeComCtrlModeMap[12]=                                                                    /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
   RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_TX_NORM
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_DISABLE_TX_NORM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_ENABLE_TX_NORM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_TX_NORMAL
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_TX_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_DISABLE_TX_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_ENABLE_TX_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_TX_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_TX_NORM_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_DISABLE_TX_NORM_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_ENABLE_TX_NORM_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_TX_NORM_NM
};
#endif /* (DCM_MODE_COMMCTRL_ENABLED == STD_ON) */
/*! A map to get the negative response code corresponding to a specific diagnostic entity (i.e. service, sub-service or parameter identifier */
DCM_LOCAL CONST(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_StateSessionNrcs[DCM_DIAG_NUM_CHK_LVLS]=                                                 /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION /* on SID level */
 ,DCM_E_REQUESTOUTOFRANGE /* on Parameter (DID, RID, etc.) level */
 ,DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION /* on SubFunction level */
};
#if (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_SVC_19_SETDTCFILTER_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_SETFFRECORDFILTER_ENABLED == STD_ON) || \
     (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)

/*! Dem SetDTCFilter API return value to NRC mapping */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_DemApiNrcMapSetDTCFilter[3]=                                                                                   /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_WRONG_FILTER, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON) && \
     (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! Dem SelectDTC API return value to NRC mapping */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_DemApiNrcMapSelectDTC[1]=                                                                                      /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON) || \
     (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)
/*! Dem GetNumberOfFilteredDTC API return value to NRC mapping */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_DemApiNrcMapGetNumberOfFilteredDTC[3]=                                                                         /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_430_ENABLED == STD_OFF)
  DEM_NUMBER_FAILED, DCM_E_CONDITIONSNOTCORRECT,
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif
#endif /* (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/*! RID sub-function ID to operation type value conversion map */
DCM_LOCAL CONST(Dcm_RidMgrOpType, DCM_CONST) Dcm_RidMgrSubFunc2OpMap[4] =                                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_RIDMGR_OP_NONE,
  DCM_RIDMGR_OP_START,
  DCM_RIDMGR_OP_STOP,
  DCM_RIDMGR_OP_REQRSLTS
};
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
/*! Diagnostic service verification level to NRC map */
DCM_LOCAL CONST(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DiagObjNotFoundNrcs[DCM_DIAG_NUM_CHK_LVLS]=                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_E_SERVICENOTSUPPORTED     /*!< on SID level */
 ,DCM_E_REQUESTOUTOFRANGE       /*!< on Parameter (DID, RID, etc.) level */
 ,DCM_E_SUBFUNCTIONNOTSUPPORTED /*!< on SubFunction level */
};
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)
/*! Mapping of DEM Clear operation results to DCM NRCs */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc04NrcMapClearDTC[]=                                                                                         /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_CLEAR_W_DTC,        DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_CLEAR_FAILED,       DCM_E_CONDITIONSNOTCORRECT,
# if defined(DCM_DEM_RET_CLEAR_BUSY)                                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
  DCM_DEM_RET_CLEAR_BUSY,         DCM_E_CONDITIONSNOTCORRECT,
# endif
# if defined (DCM_DEM_RET_CLEAR_MEMORY_ERROR)
  DCM_DEM_RET_CLEAR_MEMORY_ERROR, DCM_E_CONDITIONSNOTCORRECT,
# endif
# if (DCM_DEM_API_430_ENABLED == STD_ON)
  DCM_DEM_RET_CLEAR_W_ORIGIN,     DCM_E_REQUESTOUTOFRANGE,
# else
  /* DCM_DEM_RET_CLEAR_W_ORIGIN,  DCM_E_PANIC_NRC  - shall not occur since DCM sets the origin -> enforce DET */
# endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/*! Mapping of DEM Clear operation results to DCM NRCs */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc14NrcMapClearDTC[]=                                                                                         /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_CLEAR_W_DTC,        DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_CLEAR_FAILED,       DCM_E_CONDITIONSNOTCORRECT,
# if defined(DCM_DEM_RET_CLEAR_BUSY)                                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
  DCM_DEM_RET_CLEAR_BUSY,         DCM_E_CONDITIONSNOTCORRECT,
# endif
# if defined (DCM_DEM_RET_CLEAR_MEMORY_ERROR)
  DCM_DEM_RET_CLEAR_MEMORY_ERROR, DCM_E_GENERALPROGRAMMINGFAILURE,
# endif
# if (DCM_DEM_API_430_ENABLED == STD_ON)
  DCM_DEM_RET_CLEAR_W_ORIGIN,     DCM_E_REQUESTOUTOFRANGE,
# else
  /* DCM_DEM_RET_CLEAR_W_ORIGIN,  DCM_E_PANIC_NRC  - shall not occur since DCM sets the origin -> enforce DET */
# endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/*! List of all (UDS and OBD) extended data records DEM supports */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19ExtDataRecords[DCM_SVC_19_EXTDATA_RECID_SIZE]=                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_SVC_19_NUM_EXTDATA_RECID > 0)                                                                                                             /* COV_DCM_SUPPORT_ALWAYS TX */
 DCM_SVC_19_LST_EXTDATA_RECID,
#  endif
 DCM_SVC_19_RECLIST_END /* end marker */
};
# endif

# if (DCM_SVC_19_OBD_EXT_RECORD_ENABLED == STD_ON)                                                                                                   /* COV_DCM_UNSUPPORTED XF */
/*! List of all OBD extended data records DEM supports */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19ExtDataRecordsObd[DCM_SVC_19_OBD_EXTDATA_RECID_SIZE]=                                                     /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_SVC_19_NUM_OBD_EXTDATA_RECID > 0)
 DCM_SVC_19_LST_OBD_EXTDATA_RECID,
#  endif
 DCM_SVC_19_RECLIST_END /* end marker */
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/*! List of all freeze frame data records DEM supports */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19FFDataRecords[DCM_SVC_19_FRZFRAME_RECID_SIZE]=                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_SVC_19_NUM_FRZFRAME_RECID > 0)                                                                                                            /* COV_DCM_SUPPORT_ALWAYS TX */
 DCM_SVC_19_LST_FRZFRAME_RECID,
#  endif
 DCM_SVC_19_RECLIST_END /* end marker */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETDTCSAM_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_GETDTCSEVAM_ENABLED == STD_ON)
/*! DEM API with Std_ReturnType result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapStdReturnType[3]=                                                                                   /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  E_NOT_OK, DCM_E_CONDITIONSNOTCORRECT,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETDTCOCCURTIME_ENABLED == STD_ON)
/*! DEM API "GetDTCByOccurrenceTime" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetDTCByOccurrenceTime[] =                                                                          /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if defined (DCM_DEM_RET_OCCURR_N_OK)
  DCM_DEM_RET_OCCURR_N_OK, DCM_E_GENERALREJECT,
#  endif
#  if defined (DCM_DEM_RET_OCCURR_NO_SUCH_ELEMENT)
  DCM_DEM_RET_OCCURR_NO_SUCH_ELEMENT, DCM_E_POSITIVERESPONSE,
#  endif
#  if defined (DCM_DEM_RET_OCCURR_NOT_AVAILABLE)
  DCM_DEM_RET_OCCURR_NOT_AVAILABLE, DCM_E_POSITIVERESPONSE,
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_SVC_19_05_SUPPORT_ENABLED == STD_ON)
/*! DEM API "GetOBDFreezeFrameData" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetOBDFreezeFrameData[1]=                                                                           /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
/*! DEM API "DisableDTCRecordUpdate", "EnableDTCRecordUpdate" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapAnyAbleRecordUpdate[]=                                                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_DISABLE_DTC_REC_UP_WRONG_DTCORIGIN, DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_DISABLE_DTC_REC_UP_WRONG_DTC,       DCM_E_REQUESTOUTOFRANGE,
#  if defined (DCM_DEM_RET_DISABLE_DTC_REC_UP_WRONG_CONDITION)
  /* Let it be handled in default case (PANIC NRC + DET error) since this means wrong DCM implementation */
  /* DCM_DEM_RET_DISABLE_DTC_REC_UP_WRONG_CONDITION, DCM_E_PANIC, */
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
/*! DEM API "GetStatusOfDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetStatusOfDTC[] =                                                                                  /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_STATUS_WRONG_DTC,       DCM_E_REQUESTOUTOFRANGE,
#  if defined (DCM_DEM_RET_STATUS_FAILED)
  DCM_DEM_RET_STATUS_FAILED,          DCM_E_CONDITIONSNOTCORRECT,
#  endif
  DCM_DEM_RET_STATUS_WRONG_DTCORIGIN, DCM_E_CONDITIONSNOTCORRECT,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/*! DEM API "GetSeverityOfDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetSeverityOfDTC[] =                                                                                /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_GET_SEVERITY_OF_DTC_WRONG_DTC, DCM_E_REQUESTOUTOFRANGE,
#  if defined (DCM_DEM_RET_GET_SEVERITY_OF_DTC_WRONG_DTCORIGIN)
  DCM_DEM_RET_GET_SEVERITY_OF_DTC_WRONG_DTCORIGIN, DCM_E_REQUESTOUTOFRANGE,
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/*! DEM API "GetFunctionalUnitOfDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetFunctionalUnitOfDTC[] =                                                                          /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if defined (DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_WRONG_DTCORIGIN)
  DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_WRONG_DTCORIGIN,  DCM_E_REQUESTOUTOFRANGE,
#  endif
  DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_WRONG_DTC,        DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
/*! DEM API "GetSizeOfExtendedDataRecordByDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetSizeOfExtendedDataRecordByDTC[] =                                                                /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if defined (DCM_DEM_RET_SIZEOFEDR_N_OK)
  /* Let it be handled in default case (PANIC NRC + DET error) since this means wrong DCM implementation */
  /* DCM_DEM_RET_SIZEOFEDR_N_OK,     DCM_E_PANIC, */
#  endif
  DCM_DEM_RET_SIZEOFEDR_W_DTC,    DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFEDR_W_RNUM,   DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFEDR_W_ORIGIN, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
/*! DEM API "GetSizeOfFreezeFrameByDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetSizeOfFreezeFrameByDTC[] =                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if defined (DCM_DEM_RET_SIZEOFFFR_N_OK)
  /* Let it be handled in default case (PANIC NRC + DET error) since this means wrong DCM implementation */
  /* DCM_DEM_RET_SIZEOFFFR_N_OK,     DCM_E_PANIC, */
#  endif
  DCM_DEM_RET_SIZEOFFFR_W_DTC,    DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFFFR_W_RNUM,   DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFFFR_W_ORIGIN, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
/*! DEM API "GetFreezeFrameDataByDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetFreezeFrameDataByDTC[7]=                                                                         /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_FFDATABYDTC_W_DTC,    DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_FFDATABYDTC_W_ORIGIN, DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_FFDATABYDTC_W_RNUM,   DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
/*! DEM API "GetExtendedDataRecordByDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetExtendedDataRecordByDTC[7]=                                                                      /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_DTC,       DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_DTCORIGIN, DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_NUMBER,    DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
DCM_LOCAL CONST(Dcm_DidMgrOpMemType, DCM_CONST) Dcm_Svc2FCtrlOp2DidOpTypeMap[4]=                                                                     /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU
 ,DCM_DIDMGR_OPTYPE_IO_RST2DEF
 ,DCM_DIDMGR_OPTYPE_IO_FRZCURSTATE
 ,DCM_DIDMGR_OPTYPE_IO_SHRTTRMADJ
};
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CONST_8
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   ROM of unspecified size
---------------------------------------------- */
#define DCM_START_SEC_CONST_UNSPECIFIED
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/*! Configuration of all DCM internal tasks */
DCM_LOCAL CONST(Dcm_TskTaskInfoType, DCM_CONST) Dcm_TskTaskInfo[DCM_TSK_NUM_TASKS]=                                                                  /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  /* first to be processed */
#if (DCM_TSK_NUM_DIAG_RECOVERY > 0)                                                                                                                  /* COV_DCM_UNSUPPORTED XF */
  {Dcm_DiagTaskRecovery,     (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE}, /* Task to recover an external stored DCM state */
#endif
#if (DCM_TSK_NUM_NET_TA_MONITOR > 0)
  {Dcm_NetTaskTaMonitor,     (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_NONE}, /* Requests with a foreign N_TA will be handled here */
#endif
#if (DCM_TSK_NUM_NET_RX > 0)
  {Dcm_NetTaskRx,            (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_NONE}, /* The P2 timer will be started here - put this task prior timer task. NetRx task must always work */
#endif
  {Dcm_TmrTaskTimer,         (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_NONE}, /* process timers first, the tasks will do their job according to the event priorities. Never kill timer task! */
  {Dcm_DiagTaskRx,           (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_ALWAYS), DCM_TSK_PRIO_HIGH, (DCM_TSK_EV_DIAG_RX_TMR_P2_TO | DCM_TSK_EV_DIAG_RX_NEW_REQ)},
#if (DCM_TSK_NUM_MODE_MONITOR > 0)
  {Dcm_ModeTaskMonitor,      (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE}, /* let monitors work in the background */
#endif
#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
  {Dcm_DiagTaskFblRes,       (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE},/* let FBL work in the background till end */
#endif
#if (DCM_TSK_NUM_SVC27 > 0)
  {Dcm_Svc27Task,            (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE}, /* Collects the attempt counter values */
#endif
  {Dcm_DiagTaskWorker,       (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_ALWAYS), DCM_TSK_PRIO_LOW,  (DCM_TSK_EV_DIAG_WORK_KILL_JOBS|DCM_TSK_EV_DIAG_WORK_INT_SET2DEF|DCM_TSK_EV_DIAG_WORK_NEW_REQ|DCM_TSK_EV_DIAG_WORK_TX_END_FINAL)},
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  {Dcm_PagedBufferTask,      (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_ALWAYS), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE},
#endif
#if (DCM_TSK_NUM_ROE > 0)
  {Dcm_ExtSvc86Task,         (DCM_TSK_ATR_ROE_EXEC   | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE}, /* let RoE work in the background - if RoE triggered the client prioritization will take place */
#endif
#if (DCM_TSK_NUM_DIAG_GARB_COL > 0)
  {Dcm_DiagTaskGarbageCollector, (DCM_TSK_ATR_EXEC_ONCE | DCM_TSK_ATR_KILL_NEVER),  DCM_TSK_PRIO_HIGH, 0},
#endif
  {Dcm_DiagTaskTx,           (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_ALWAYS), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_DIAG_TX_SEND_RCRRP},
#if (DCM_TSK_NUM_SVC2A_SCHEDULER > 0)
  {Dcm_Svc2ATaskSchdProcess, (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE},/* let 0x2A work in the background if needed to be stopped -> the stop all API shall be used */
#endif
  {Dcm_NetTaskTx,            (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_NONE}
  /* last to be processed */
};
DCM_LOCAL CONST(Dcm_TmrTimerInfoType, DCM_CONST) Dcm_TmrTimerInfo[DCM_TMR_NUM_TIMERS] =                                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  {Dcm_OnTimeoutP2}
 ,{Dcm_OnTimeoutS3}
#if (DCM_TMR_NUM_FBLRES > 0)
 ,{Dcm_OnTimeoutFblRes}
#endif
#if (DCM_TMR_NUM_SECURITY_0 > 0)
 ,{Dcm_OnTimeoutSecurityAccess_0}
#endif
#if (DCM_TMR_NUM_SECURITY_1 > 0)                                                                                                                     /* COV_DCM_UNSUPPORTED XF */
 ,{Dcm_OnTimeoutSecurityAccess_1}
#endif
#if (DCM_TMR_NUM_PERIODIC_TX > 0)
 ,{Dcm_OnTimeoutPeriodicTx}
#endif
#if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0)
 ,{Dcm_OnTimeoutSvc2AScheduler}
#endif
#if (DCM_TMR_NUM_SVC86_INTERMESSAGETIME > 0)
 ,{Dcm_ExtOnTimeoutSvc86InterMessageTime}
#endif
#if (DCM_TMR_NUM_KEEP_ALIVE > 0)
 ,{Dcm_OnTimeoutKeepAlive}
#endif
};
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_19_SETDTCFILTER_INFO_CLASS_ENABLED == STD_ON)
/*! A set of all required DEM filter configurations */
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
DCM_LOCAL CONST(Dcm_Svc19DemDtcFilterInfoType, DCM_CONST) Dcm_Svc19DemDtcFilterInfo[DCM_SVC_19_DEM_SETFILTER_NUM_CLASSES]=                           /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  {DEM_DTC_ORIGIN_PRIMARY_MEMORY,      FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_01: SF 0x01, 0x02, 0x14, 0x0A */
 ,{DEM_DTC_ORIGIN_PRIMARY_MEMORY,      TRUE}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_02: SF 0x07, 0x08 */
 ,{DEM_DTC_ORIGIN_MIRROR_MEMORY,       FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_03: SF 0x11, 0x0F */
 ,{DEM_DTC_ORIGIN_OBD_RELEVANT_MEMORY, FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_04: SF 0x12, 0x13 */
 ,{DEM_DTC_ORIGIN_PERMANENT_MEMORY,    FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_05: SF 0x15 */
 ,{DEM_DTC_ORIGIN_SECONDARY_MEMORY,    FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_06: SF 0x17 */ /* 0x17: mem selection from request */
 ,{DEM_DTC_ORIGIN_OBD_RELEVANT_MEMORY, TRUE}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_07: SF 0x42 */
};
#  else
DCM_LOCAL CONST(Dcm_Svc19DemDtcFilterInfoType, DCM_CONST) Dcm_Svc19DemDtcFilterInfo[DCM_SVC_19_DEM_SETFILTER_NUM_CLASSES]=                           /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  {DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_01: SF 0x01, 0x02, 0x14, 0x0A */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DCM_DEM_FILTER_WITH_SEVERITY_YES} /* DCM_SVC_19_DEM_SETFILTER_CLASS_02: SF 0x07, 0x08 */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_MIRROR_MEMORY,    DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_03: SF 0x11, 0x0F */
 ,{DEM_DTC_KIND_EMISSION_REL_DTCS,  DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_04: SF 0x12, 0x13 */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_PERMANENT_MEMORY, DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_05: SF 0x15 */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_SECONDARY_MEMORY, DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_06: SF 0x17 */
 ,{DEM_DTC_KIND_EMISSION_REL_DTCS,  DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DCM_DEM_FILTER_WITH_SEVERITY_YES} /* DCM_SVC_19_DEM_SETFILTER_CLASS_07: SF 0x42 */
};
#  endif
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON) || \
     (DCM_SVC_19_05_SUPPORT_ENABLED             == STD_ON)
/*! List of actions for acquiring DTC status and reporting it together with the DTC itself. This is also a termination activity chain triggering the final positive response */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainGetDtcStatusEnd[] =                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC,
#  endif
  DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC
 ,DCM_SVC19_PROGRESS_CHAIN_END
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/*! List of actions for freeze-frame data reporting prolog */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainReadFFRByDtc[] =                                                               /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC,
#  endif
  DCM_SVC19_PROGRESS_DEMCHAIN_DISABLERECORDUPDATE
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC
#  if (DCM_DEM_API_SELECT_FFR_ENABLED == STD_ON)
 ,DCM_SVC19_PROGRESS_DEMCHAIN_SELECTFFREC
#  endif
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFFFREC
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/*! List of actions for extended data reporting prolog */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainReadExtRecords[] =                                                             /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC,
#  endif
  DCM_SVC19_PROGRESS_DEMCHAIN_DISABLERECORDUPDATE
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC
#  if (DCM_DEM_API_SELECT_EDR_ENABLED == STD_ON)
 ,DCM_SVC19_PROGRESS_DEMCHAIN_SELECTEXTDATAREC
#  endif
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFEXTDATAREC
};
# endif

# if (DCM_SVC_19_09_SUPPORT_ENABLED == STD_ON)
/*! List of actions for complete processing of SF 0x09 */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19_09DemChain[] =                                                                        /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC,
#  endif
  DCM_SVC19_PROGRESS_DEMCHAIN_GETSEVERITYOFDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETFUNCUNITOFDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC
 ,DCM_SVC19_PROGRESS_CHAIN_END
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/*! List of actions for complete processing of a SF reporting the number of filtered DTCs */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainDtcCount[2] =                                                                  /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_PUTNUMFLTRDDTC
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/*! List of actions for complete processing of a SF reporting DTCs filtered by status mask */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainReadDtcByStatus[2] =                                                           /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
 DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC /* let this API to be called also in linear-buffer case in order to check for the last time if any DEM state error has occurred */
,DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDDTC
};
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/*! List of actions for complete processing of SF 0x08 */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19_08DemChain[2] =                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDSEVERITY
};
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/*! List of actions for complete processing of SF 0x14 */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19_14DemChain[2] =                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDFDC
};
# endif
# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/*! List of actions for complete processing of SF 0x42 */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19_42DemChain[2] =                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC /* let this API to be called also in linear-buffer case in order to check for the last time if any DEM state error has occurred */
 ,DCM_SVC19_PROGRESS_DEMCHAIN_WWHOBD_GETNEXTFLTRDSEVERITY
};
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CONST_UNSPECIFIED
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Inlined function implementations (Top Level)
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_UTI_LOOKUP_RANGE_U16_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_UtiLookUpRangeUint16()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpRangeUint16(P2CONST(Dcm_UtiU16RangeType, AUTOMATIC, DCM_CONST) lookUpTable
                                                                      ,uint16 value)
{
  sint16_least  lResult;
  uint16_least  loIdx;
  uint16_least  hiIdx;
  uint16_least  lPosition;

  /* #10 Initialize look-up: assume nothing will be found */
  lResult = -1;
  loIdx= 1;
  hiIdx= lookUpTable[0].First;/* Take one of the borders since both have the same value */

  /* #20 If any sub-array exists: */
  while (loIdx <= hiIdx)
  {
    /*  #30 Calculate entry position for comparison */
    lPosition = (uint16_least)(loIdx + ((hiIdx - loIdx) / 2)); /* avoids overflows on value addition */

    /* #40 If valid range found:  */
    if( (lookUpTable[lPosition].First <= value)
      &&(lookUpTable[lPosition].Second >= value) )
    {
      /* #50 Return valid entry position (compensate offset) */
      lResult = (sint16_least)(lPosition - 1);
      break;
    }
    /* #60 Otherwise - continue searching */

    /* #70 Determine which sub-array shall be taken as a next */
    if (value < lookUpTable[lPosition].First)
    {
      /* not needed lPosition zero value check, since loIdx >=1 */
      hiIdx = (uint16_least)(lPosition - 1);
    }
    else
    {
      /* Use upper half of interval */
      loIdx = (uint16_least)(lPosition + 1);
    }
  }
  /* #80 Otherwise - report nothing found  */

  return lResult;
}
#endif
/**********************************************************************************************************************
 *  Dcm_PagedBufferInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInit(void)
{
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_InstanceContext.PagedBuffer.State = DCM_PAGEDBUFFER_STATE_INACTIVE;
#endif
}

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDefragmentPage()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferDefragmentPage(void)
{
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;
  Dcm_CfgNetBufferSizeOptType   lPageSize;

  lBufferInfo = Dcm_NetGetBufferInfo(Dcm_InstanceContext.PagedBuffer.BufferHdl);
  lPageSize = (Dcm_CfgNetBufferSizeOptType)( Dcm_InstanceContext.PagedBuffer.WriteIndex
                                           - Dcm_InstanceContext.PagedBuffer.ReadIndex);

  Dcm_UtiMemCopySafe(&(lBufferInfo->BufferPtr[Dcm_InstanceContext.PagedBuffer.ReadIndex])
                    ,lBufferInfo->BufferPtr
                    ,0u
                    ,lBufferInfo->Size
                    ,lPageSize);                                                                                                                     /* SBSW_DCM_POINTER_WRITE_BUFFERINFO */

  /* Enter critical section (Reason: Protect against hi-priority task /ISR CopyTxData) */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /* Update Read- and Write-Index */
  Dcm_InstanceContext.PagedBuffer.ReadIndex  = 0u;
  Dcm_InstanceContext.PagedBuffer.WriteIndex = (Dcm_CfgNetBufferSizeMemType)lPageSize;
  /* Leave critical section */
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferUpdatePage()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferUpdatePage(Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;
  Dcm_DiagDataContextType       lDataContext;
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;
  uint8                         lUpdaterDataProvisionState;

  lBufferInfo = Dcm_NetGetBufferInfo(Dcm_InstanceContext.PagedBuffer.BufferHdl);

  Dcm_DebugAssert((Dcm_InstanceContext.PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                  /* COV_DCM_RTM_DEV_DEBUG XF */

  /* If defragmentation needed: */
  if ((Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_WAIT_FOR_DATA)
    &&(Dcm_InstanceContext.PagedBuffer.ReadIndex != 0) )
  {
    Dcm_PagedBufferDefragmentPage();
  }

  /* Derive new data context for the remaining data to be read */
  Dcm_DiagInitDataContext(&lDataContext, lBufferInfo->BufferPtr, lBufferInfo->Size);                                                                 /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */
  Dcm_DiagCommitData(&lDataContext, Dcm_InstanceContext.PagedBuffer.WriteIndex);                                                                     /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

  /* Stronger limitation of the available buffer size - cut to the response length */
  if(lDataContext.AvailLen > Dcm_InstanceContext.PagedBuffer.RemainingLen)
  {
    Dcm_DiagDataContextSetAvailLen(&lDataContext, Dcm_InstanceContext.PagedBuffer.RemainingLen);                                                     /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
  }

  /* Delegate to the page writer */
  lStdResult = Dcm_PagedBufferExecute(&lDataContext, ErrorCode);                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

  switch(lStdResult)
  {
    case DCM_E_OK:
    case DCM_E_NOT_OK:
      Dcm_InstanceContext.PagedBuffer.UpdateFinished = TRUE;
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_ALL_DATA_PROVIDED;
      break;
    case DCM_E_DATA_READY_PADDING:
      Dcm_InstanceContext.PagedBuffer.OpStatus = DCM_INITIAL;
      /* Delegate to the padding writer */
      Dcm_InstanceContext.PagedBuffer.UpdateFuncRef = DCM_PAGEDBUFFER_PADDING_FUNC_REF;
      /* Application is done, now call the padding-bytes provider */
      Dcm_InstanceContext.PagedBuffer.UpdateFinished = TRUE;
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      break;
    case DCM_E_PENDING:
      Dcm_InstanceContext.PagedBuffer.OpStatus = DCM_PENDING;
      /* Data could also be written although DCM_E_PENDING was returned */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      break;
# if (DCM_RUNTIME_USAGE_LIMIT_ENABLED == STD_ON)
    case DCM_E_PENDING_LIMITER:
      /* Keep the last opStatus on "pending" forced by Dcm_PagedBufferExecute code */
      /* Data could also be written although DCM_E_PENDING was returned */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      lStdResult = DCM_E_PENDING;
      break;
# endif
    case DCM_E_BUFFERTOOLOW:
      Dcm_InstanceContext.PagedBuffer.OpStatus = DCM_PENDING;
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      break;
    default:/* Unexpected return value */                                                                                                            /* COV_DCM_RTM_UNREACHABLE X */
      lStdResult = DCM_E_NOT_OK; /* Assure only valid values from here on */
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_InstanceContext.PagedBuffer.UpdateFinished = TRUE;
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_ALL_DATA_PROVIDED;
      break;
  }

  if(lStdResult == DCM_E_NOT_OK)
  {
    if(Dcm_InstanceContext.PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)
    {
      /* Reset paged-buffer usage and delegate to the linear buffer processor */
      Dcm_InstanceContext.PagedBuffer.State = DCM_PAGEDBUFFER_STATE_CANCELED;
    }
    else
    {
      /* Wait for under-run transmission interruption (simulate successful update with zero data size) */
      lStdResult = DCM_E_OK;
    }
    Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState = lUpdaterDataProvisionState;
  }
  else
  {
    /* Enter critical section (Reason: Protect against hi-priority task /ISR CopyTxData) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /* Update statistic */
    Dcm_InstanceContext.PagedBuffer.RemainingLen -= (Dcm_MsgLenType)(lDataContext.Usage - Dcm_InstanceContext.PagedBuffer.WriteIndex);
    Dcm_InstanceContext.PagedBuffer.WriteIndex = (Dcm_CfgNetBufferSizeMemType)lDataContext.Usage;

    /* Unlock CopyTx Data if more data is expected to be provided by a paged-buffer updater */
    Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState = lUpdaterDataProvisionState;

    /* Leave critical section */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* If transmission not yet started and some data is already available for transmission: */
    if ((Dcm_InstanceContext.PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)
      && (lStdResult != DCM_E_PENDING))
    {
      /* Activate transmission */
      Dcm_InstanceContext.PagedBuffer.State = DCM_PAGEDBUFFER_STATE_ONTX;
      Dcm_InstanceContext.Diag.State |= DCM_DIAG_STATE_ON_TX; /* update diagnostic state (PROCESS && ON_TX) */
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_PAGED);
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
                                                                   P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) PduInfo                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,PduLengthType Length)                                                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  BufReq_ReturnType              lResult = BUFREQ_OK;
  PduLengthType                  lPageSize;

  Dcm_DebugAssert((Dcm_InstanceContext.PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE)
                 ,DCM_SID_PROVIDETXBUFFER, DCM_E_ILLEGAL_STATE)                                                                                      /* COV_DCM_RTM_DEV_DEBUG XF */

  /*
   lPageSize |    Length    | PagedBufferState  | lResult |  BufferSize
  -----------+--------------+-------------------+---------+-------------
      0      |     any      | no data available |  BUSY   |  n/a
     != 0    |      0       | data available    |   OK    |  lPageSize
     != 0    | <= lPageSize | data available    |   OK    |  Length
     != 0    | > lPageSize  | too few data      |  BUSY   |  n/a
  */

  /* Calculate and return page size */
  lPageSize = (PduLengthType)(Dcm_InstanceContext.PagedBuffer.WriteIndex - Dcm_InstanceContext.PagedBuffer.ReadIndex);

  if ((Length <= lPageSize) && (lPageSize != 0))
  {
    Dcm_PbCfgNetBufferInfoPtrType lBufferInfo = Dcm_NetGetBufferInfo(Dcm_InstanceContext.PagedBuffer.BufferHdl);

    /* Point sdu data pointer to page buffer read index */
    PduInfo->SduDataPtr = &(lBufferInfo->BufferPtr[Dcm_InstanceContext.PagedBuffer.ReadIndex]);                                                      /* SBSW_DCM_PARAM_PTR_WRITE */

    if (Length == 0)
    {
      /* set sdu length to amount of data available in the page */
      PduInfo->SduLength = lPageSize;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* Set sdu length to the requested length */
      PduInfo->SduLength = Length;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    Dcm_InstanceContext.PagedBuffer.ReadIndex += (Dcm_CfgNetBufferSizeMemType)(PduInfo->SduLength);
  }
  else
  {
    lResult = BUFREQ_E_BUSY; /* avoid coping data during defragmenting of the paged-buffer */

    /* check if paged-buffer update is possible */
    if (Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED)
    {
      Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState = DCM_PAGEDBUFFER_WAIT_FOR_DATA;
      Dcm_TskSetEvent(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE); /* re-activate page updater */
    } /* else - still waiting for the data or all data provided */
  }

  return lResult;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
                                                       P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                      ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  BufReq_ReturnType  lResult = BUFREQ_OK;

  Dcm_DebugAssert((Dcm_InstanceContext.PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_COPYTXDATA
                 ,DCM_E_ILLEGAL_STATE)                                                                                                               /* COV_DCM_RTM_DEV_DEBUG XF */

  *availableDataPtr = (PduLengthType)(Dcm_InstanceContext.PagedBuffer.WriteIndex
                                      - Dcm_InstanceContext.PagedBuffer.ReadIndex); /* Calculate and return page size */                             /* SBSW_DCM_PARAM_PTR_WRITE */

  if( (*availableDataPtr == 0u) /* no data at all */
    ||(*availableDataPtr < info->SduLength) ) /* real under-run */
  {
    if(info->SduLength != 0)
    {
      lResult = BUFREQ_E_BUSY;
    }/* else - just buffer size check */

    if ((Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED)
      &&(Dcm_InstanceContext.PagedBuffer.RemainingLen != 0) )
    {
      Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState = DCM_PAGEDBUFFER_WAIT_FOR_DATA;
      Dcm_TskSetEvent(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE);/* re-activate page updater */
    }/* else - still waiting for the data or all data provided */
  }
  else /* (lPageSize != 0) && (lPageSize >= info->SduLength) => <check buffer availability> */
  {
    if ((Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_WAIT_FOR_DATA) /* still waiting for data OR data is currently being written */
      &&(Dcm_InstanceContext.PagedBuffer.ReadIndex != 0) /* with needed defragmentation */
      &&(info->SduLength != 0) )/* no buffer availability check request */
    {
      lResult = BUFREQ_E_BUSY;/* avoid coping data during defragmentation of the paged-buffer (i.e. in case of adaptive CopyTxData call with reducing SduLength each time, or when SduLength == 0, and immediately called again with SduLength != 0 */
    }
    else
    {
      Dcm_PbCfgNetBufferInfoPtrType lBufferInfo = Dcm_NetGetBufferInfo(Dcm_InstanceContext.PagedBuffer.BufferHdl);

      *availableDataPtr -= info->SduLength; /* Update remained data part */                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Take the linear case always */
      Dcm_UtiMemCopySafe(&(lBufferInfo->BufferPtr[Dcm_InstanceContext.PagedBuffer.ReadIndex])
                        ,info->SduDataPtr
                        ,0u
                        ,info->SduLength
                        ,info->SduLength);                                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_InstanceContext.PagedBuffer.ReadIndex += (Dcm_CfgNetBufferSizeMemType)(info->SduLength);
    }
  }
  return lResult;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrInit(void)
{
  uint8_least lIter;

  for(lIter = 0; lIter < DCM_DIDMGR_DID_LOCK_LIST_SIZE; ++lIter)
  {
    Dcm_InstanceContext.DidMgr.DidLockList[lIter].Did   = 0u;                                                                                        /* SBSW_DCM_POINTER_WRITE_DIDLOCKLIST */
    Dcm_InstanceContext.DidMgr.DidLockList[lIter].Owner = DCM_DIDMGR_DIDLOCK_OWNER_NONE;                                                             /* SBSW_DCM_POINTER_WRITE_DIDLOCKLIST */
  }

# if (DCM_DIDMGR_IODID_NBYTE_EXT_CEMR_ENABLED == STD_ON)
  /* Set default ReturnControlToEcu values to 0xFF...FF */
  Dcm_UtiMemSetUintX(Dcm_InstanceContext.DidMgr.IoControlCemrSessionMask                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_POINTER_WRITE_IO_CTRL_CEMR_SESSION_MASK */
                    ,Dcm_MsgItemType
                    ,0xFFu
                    ,DCM_DIDMGR_IODID_MAX_EXT_CEMR_SIZE);
# endif
}

/**********************************************************************************************************************
 *  Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrSignalOpClassInfoPtrType, DCM_CODE) Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(
                                                                        Dcm_CfgDidMgrSignalOpClassRefOptType opInfoRef)
{
  Dcm_DidMgrSignalOpClassInfoPtrType lDidSignalOpInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(opInfoRef >= DCM_CFGDIDMGRSIGNALOPCLASSINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGDIDMGRSIGNALOPCLASSINFOGETENTRY);
    lDidSignalOpInfo = NULL_PTR;
  }
  else
# endif
  {
    lDidSignalOpInfo = &Dcm_CfgDidMgrSignalOpClassInfo[opInfoRef];
  }

  return lDidSignalOpInfo;
}

/**********************************************************************************************************************
 *  Dcm_CfgDidMgrDidOpClassInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrDidOpClassInfoPtrType, DCM_CODE) Dcm_CfgDidMgrDidOpClassInfoGetEntry(
                                                                        Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef)
{
  Dcm_DidMgrDidOpClassInfoPtrType pOpClassInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(opInfoRef >= DCM_CFGDIDMGRDIDOPCLASSINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGDIDMGRDIDOPCLASSINFOGETENTRY);
    pOpClassInfo = &Dcm_CfgDidMgrDidOpClassInfo[0];
  }
  else
# endif
  {
    pOpClassInfo = &Dcm_CfgDidMgrDidOpClassInfo[opInfoRef];
  }

  return pOpClassInfo;
}

# if (DCM_DIDMGR_SR_IO_CONTROL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrIoCtrlSRHandlersPtrType, DCM_CODE) Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry(
                                                         Dcm_CfgDidMgrIoCtrlSRHandlersRefOptType ioControlSRHandlerRef)
{
  Dcm_DidMgrIoCtrlSRHandlersPtrType pIoControlSrHandlers;

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(ioControlSRHandlerRef >= DCM_CFGDIDMGR_IOCONTROLSENDERRECEIVERHANDLERS_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGDIDMGRIOCONTROLGETSENDERRECEIVERHANDLERS);
    pIoControlSrHandlers = &(Dcm_CfgDidMgr_IOControlSenderReceiverHandlers[0]);
  }
  else
#  endif
  {
    pIoControlSrHandlers = &(Dcm_CfgDidMgr_IOControlSenderReceiverHandlers[ioControlSRHandlerRef]);
  }

  return pIoControlSrHandlers;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrGetSignalLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetSignalLength(
                                                                   Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_CfgNetBufferSizeOptType        lSignalLength;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(pSignalOpClassInfo == NULL_PTR)
  {
    lSignalLength = 0u;
  }
  else
#  endif
  {
    /* If the signal has a variable length: */
    if(pSignalOpClassInfo->MinLength == 0u)
    {
      /* Calculate the length of the signal. A signal with variable length is always the last signal of the DID */
      lSignalLength = (Dcm_CfgNetBufferSizeOptType)(pDidInfoContext->DidLength - pDidOpTypeContext->OpType.Read.Progress);
    }
    else
    {
      /* Otherwise return the signal length */
      lSignalLength = (Dcm_CfgNetBufferSizeOptType)pSignalOpClassInfo->MinLength;
    }
  }

  return lSignalLength;
}
# endif

# if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidRangeGap()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidRangeGap(Dcm_OpStatusType         opStatus
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)
{
  Std_ReturnType lStdResult = DCM_E_OK;

  /* #10 If the DID range supports gaps: */
  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext), DCM_DIDMGR_OPTYPE_RANGEISDIDAVAILABLE))
  {
    Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;
    Dcm_DidSupportedType               lIsAvailable = DCM_DID_NOT_SUPPORTED;

    /* #20 Execute operation for evaluation gap match */
    Dcm_DidMgrInitOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_RANGEISDIDAVAILABLE);                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

    pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    if(pSignalOpClassInfo == NULL_PTR)
    {
      lStdResult = DCM_E_NOT_OK;
    }
    else
#  endif
    {
      Dcm_DebugAssert(pSignalOpClassInfo->FuncClass == DCM_DIDMGR_OPCLS_ISDIDAVAILABLE
                     ,DCM_SID_INTERNAL
                     ,DCM_E_ILLEGAL_STATE)

      lStdResult = ((Dcm_DidMgrOpFuncRangeIsAvailDidType)pSignalOpClassInfo->OpFunc)(pDidInfoContext->Did                                            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,opStatus
                                                                                    ,&lIsAvailable);                                                 /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_PARAM_PTR_FORWARD */

      /* #30 If operation needs more time (DCM_E_PENDING) or acknowledges that the DID is still valid: */
      if( ( (lStdResult == DCM_E_OK)
          &&(lIsAvailable == DCM_DID_SUPPORTED) )
        ||(lStdResult == DCM_E_PENDING) )
      {
        /* #40 Return the current/final result: DCM_E_PENDING, DCM_E_OK */
      }
      else
      {
        /* #50 Otherwise: notify caller for range DID match but still DID invalid since in a gap */
        lStdResult = DCM_E_LOOKUP_MATCH_FOUND;
      }
    }
  }
  /* #60 Otherwise: all DIDs within that range are valid: return DCM_E_OK */
  return lStdResult;
}
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDidRangeLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDidRangeLookUp(Dcm_OpStatusType              opStatus
                                                                    ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                    ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_DidMgrOpOptType               didOp)
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
  lStdReturn = DCM_E_OK;

  /* #10 On the very first call: */
  if(opStatus == DCM_INITIAL)
#  endif
  {
    sint16_least lResult;

    lStdReturn = DCM_E_NOT_OK;

    /* #20 Try finding a range that encloses this DID */
    lResult = Dcm_UtiLookUpRangeUint16(Dcm_CfgDidMgrDidRanges, pDidInfoContext->Did);                                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    /* #30 If a match found:  */
    if(lResult >= 0)
    {
      Dcm_DidMgrDidInfoPtrType pDidInfo = &(Dcm_CfgDidMgrDidInfo[Dcm_CfgDidMgrRangeDidInfoRefs[lResult]]);

      /* #40 If the matched range supports the requested DID operation: */
      if(Dcm_DidMgrIsOpSupported(pDidInfo, didOp))
      {
        /* #50 Prepare for positive final result; initialize DID context */
        pDidInfoContext->Descriptor.DidInfoIdx = Dcm_CfgDidMgrRangeDidInfoRefs[lResult];                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
        /* Set DID length. Later the concrete length will be stored here. Take the maximum length! */
        pDidInfoContext->DidLength      = pDidInfo->MaxLength;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
        pDidInfoContext->ReservedLength = pDidInfo->ReservedLength;                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
        /* Store DID operation information */
        Dcm_DidMgrInitOpInfo(pDidInfoContext, didOp);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

        lStdReturn = DCM_E_OK;
      }
      /* #60 Otherwise: Operation not supported -> DID not supported in context of the requested operation */
    }
  }
  /* #65 Otherwise: keep current result: DCM_E_OK */

#  if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
  /* #70 If DID match found: */
  if(lStdReturn == DCM_E_OK)
  {
    /* #80 Process potentially available DID range gaps, resp. re-call any pending operation */
    lStdReturn = Dcm_DidMgrFilterDidRangeGap(opStatus, pDidInfoContext, pDidOpTypeContext);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  /* #90 Otherwise: return final result: DCM_E_NOT_OK, DCM_E_PENDING */
#  endif

  return lStdReturn;
}
# endif

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON) && \
     (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetRequiredSignalBufSize()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetRequiredSignalBufSize(
                                                              Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                             ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_CfgNetBufferSizeOptType        lSignalLength;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                           /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(pSignalOpClassInfo == NULL_PTR)
  {
    lSignalLength = (Dcm_CfgNetBufferSizeOptType)Dcm_UtiMaxValueOfUintType(Dcm_CfgNetBufferSizeMemType);
  }
  else
#  endif
  {
    /* If the signal is part of a paged DID (Note: OpClass needs to be set -> precondition) */
    if (pSignalOpClassInfo->FuncClass == DCM_DIDMGR_OPCLS_READ_PAGED)
    {
      /* Return size of dedicated read buffer as it determines the page size */
      lSignalLength = (Dcm_CfgNetBufferSizeOptType)DCM_DIDMGR_READ_PAGE_SIZE;
    }
    else /* Signal cannot be part of a DynDID because DynDIDs are not allowed when paged buffer is enabled */
    {
      /* Return the maximal signal length */
      lSignalLength = (Dcm_CfgNetBufferSizeOptType)pSignalOpClassInfo->MaxLength;
    }
  }

  return lSignalLength;
}
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfoSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfoSignal(Dcm_OpStatusType        opStatus
                                                                    ,Dcm_MsgContextPtrType             pMsgContext                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pSignalOpClassInfo == NULL_PTR)                                                                                                               /* PRQA S 3415 */ /* MD_Dcm_3415 */
    ||(Dcm_DiagMsgContextVerifySize(pMsgContext, pSignalOpClassInfo->MaxLength) == FALSE) )                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
    switch(pSignalOpClassInfo->FuncClass)
    {
    case DCM_DIDMGR_OPCLS_GETSCALING_SYNC:
      DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */
      lStdResult = ((Dcm_DidMgrOpFuncGetScalingInfoSyncType)pSignalOpClassInfo->OpFunc)(Dcm_DiagGetResData(pMsgContext)                              /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                                       ,ErrorCode);                                                  /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
      break;
    case DCM_DIDMGR_OPCLS_GETSCALING_ASYNC:
      lStdResult = ((Dcm_DidMgrOpFuncGetScalingInfoAsyncType)pSignalOpClassInfo->OpFunc)(opStatus                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                        ,Dcm_DiagGetResData(pMsgContext)                             /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                                        ,ErrorCode);                                                 /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
      break;
    default:
      DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */
      DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                           /* PRQA S 3112 */ /* MD_Dcm_3112 */
      DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                       /* PRQA S 3112 */ /* MD_Dcm_3112 */

      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
#  endif

    if (lStdResult == DCM_E_OK)
    {
      Dcm_DiagProvideResData(pMsgContext, pSignalOpClassInfo->MaxLength);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    } /* Catch any RTE or unexpected specific errors */
    else if( (lStdResult != DCM_E_NOT_OK)
           &&(lStdResult != DCM_E_PENDING)
      )
    {
      Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
    {
      /* Do nothing */
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfo(Dcm_OpStatusType            opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  do
  {
    lStdResult = Dcm_DidMgrGetScalingInfoSignal(opStatus
                                               ,pMsgContext
                                               ,pDidInfoContext
                                               ,pDidOpTypeContext
                                               ,ErrorCode);                                                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    if(lStdResult == DCM_E_OK)
    {
      pDidOpTypeContext->Base.NumSignals--;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

      if(pDidOpTypeContext->Base.NumSignals == 0u)
      {
        break;
      }

      /* Go on with next signal */
      pDidOpTypeContext->Base.SignalOpClassInfoRef++;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      opStatus = DCM_INITIAL; /* reset op status */
    }
  }
  while(lStdResult == DCM_E_OK);

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWriteSignal(Dcm_OpStatusType               opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(pSignalOpClassInfo == NULL_PTR)
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
    switch(pSignalOpClassInfo->FuncClass)
    {
#  if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
    case DCM_DIDMGR_OPCLS_WRITE_RANGE:
      lStdResult = ((Dcm_DidMgrOpFuncWriteDidRangeType)pSignalOpClassInfo->OpFunc)(pDidInfoContext->Did                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                       ,Dcm_DiagGetReqData(pMsgContext)
                                                                       ,opStatus
                                                                       ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                       ,ErrorCode);                                                                  /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
      break;
#  endif
    case DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_NRES_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncWriteLenSyncNResErrorType)pSignalOpClassInfo->OpFunc)(                                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        Dcm_DiagGetReqData(pMsgContext)
                                                                       ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                       ,ErrorCode);                                                                  /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_WRITE_LEN_ASYNC_NRES_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncWriteLenAsyncNResErrorType)pSignalOpClassInfo->OpFunc)(                                                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        Dcm_DiagGetReqData(pMsgContext)
                                                                       ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                       ,opStatus
                                                                       ,ErrorCode);                                                                  /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncWriteNLenSyncNResErrorType)pSignalOpClassInfo->OpFunc)(                                                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                         Dcm_DiagGetReqData(pMsgContext)
                                                                                        ,ErrorCode);                                                 /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_WRITE_NLEN_ASYNC_NRES_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncWriteNLenAsyncNResErrorType)pSignalOpClassInfo->OpFunc)(                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                         Dcm_DiagGetReqData(pMsgContext)
                                                                                        ,opStatus
                                                                                        ,ErrorCode);                                                 /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
      break;
#  if (DCM_DIDMGR_SR_SUPPORT_ENABLED == STD_ON) || (DCM_DIDMGR_ATOMIC_NV_DATA_SUPPORT_ENABLED == STD_ON)
    case DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_NERROR:
      lStdResult = ((Dcm_DidMgrOpFuncWriteNLenSyncNResNErrorType)pSignalOpClassInfo->OpFunc)(                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
                                                                                       Dcm_DiagGetReqData(pMsgContext));

      if(lStdResult != DCM_E_OK)
      {
        *ErrorCode = DCM_E_GENERALPROGRAMMINGFAILURE; /* set write operation failed */                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
      break;
#  endif
#  if (DCM_DIDMGR_WRITE_SUPPORTEDDID_ENABLED == STD_ON)
    case DCM_DIDMGR_OPCLS_WRITE_WRAPPER:
      lStdResult = ((Dcm_DidMgrOpFuncWriteWrapperType)pSignalOpClassInfo->OpFunc)(pMsgContext                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,ErrorCode);                                                        /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
      break;
#  endif
    case DCM_DIDMGR_OPCLS_WRITE_GAP:
      /* Just a gap, do nothing */
      lStdResult = DCM_E_OK;
      break;

    default:
      DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */
      DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                           /* PRQA S 3112 */ /* MD_Dcm_3112 */
      DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                       /* PRQA S 3112 */ /* MD_Dcm_3112 */
      DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */

      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
#  endif

    if(lStdResult == DCM_E_OK)
    {
      /* Consuming request data is not necessary for the last signal. */
      if(pSignalOpClassInfo->MinLength != 0u)
      {
        Dcm_DiagConsumeReqData(pMsgContext, pSignalOpClassInfo->MaxLength);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }

    /* Catch any RTE or unexpected specific errors */
    if( (lStdResult != DCM_E_OK)
      &&(lStdResult != DCM_E_PENDING)
      &&(lStdResult != DCM_E_NOT_OK)
      )
    {
      Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWrite()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWrite(Dcm_OpStatusType                  opStatus
                                                               ,Dcm_MsgContextPtrType             pMsgContext
                                                               ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                               ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                               ,Dcm_NegativeResponseCodePtrType   ErrorCode)                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  do
  {
    lStdResult = Dcm_DidMgrWriteSignal(opStatus
                                      ,pMsgContext
                                      ,pDidInfoContext
                                      ,pDidOpTypeContext
                                      ,ErrorCode);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    if(lStdResult == DCM_E_OK)
    {
      pDidOpTypeContext->Base.NumSignals--;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

      if(pDidOpTypeContext->Base.NumSignals == 0u)
      {
        break;
      }

      /* Go on with next signal */
      pDidOpTypeContext->Base.SignalOpClassInfoRef++;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      opStatus = DCM_INITIAL; /* reset op status */
    }
  }
  while(lStdResult == DCM_E_OK);

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2EcuSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(
                                                                        Dcm_CfgDidMgrSignalOpClassRefOptType opInfoRef)
{
  Std_ReturnType                     lStdResult;
  Dcm_NegativeResponseCodeType       lNrc;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(opInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(pSignalOpClassInfo == NULL_PTR)                                                                                                                 /* PRQA S 3415 */ /* MD_Dcm_3415 */
  {
    lStdResult = DCM_E_NOT_OK;
  }
  else
#  endif
  {
    switch(pSignalOpClassInfo->FuncClass)
    {
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                      &lNrc);                                                        /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(DCM_INITIAL                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                      ,&lNrc);                                                       /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(0xFFu                                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                     ,&lNrc);                                                        /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(DCM_INITIAL                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                      ,0xFFu
                                                                                      ,&lNrc);                                                       /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(0xFFFFu                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                      ,&lNrc);                                                       /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(DCM_INITIAL                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                       ,0xFFFFu
                                                                                       ,&lNrc);                                                      /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(0xFFFFFFFFUL                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                      ,&lNrc);                                                       /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(DCM_INITIAL                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                       ,0xFFFFFFFFUL
                                                                                       ,&lNrc);                                                      /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
#  if (DCM_DIDMGR_IODID_NBYTE_EXT_CEMR_ENABLED == STD_ON)
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                     Dcm_InstanceContext.DidMgr.IoControlCemrSessionMask
                                                                    ,&lNrc);                                                                         /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(DCM_INITIAL                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                    ,Dcm_InstanceContext.DidMgr.IoControlCemrSessionMask
                                                                    ,&lNrc);                                                                         /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
#  endif
    default:
      DCM_IGNORE_UNREF_PARAM(opInfoRef);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */

      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }
    Dcm_DebugApiCheckRte(lStdResult != DCM_E_PENDING, DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

    /*
    No need to handle application NRC since not used!
    Dcm_DiagHandleApplNrc(lStdResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);
    */
  }
  DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
}                                                                                                                                                    /* PRQA S 6030 */ /* MD_MSR_STCYC */
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2Ecu()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef)
{
  Dcm_CfgDidMgrSignalOpClassRefOptType lSignalIter;

  for(lSignalIter = Dcm_CfgDidMgrDidOpClassInfoGetEntry(opInfoRef + 0)->OpClassRef;
      lSignalIter < Dcm_CfgDidMgrDidOpClassInfoGetEntry(opInfoRef + 1)->OpClassRef;
      ++lSignalIter)
  {
    Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(lSignalIter);
  }
}
# endif

# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlSignal(Dcm_OpStatusType           opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pSignalOpClassInfo == NULL_PTR)                                                                                                               /* PRQA S 3415 */ /* MD_Dcm_3415 */
    ||(Dcm_DiagMsgContextVerifySize(pMsgContext, pSignalOpClassInfo->MaxLength) == FALSE) )                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
    switch(pSignalOpClassInfo->FuncClass)
    {
  /* No CEMR */
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(ErrorCode);                                            /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(opStatus                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                              ,ErrorCode);                                           /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_NCEMR_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                         Dcm_DiagGetReqData(pMsgContext)
                                                                                        ,ErrorCode);                                                 /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_NCEMR_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(                                                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        Dcm_DiagGetReqData(pMsgContext)
                                                                       ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                       ,ErrorCode);                                                                  /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_NCEMR_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                         Dcm_DiagGetReqData(pMsgContext)
                                                                                        ,opStatus
                                                                                        ,ErrorCode);                                                 /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_NCEMR_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        Dcm_DiagGetReqData(pMsgContext)
                                                                       ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                       ,opStatus
                                                                       ,ErrorCode);                                                                  /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
  /* CEMR 8Bit */
#  if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                             (uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                            ,ErrorCode);                                                                             /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(opStatus                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                            ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                            ,ErrorCode);                                                                             /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR8_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                            ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                            ,ErrorCode);                                                                             /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR8_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                            ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                            ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                            ,ErrorCode);                                                                             /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR8_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                            ,opStatus
                                                            ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                            ,ErrorCode);                                                                             /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR8_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                            ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                            ,opStatus
                                                            ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                            ,ErrorCode);                                                                             /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;

  /* CEMR 16Bit */
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                            (uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                           ,ErrorCode);                                                                              /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(opStatus                                             /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                           ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                           ,ErrorCode);                                                                              /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR16_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                           ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                           ,ErrorCode);                                                                              /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR16_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                            Dcm_DiagGetReqData(pMsgContext)
                                                           ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                           ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                           ,ErrorCode);                                                                              /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR16_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                            Dcm_DiagGetReqData(pMsgContext)
                                                           ,opStatus
                                                           ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                           ,ErrorCode);                                                                              /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR16_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                            Dcm_DiagGetReqData(pMsgContext)
                                                           ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                           ,opStatus
                                                           ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                           ,ErrorCode);                                                                              /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;

  /* CEMR 32Bit */
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                    pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                   ,ErrorCode);                                                                      /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(opStatus                                             /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                   ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                   ,ErrorCode);                                                                      /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR32_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                    Dcm_DiagGetReqData(pMsgContext)
                                                                   ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                   ,ErrorCode);                                                                      /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR32_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                    Dcm_DiagGetReqData(pMsgContext)
                                                                   ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                   ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                   ,ErrorCode);                                                                      /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR32_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                    Dcm_DiagGetReqData(pMsgContext)
                                                                   ,opStatus
                                                                   ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                   ,ErrorCode);                                                                      /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR32_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                    Dcm_DiagGetReqData(pMsgContext)
                                                                   ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                   ,opStatus
                                                                   ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                   ,ErrorCode);                                                                      /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
  /* CEMR NBit */
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                              pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                             ,ErrorCode);                                                            /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(opStatus                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                             ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                             ,ErrorCode);                                                            /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMRN_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                              Dcm_DiagGetReqData(pMsgContext)
                                                                             ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                             ,ErrorCode);                                                            /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMRN_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(                                                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        Dcm_DiagGetReqData(pMsgContext)
                                                                       ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                       ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                       ,ErrorCode);                                                                  /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMRN_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                              Dcm_DiagGetReqData(pMsgContext)
                                                                             ,opStatus
                                                                             ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                             ,ErrorCode);                                                            /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMRN_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        Dcm_DiagGetReqData(pMsgContext)
                                                                       ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                       ,opStatus
                                                                       ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                       ,ErrorCode);                                                                  /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
#  endif
    case DCM_DIDMGR_OPCLS_IO_GAP:
      /* Just a gap, do nothing */
      lStdResult = DCM_E_OK;
      break;
#  if (DCM_DIDMGR_WRITE_SUPPORTEDDID_ENABLED == STD_ON)
    case DCM_DIDMGR_OPCLS_IO_WRAPPER:
      lStdResult = ((Dcm_DidMgrOpFuncIoWrapperType)pSignalOpClassInfo->OpFunc)(pMsgContext                                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                              ,ErrorCode);                                                           /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
#  endif
    default:
      DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */
      DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                           /* PRQA S 3112 */ /* MD_Dcm_3112 */
      DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                       /* PRQA S 3112 */ /* MD_Dcm_3112 */
      DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */

      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
#  endif

    if(lStdResult == DCM_E_OK)
    {
      /* Consuming request data is not necessary for the dynamic signal because it is the last signal */
      if(pSignalOpClassInfo->MinLength != 0u)
      {
        Dcm_DiagConsumeReqData(pMsgContext, pSignalOpClassInfo->MaxLength);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }

    /* Catch any RTE or unexpected specific errors */
    if( (lStdResult != DCM_E_OK)
      &&(lStdResult != DCM_E_PENDING)
      &&(lStdResult != DCM_E_NOT_OK)
      )
    {
      Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }

    Dcm_DiagHandleApplNrc(lStdResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
# endif

# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControl(Dcm_OpStatusType                  opStatus
                                                                   ,Dcm_MsgContextPtrType             pMsgContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

#  if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_INT_CEMR_ENABLED == STD_ON)
  if(Dcm_DidMgrGetCtrlEnblMaskHandling(Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)) == DCM_DIDMGR_IO_CEMR_HANDLING_INTERNAL)
  {
    lStdResult = Dcm_DidMgrIoControlWithMask(opStatus, pMsgContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
#  endif
  {
    while(pDidOpTypeContext->Base.NumSignals != 0u)
    {
      lStdResult = Dcm_DidMgrIoControlSignal(opStatus
                                            ,pMsgContext
                                            ,pDidInfoContext
                                            ,pDidOpTypeContext
                                            ,ErrorCode);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(lStdResult != DCM_E_OK)
      {
        /* on pending or not OK -> just leave */
        break;
      }

      pDidOpTypeContext->Base.NumSignals--;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      if(pDidOpTypeContext->Base.NumSignals != 0u)
      {
        /* Go on with next signal */
        pDidOpTypeContext->Base.SignalOpClassInfoRef++;                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      opStatus = DCM_INITIAL; /* reset op status */
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_INT_CEMR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlWithMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlWithMask(Dcm_OpStatusType         opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   ErrorCode)

{
  Std_ReturnType lStdResult = DCM_E_OK;

  if(opStatus == DCM_INITIAL)
  {
    /* DID handler is already initialized in Dcm_DidMgrIoControl() */
    pDidOpTypeContext->OpType.Io.OperExecuted= FALSE;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    pDidOpTypeContext->OpType.Io.SignalIter  = 0u;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    pDidOpTypeContext->OpType.Io.BitScanner  = 0x80u;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  DCM_UTI_LOOP_FOR_EVER
  {
    if(Dcm_UtiBitOpTest(Dcm_MsgItemType
                       ,pDidOpTypeContext->OpType.Io.EnableMaskPtr[0]
                       ,pDidOpTypeContext->OpType.Io.BitScanner))
    {
      pDidOpTypeContext->OpType.Io.OperExecuted = TRUE;                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */

      lStdResult = Dcm_DidMgrIoControlSignal(opStatus
                                            ,pMsgContext
                                            ,pDidInfoContext
                                            ,pDidOpTypeContext
                                            ,ErrorCode);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

      if(lStdResult != DCM_E_OK)
      {
        break;
      }
    }
    else
    {
      /* signal not allowed -> skip */
      Dcm_DiagConsumeReqData(pMsgContext
                            ,Dcm_CfgDidMgrSignalOpClassInfo[pDidOpTypeContext->Base.SignalOpClassInfoRef].MaxLength);                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    }

    pDidOpTypeContext->OpType.Io.SignalIter++;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    if(pDidOpTypeContext->OpType.Io.SignalIter >= pDidOpTypeContext->Base.NumSignals)
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }

    /* next signal */
    /* Gaps are not considered as signals by control enable mask, so skip them here */
    if(Dcm_CfgDidMgrSignalOpClassInfo[pDidOpTypeContext->Base.SignalOpClassInfoRef].FuncClass != DCM_DIDMGR_OPCLS_IO_GAP)
    {
      pDidOpTypeContext->OpType.Io.BitScanner >>= 1;                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      if(pDidOpTypeContext->OpType.Io.BitScanner == 0)
      {
        pDidOpTypeContext->OpType.Io.BitScanner = 0x80u;                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
        Dcm_UtiNextItemByPtr(pDidOpTypeContext->OpType.Io.EnableMaskPtr,1);                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }

    /* Go on with next signal */
    pDidOpTypeContext->Base.SignalOpClassInfoRef++;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    opStatus = DCM_INITIAL;/* reset op status */
  }

  if(pDidOpTypeContext->OpType.Io.OperExecuted == FALSE)
  {
    /* the enable mask record did not enable any signal */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010 */ /* MD_MSR_STPTH */
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalRange()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalRange(Dcm_OpStatusType            opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;
  Dcm_DidMgrDidLengthType            lResLength = 0u; /* Set just in case not set by application */

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pSignalOpClassInfo == NULL_PTR)                                                                                                               /* PRQA S 3415 */ /* MD_Dcm_3415 */
    ||(Dcm_DiagDataContextVerifySize(pDataContext, pSignalOpClassInfo->MaxLength) == FALSE) )                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
    /* Call the appropriate application callback for that DID range signal */
    lStdResult = ((Dcm_DidMgrOpFuncReadDidRangeType)pSignalOpClassInfo->OpFunc)(pDidInfoContext->Did                                                 /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                             ,Dcm_DiagGetDataContextBuffer(pDataContext)
                                                                             ,opStatus
                                                                             ,&lResLength
                                                                             ,ErrorCode);                                                            /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)
    {
      /* Update final response length only in positive/final case */
#  if(DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if(lResLength > pDidInfoContext->DidLength)
      {
        lStdResult = DCM_E_NOT_OK;
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        Dcm_DebugReportError(DCM_SID_SVCPORT_DATASVCS_OP_READDIDRANGE, DCM_E_INTERFACE_BUFFER_OVERFLOW);
      }
      else
#  endif
      {
        pDidInfoContext->DidLength = lResLength;/* update current DID length */                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */

        Dcm_DiagCommitData(pDataContext, lResLength);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }
  }
  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalAsync()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalAsync(Dcm_OpStatusType            opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pSignalOpClassInfo == NULL_PTR)                                                                                                               /* PRQA S 3415 */ /* MD_Dcm_3415 */
    ||(Dcm_DiagDataContextVerifySize(pDataContext, pSignalOpClassInfo->MaxLength) == FALSE) )                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
    /* Call the appropriate application callback for that asynchronous signal */
    lStdResult = ((Dcm_DidMgrOpFuncReadAsyncType)pSignalOpClassInfo->OpFunc)(opStatus                                                                /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                           ,Dcm_DiagGetDataContextBuffer(pDataContext));                             /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

    if(lStdResult == DCM_E_OK)
    {
      Dcm_CfgNetBufferSizeOptType lSignalLen;

      /* Update the remaining available length */
      lSignalLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagCommitData(pDataContext, lSignalLen);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else if(lStdResult == DCM_E_NOT_OK)
    {
      /* Handle NRC here since no NRC can be passed by the application on this interface */
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* Nothing to do */
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalSync()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalSync(Dcm_OpStatusType             opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pSignalOpClassInfo == NULL_PTR)                                                                                                               /* PRQA S 3415 */ /* MD_Dcm_3415 */
    ||(Dcm_DiagDataContextVerifySize(pDataContext, pSignalOpClassInfo->MaxLength) == FALSE) )                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
    /* Call the appropriate application callback for that synchronous signal */
    lStdResult = ((Dcm_DidMgrOpFuncReadSyncType)pSignalOpClassInfo->OpFunc)(Dcm_DiagGetDataContextBuffer(pDataContext));                             /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

    if(lStdResult == DCM_E_OK)
    {
      Dcm_CfgNetBufferSizeOptType lSignalLen;

      /* Update the remaining available length */
      lSignalLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagCommitData(pDataContext, lSignalLen);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* Handle NRC here since no NRC can be passed by the application through this interface */
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalPaged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalPaged(Dcm_OpStatusType            opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrDidLengthType            lTmpAvailLen;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;
#  if (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED == STD_ON)                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  boolean                            lLoopPossible;
#  endif

  DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                           /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pSignalOpClassInfo == NULL_PTR)                                                                                                               /* PRQA S 3415 */ /* MD_Dcm_3415 */
#   if (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED == STD_ON)                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    ||(Dcm_DiagDataContextVerifySize(pDataContext, DCM_DIDMGR_READ_PAGE_SIZE) == FALSE)                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
#   endif
    )
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
    lTmpAvailLen = (Dcm_DidMgrDidLengthType)pDataContext->AvailLen;
#  if (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED == STD_ON)                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    if (lTmpAvailLen > DCM_DIDMGR_READ_PAGE_SIZE)
    {
      lTmpAvailLen = DCM_DIDMGR_READ_PAGE_SIZE;
      lLoopPossible = TRUE;
    }
    else
    {
      lLoopPossible = FALSE;
    }
#  endif

    /* Call the appropriate application callback for that paged signal */
    lStdResult = ((Dcm_DidMgrOpFuncReadPagedDidType)pSignalOpClassInfo->OpFunc)(opStatus                                                             /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                             ,Dcm_DiagGetDataContextBuffer(pDataContext)
                                                                             ,&lTmpAvailLen);                                                        /* SBSW_DCM_COMB_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */

    switch (lStdResult)
    {
      case DCM_E_BUFFERTOOLOW:
#  if (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED == STD_ON)                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
        if (lLoopPossible == TRUE)
        {
          lStdResult = DCM_E_LOOP;
        }
#  endif
        /* fall through */
      case DCM_E_OK:                                                                                                                                 /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
        Dcm_DiagCommitData(pDataContext, lTmpAvailLen);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
        break;

      case DCM_E_NOT_OK:
        /* Handle NRC here since no NRC can be passed by the application on this interface */
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        break;

      default:
        /* Nothing to do */
        break;
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_VID_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalVid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalVid(Dcm_OpStatusType              opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pSignalOpClassInfo == NULL_PTR)                                                                                                               /* PRQA S 3415 */ /* MD_Dcm_3415 */
    ||(Dcm_DiagDataContextVerifySize(pDataContext, pSignalOpClassInfo->MaxLength) == FALSE) )                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
    uint8 lResLength = (uint8)pSignalOpClassInfo->MaxLength;

    /* Call the appropriate application callback for that VID signal */
    lStdResult = ((Dcm_DidMgrOpFuncReadVidType)pSignalOpClassInfo->OpFunc)(opStatus                                                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                          ,Dcm_DiagGetDataContextBuffer(pDataContext)
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
                                                                          ,&lResLength
#  endif
                                                                          );                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_COMB_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */

    /* Handle NRC here since no NRC can be passed by the application on this interface */
    if(lStdResult == DCM_E_OK)
    {
      /* If VID signal with dynamic length supported (Autosar Version >= 4.2.2) */
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
      /* Update final response length only in positive/final case */
#   if(DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if( (lResLength == 0) /* At least the NODI byte has to be written */
        ||(lResLength > pSignalOpClassInfo->MaxLength) )
      {
        lStdResult = DCM_E_NOT_OK;
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        Dcm_DebugReportError(DCM_SID_SVCPORT_DATASVCS_OP_READVID, DCM_E_INTERFACE_BUFFER_OVERFLOW);
      }
      else
#   endif
#  endif
      {
        /* Decrement length of signal if NODI byte reporting disabled */
#  if (DCM_DIDMGR_REPORT_NODIBYTE_ENABLED == STD_OFF)
        lResLength--;

        /* Remove NODI byte from VID signal if NODI byte reporting disabled */
        Dcm_DiagProvideDataAsUN(pDataContext, &Dcm_DiagGetDataContextBuffer(pDataContext)[1], lResLength);                                           /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_COMB_PTR_FORWARD */
#  else
        Dcm_DiagCommitData(pDataContext, lResLength);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif

        pDidInfoContext->DidLength = lResLength; /* Update current DID length */                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
    else if(lStdResult == DCM_E_PENDING)
    {
      /* Retry later */
    }
    else
    {
      Dcm_DebugApiCheckRte((lStdResult == DCM_E_NOT_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_SR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalSR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalSR(Dcm_OpStatusType               opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pSignalOpClassInfo == NULL_PTR)                                                                                                               /* PRQA S 3415 */ /* MD_Dcm_3415 */
    ||(Dcm_DiagDataContextVerifySize(pDataContext, pSignalOpClassInfo->MaxLength) == FALSE) )                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
    /* Call the appropriate application callback for that SR signal */
    lStdResult = ((Dcm_DidMgrOpFuncReadSRType)pSignalOpClassInfo->OpFunc)(pDataContext);                                                             /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)
    {
      Dcm_CfgNetBufferSizeOptType lSignalLen;

      /* Update the remaining available length */
      lSignalLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagCommitData(pDataContext, lSignalLen);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* Handle NRC here since no NRC can be passed by the application through this interface */
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalWrapper()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalWrapper(Dcm_OpStatusType          opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pSignalOpClassInfo == NULL_PTR)                                                                                                               /* PRQA S 3415 */ /* MD_Dcm_3415 */
    ||(Dcm_DiagDataContextVerifySize(pDataContext, pSignalOpClassInfo->MaxLength) == FALSE) )                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
    /* Call the appropriate application callback for that asynchronous signal */
    lStdResult = ((Dcm_DidMgrOpFuncReadWrapperType)pSignalOpClassInfo->OpFunc)(pDidInfoContext->Did                                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                              ,opStatus
                                                                              ,pDataContext);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */

    if(lStdResult == DCM_E_NOT_OK)
    {
      /* Handle NRC here since no NRC can be passed by the application on this interface */
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalGap()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalGap(Dcm_OpStatusType              opStatus
                                                                   ,Dcm_DiagDataContextPtrType        pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode)                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                           /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(pSignalOpClassInfo == NULL_PTR)
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
#  if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
    if(opStatus == DCM_INITIAL)
#  endif
    {
      pDidOpTypeContext->OpType.Read.RemainingLength = pSignalOpClassInfo->MaxLength;                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    }

#  if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
    if(pDataContext->AvailLen < pDidOpTypeContext->OpType.Read.RemainingLength)
    {
      pDidOpTypeContext->OpType.Read.RemainingLength -= (Dcm_CfgDidMgrSignalLengthType)pDataContext->AvailLen;                                       /* SBSW_DCM_PARAM_PTR_WRITE */

      Dcm_DiagCommitData(pDataContext, pDataContext->AvailLen);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_BUFFERTOOLOW;
    }
    else
#  endif
    {
      Dcm_DiagCommitData(pDataContext, pDidOpTypeContext->OpType.Read.RemainingLength);                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_OK;
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignal(Dcm_OpStatusType                  opStatus
                                                                    ,Dcm_DiagDataContextPtrType        pDataContext
                                                                    ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(pSignalOpClassInfo == NULL_PTR)
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
    switch(pSignalOpClassInfo->FuncClass)
    {
#  if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
    case DCM_DIDMGR_OPCLS_READ_RANGE:
      lStdResult = Dcm_DidMgrReadSignalRange(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif

    case DCM_DIDMGR_OPCLS_READ_ASYNC:
      lStdResult = Dcm_DidMgrReadSignalAsync(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_READ_SYNC:
      lStdResult = Dcm_DidMgrReadSignalSync(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;

#  if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
    case DCM_DIDMGR_OPCLS_READ_PAGED:
      lStdResult = Dcm_DidMgrReadSignalPaged(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif

#  if (DCM_DIDMGR_VID_SUPPORT_ENABLED == STD_ON)
    case DCM_DIDMGR_OPCLS_READ_VID:
      lStdResult = Dcm_DidMgrReadSignalVid(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif

#  if (DCM_DIDMGR_SR_SUPPORT_ENABLED == STD_ON)
    case DCM_DIDMGR_OPCLS_READ_SR:
      lStdResult = Dcm_DidMgrReadSignalSR(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif

    case DCM_DIDMGR_OPCLS_READ_GAP:
      lStdResult = Dcm_DidMgrReadSignalGap(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_READ_WRAPPER:
      lStdResult = Dcm_DidMgrReadSignalWrapper(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;

    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }
  }

#  if (DCM_DIDMGR_CANCEL_OP_READ_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
#  endif

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
    &&(lStdResult != DCM_E_NOT_OK)
    &&(lStdResult != DCM_E_PENDING)
#  if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_BUFFERTOOLOW)
    &&(lStdResult != DCM_E_LOOP)
#  endif
#  if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_FORCE_RCRRP)
#  endif
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  Dcm_DiagHandleApplNrc(lStdResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6050, 6060 */ /* MD_MSR_STPTH,  MD_MSR_STCYC,  MD_MSR_STCAL, MD_Dcm_Design_6060 */
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrReadLengthSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLengthSignal(Dcm_OpStatusType           opStatus
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_DidMgrDidLengthPtrType        pResLength
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                           /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(pSignalOpClassInfo == NULL_PTR)
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
# endif
  {
    switch(pSignalOpClassInfo->FuncClass)
    {
    case DCM_DIDMGR_OPCLS_READLENGTH_SYNC:
      lStdResult = ((Dcm_DidMgrOpFuncReadLengthSyncType)pSignalOpClassInfo->OpFunc)(pResLength);                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;

    case DCM_DIDMGR_OPCLS_READLENGTH_ASYNC:
      lStdResult = ((Dcm_DidMgrOpFuncReadLengthAsyncType)pSignalOpClassInfo->OpFunc)(opStatus                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,pResLength);                                                    /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
    case DCM_DIDMGR_OPCLS_READLENGTH_RANGE:
      lStdResult = ((Dcm_DidMgrOpFuncReadDidRangeLengthType)pSignalOpClassInfo->OpFunc)(pDidInfoContext->Did                                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                       ,opStatus
                                                                                       ,pResLength);                                                 /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
# endif
    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }
  }

# if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
# endif

  if(lStdResult == DCM_E_NOT_OK)
  {
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT; /* return NRC CNC since no error code supported by the application API */                               /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
    &&(lStdResult != DCM_E_PENDING)
    &&(lStdResult != DCM_E_NOT_OK)
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  /* No need to handle E_NOT_OK since the only setter is the DCM itself (no appl NRC).
   * Dcm_DiagHandleApplNrc(lStdResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);
   */
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCondSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCondSignal(Dcm_OpStatusType        opStatus
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                           /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pSignalOpClassInfo = Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull(pDidOpTypeContext->Base.SignalOpClassInfoRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(pSignalOpClassInfo == NULL_PTR)
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
# endif
  {
    switch(pSignalOpClassInfo->FuncClass)
    {
    case DCM_DIDMGR_OPCLS_READCHK_COND_SYNC:
      lStdResult = ((Dcm_DidMgrOpFuncReadCheckCondSyncType)pSignalOpClassInfo->OpFunc)(ErrorCode);                                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_READCHK_COND_ASYNC:
      lStdResult = ((Dcm_DidMgrOpFuncReadCheckCondAsyncType)pSignalOpClassInfo->OpFunc)(opStatus                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                       ,ErrorCode);                                                  /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }
  }

# if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
# endif

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
    &&(lStdResult != DCM_E_PENDING)
    &&(lStdResult != DCM_E_NOT_OK)
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  Dcm_DiagHandleApplNrc(lStdResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidLookUp(
                                                                       Dcm_DidMgrDidInfoContextPtrType pDidInfoContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                      ,Dcm_DidMgrOpOptType             didOp)
{
  Std_ReturnType             lStdReturn = DCM_E_OK;
  Dcm_DidMgrDidOpInfoPtrType pDidOpInfoPtr;

  DCM_IGNORE_UNREF_PARAM(didOp);                                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pDidOpInfoPtr = Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext);

# if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  if(Dcm_VarMgrIsEnabledInActiveVariants(pDidOpInfoPtr->ExecCondRef) == FALSE)
  {
    /* Not supported in current variant */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  /* Check session state */
  if(!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(pDidOpInfoPtr->ExecCondRef)))
  {
    /* Not supported in current session */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
# if (DCM_SVC_22_OBD_CALIBRATION_ENABLED == STD_ON) && \
     (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
    /* Perform this check only on supported DIDs ! */
    if( (pDidInfoContext->Did >= (uint16)0xF400u)
      &&(pDidInfoContext->Did <= (uint16)0xF8FFu)
#  if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
      /* Already filtered in the IsDidAvailable operation of the 0xF6xx DID range.
       * Note: Dcm_CfgSvc22SupportedIdMask does not contain any information for this DID range -> exclude from indexing.
       */
      &&((pDidInfoContext->Did & 0xF600u) != 0xF600u)
#  endif
      )
    {
      if(!Dcm_ObdIdMgrIsIdEnabled(Dcm_UtiGetLoByte(pDidInfoContext->Did),
                             &Dcm_CfgSvc22SupportedIdMask[Dcm_CfgSvc22SupportedIdMaskOffset[Dcm_UtiGetHiByte(pDidInfoContext->Did)-(uint8)0xF4u]]))  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
      {
        /* OBD DID not enabled */
        lStdReturn = DCM_E_NOT_OK;
      }/* else - still enabled */
    }
    else/* not an (WWH-)OBD DID */
# endif
    {
# if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
      if(didOp != DCM_DIDMGR_OP_DEFINE) /* isolate SID 0x2C - Define or Clear on not defined DDDID is always allowed! */
      {
        if(!Dcm_Svc2CIsDidDefined(Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)))
        {
          /* not yet defined for other operations than DEFINE */
          lStdReturn = DCM_E_NOT_OK;
        }/* else - defined for other operations */
      }
# endif
    }
  }

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_DidMgrConcreteDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrConcreteDidLookUp(
                                                                        Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                       ,Dcm_DidMgrOpOptType didOp)
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;
  /* Search for the DID in the database */
  sint16_least  lResult = Dcm_UtiLookUpUint16(Dcm_CfgDidMgrDidLookUpTable, pDidInfoContext->Did);                                                    /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* Check DID lookup result: */
  if(lResult >= 0)
  {
    /* If found, check if the DID supports the required operation: */
    if(Dcm_DidMgrIsOpSupported(&Dcm_CfgDidMgrDidInfo[lResult], didOp))
    {
      /* If operation supported, initialize DID information (set DID as supported) */
      pDidInfoContext->Descriptor.DidInfoIdx = (Dcm_CfgDidMgrDidInfoRefType)lResult;                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Set DID length. Later the concrete length will be stored here. Take the maximum/concrete length! */
      pDidInfoContext->DidLength      = Dcm_CfgDidMgrDidInfo[lResult].MaxLength;                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      pDidInfoContext->ReservedLength = Dcm_CfgDidMgrDidInfo[lResult].ReservedLength;                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Initialize DID operation information  */
      Dcm_DidMgrInitOpInfo(pDidInfoContext, didOp);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdReturn = DCM_E_OK;
    }/* else - not a supported DID in the operation context! */
  }/* else - not a supported DID at all! */

  return lStdReturn;
}

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrCheckSignalSize()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DidMgrCheckSignalSize(Dcm_DiagDataContextConstPtrType   pDataContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_CfgNetBufferSizeOptType lRequiredBufSize;

#  if (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED == STD_ON)                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lRequiredBufSize = Dcm_DidMgrGetRequiredSignalBufSize(pDidInfoContext, pDidOpTypeContext);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
  /* Calculate the remaining available length */
  lRequiredBufSize = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif

  /*
   * Note: An additional check against AvailLen is not necessary here, since AvailLen is always equal to Size.
   *       The only exception is the last page during paged buffering, because AvailLen is than reduced to the
   *       remaining data length. As such it is already guaranteed that the signal fits into AvailLen.
   */
  return Dcm_DiagDataContextCheckSize(pDataContext, lRequiredBufSize);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrReadMultiSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadMultiSignal(Dcm_DiagDataContextPtrType pDataContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType lResult;

  /* For each signal of the DID: */
  do
  {
# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
    if (Dcm_DidMgrCheckSignalSize(pDataContext, pDidInfoContext, pDidOpTypeContext) == FALSE)                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    {
      /* Try it the next task cycle */
      lResult = DCM_E_BUFFERTOOLOW;
    }
    else
# endif
    {
      Dcm_CfgNetBufferSizeOptType lAvailLen;

      lAvailLen = (Dcm_CfgNetBufferSizeOptType)(pDataContext->AvailLen);

      /* Read the signal data considering gaps */
      lResult = Dcm_DidMgrReadSignal(pDidOpTypeContext->OpType.Read.OpStatus
                                    ,pDataContext
                                    ,pDidInfoContext
                                    ,pDidOpTypeContext
                                    ,ErrorCode);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

      switch(lResult)
      {
        case DCM_E_OK:
          pDidOpTypeContext->Base.NumSignals--;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
          if(pDidOpTypeContext->Base.NumSignals == 0u)
          {
            return DCM_E_OK;                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
          }

          pDidOpTypeContext->OpType.Read.Progress += (Dcm_CfgDidMgrOptimizedDidLengthType)(lAvailLen - pDataContext->AvailLen);                      /* SBSW_DCM_PARAM_PTR_WRITE */

          /* Go on with next signal */
          pDidOpTypeContext->Base.SignalOpClassInfoRef++;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
          pDidOpTypeContext->OpType.Read.OpStatus = DCM_INITIAL; /* reset op status */                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
          break;
        case DCM_E_BUFFERTOOLOW:
        case DCM_E_LOOP:
          pDidOpTypeContext->OpType.Read.Progress += (Dcm_CfgDidMgrOptimizedDidLengthType)(lAvailLen - pDataContext->AvailLen);                      /* SBSW_DCM_PARAM_PTR_WRITE */
          /* fall through */
        case DCM_E_PENDING:                                                                                                                          /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
          pDidOpTypeContext->OpType.Read.OpStatus = DCM_PENDING;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          break;
        default: /* DCM_E_FORCE_RCRRP, DCM_E_NOT_OK */
          break;
      }
    }
  } while( (lResult == DCM_E_OK) || (lResult == DCM_E_LOOP) );

  return lResult;
}                                                                                                                                                    /* PRQA S 2006, 6080 */ /* MD_Dcm_Optimize_2006, MD_MSR_STMIF */
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Inlined function implementations (Level1)
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/**********************************************************************************************************************
 *  Dcm_DiagAcceptNewRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagAcceptNewRequest(Dcm_NetTransportObjectPtrType pTranspObj)                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  boolean lResult = TRUE;
  /* If SID in range: [0x40, 0x7F]U[0xC0, 0xFF] */
#if(DCM_DIAG_IGNORE_RESPONSE_SID_ENABLED == STD_ON)
  if((pTranspObj->RxData[0] & 0x40u) != 0)
  {
    pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_IGNORE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = FALSE;
  }
  else
#endif
  /* If valid functional "0x3E 0x80" */
  if( (pTranspObj->RxData[0] == 0x3Eu)
    &&(pTranspObj->RxData[1] == 0x80u)
    &&(pTranspObj->RxLength  == 2u)
    &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE) )
  {
#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
    if (Dcm_NetGetSessionConnection() != pTranspObj->ConnId) /* request from different tester */
    {
      pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_IGNORE;                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    }
#endif
    lResult = FALSE;
  }
  else
  {
    /* nothing to do */
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_DiagOnTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagOnTxFinished(Dcm_NetTransportObjectPtrType pTranspObj                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                          ,Dcm_NetTransmissionResultType txStatus)
{
  switch(pTranspObj->ResType)
  {
  case DCM_NET_TOBJ_RESTYPE_LINEAR:
  case DCM_NET_TOBJ_RESTYPE_PAGED:
    /* Do finalize main response */
    Dcm_DiagTxFinalization(pTranspObj, txStatus);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_NET_TOBJ_RESTYPE_RCRRP:
    Dcm_DiagRcrRpTxFinished(pTranspObj, txStatus);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  case DCM_NET_TOBJ_RESTYPE_UNSOLICITED:
    Dcm_DiagOnFblResTxFinished(pTranspObj, txStatus);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    /* Unknown response type */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }
}
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AOnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2AOnStateChanged(void)
{
# if (DCM_DIDMGR_PERIODICDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    Dcm_NegativeResponseCodeType   lNrc;
    Dcm_Svc2ASchdItemHandleOptType lSchdIter;
    Std_ReturnType lStdReturn;

    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);
      if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED)/* is still an active entry? */
      {
        lStdReturn = Dcm_DidMgrDynDidStateCheck(&(pSchdEntry->DidContext), &lNrc);                                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
        if (lStdReturn == DCM_E_NOT_OK)
        {
          Dcm_Svc2ASchdStopItemByHandle(lSchdIter);
        }
      }
    }
  }
# endif
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CGetSrcItem()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidSrcItemPtrType, DCM_CODE) Dcm_Svc2CGetSrcItem(
                                                                     Dcm_CfgDidMgrDynDidSrcItemIdxOptType srcItemIndex)
{
  Dcm_Svc2CDynDidSrcItemPtrType pSourceItem;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (srcItemIndex >= DCM_NUM_DYNDID_ITEMS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_SVC2CGETSRCITEM);
    pSourceItem = &Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[0];
  }
  else
# endif
  {
    pSourceItem = &Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[srcItemIndex];
  }

  return pSourceItem;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CGetItem()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidItemPtrType, DCM_CODE) Dcm_Svc2CGetItem(Dcm_CfgDidMgrDynDidHandleOptType itemIndex)
{
  Dcm_Svc2CDynDidItemPtrType pItem;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (itemIndex >= DCM_NUM_DYNDIDS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_SVC2CGETITEM);
    pItem = &Dcm_InstanceContext.Diag.Services.Svc2C.Items[0];
  }
  else
# endif
  {
    pItem = &Dcm_InstanceContext.Diag.Services.Svc2C.Items[itemIndex];
  }

  return pItem;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CGetDDDidProcessContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidProcessContextPtrType, DCM_CODE) Dcm_Svc2CGetDDDidProcessContext(
                                                                                             uint8 processContextIndex)
{
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (processContextIndex >= DCM_SVC_2C_NUM_PROCESS_CONTEXTS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_SVC2CGETDDDIDPROCESSCONTEXT);
    pProcessContext = &Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[0];
  }
  else
# endif
  {
    pProcessContext = &Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[processContextIndex];
  }

  return pProcessContext;
}

# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CStateCheckSrcItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CStateCheckSrcItems(
                                                                           Dcm_CfgDidMgrDynDidHandleOptType dynDidHandle
                                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType currItem;
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType endItem;

  currItem = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);
  endItem = (Dcm_CfgDidMgrDynDidSrcItemIdxOptType)(currItem + Dcm_Svc2CGetItem(dynDidHandle)->Count);

  Dcm_DebugAssert((currItem < endItem), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                       /* COV_DCM_RTM_DEV_DEBUG XF */

  for(; currItem < endItem; currItem++)
  {
    if(Dcm_Svc2CIsDidSrcItem(currItem))
    {
#  if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
      Dcm_DidMgrDidInfoContextPtrType pDidInfoContext = &Dcm_Svc2CGetSrcItem(currItem)->DidDescriptor.DidContext;
      lStdResult = Dcm_StateCheck(Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext)->ExecCondRef
                                 ,DCM_DIAG_CHK_LVL_PARAMETER, ErrorCode);                                                                            /* SBSW_DCM_COMB_PTR_FORWARD */
#  endif
    }
    else
    {
#  if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
      lStdResult = Dcm_MemMgrCheckMemBlock(&(Dcm_Svc2CGetSrcItem(currItem)->MemDescriptor.MemBlock)
                                          ,DCM_MEMMGR_OP_READ
                                          ,ErrorCode);                                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */
#  endif
    }
    if (lStdResult != DCM_E_OK)
    {
      break;
    }
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2COnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2COnStateChanged(void)
{
# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
  /* clear all DynDID definitions not supported any more */
  Dcm_NegativeResponseCodeType lNrc;
  Std_ReturnType lStdResult;
  Dcm_CfgDidMgrDynDidHandleOptType dynDidIter;

  for(dynDidIter = 0; dynDidIter < DCM_NUM_DYNDIDS; ++dynDidIter)
  {
    if(Dcm_Svc2CIsDynDidDefined(dynDidIter))
    {
      lStdResult = Dcm_StateCheck(Dcm_DidMgrGetDynDidReadExecPrecond(dynDidIter), DCM_DIAG_CHK_LVL_PARAMETER, &lNrc);                                /* SBSW_DCM_POINTER_FORWARD_STACK */
#  if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
      if(lStdResult == DCM_E_OK) /* all DDDID conditions OK - check inside */
      {
        lStdResult = Dcm_Svc2CStateCheckSrcItems(dynDidIter, &lNrc);                                                                                 /* SBSW_DCM_POINTER_FORWARD_STACK */
      }
#  endif
      if(lStdResult == DCM_E_NOT_OK) /* any condition not fulfilled? */
      {
        Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)dynDidIter);
      }
    } /* else - DDDID not defined yet */
  }
# endif
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Min Length already checked in DiagDispatcher and expected to be 3 !!! */
    Dcm_DiagConsumeReqDataAsU16(pMsgContext, &(pRepContext->DidInfoContext.Did));                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdResult = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->DidInfoContext)
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_IO);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

  switch(lStdResult)
  {
  case DCM_E_OK:
    {
      uint8 lControlOp;
      Dcm_DiagConsumeReqDataAsU8(pMsgContext, &lControlOp);                                                                                          /* SBSW_DCM_COMB_PTR_FORWARD */

      /* convert from UDS to internal operation representation */
      if(lControlOp < 4u)
      {
        pRepContext->OpType = Dcm_Svc2FCtrlOp2DidOpTypeMap[lControlOp]; /* use interpreted value */                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      else
      {
        pRepContext->OpType = (Dcm_DidMgrOpMemType)0x00u; /* no supported operation */                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
      }

      /* Check for supported sub-operation */
      if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&pRepContext->DidInfoContext), pRepContext->OpType))                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        /* Commit response header */
        Dcm_DiagProvideResData(pMsgContext, 3);                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

        lStdResult = Dcm_Svc2FIoDidOperationProcessor(pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
    break;
  case DCM_E_NOT_OK:
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default: /* DCM_E_PENDING -> try again */
    break;
  }

  return lStdResult;
}

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FGetActiveIoDids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_UtiBitSetBasePtrType, DCM_CODE) Dcm_Svc2FGetActiveIoDids(
                                                                            Dcm_CfgDidMgrIoDidHandleOptType ioDidIndex)
{
  Dcm_UtiBitSetBasePtrType pActiveIoDids;

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (ioDidIndex >= Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS))
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_SVC2FGETACTIVEIODIDS);
    pActiveIoDids = &Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids[0];
  }
  else
#  endif
  {
    pActiveIoDids = &Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids[ioDidIndex];
  }

  return pActiveIoDids;
}
# endif


/**********************************************************************************************************************
 *  Dcm_Svc2FOnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FOnStateChanged(void)
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON) && \
     (DCM_DIDMGR_IODID_EXEC_PRECOND_LIMIT_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid == TRUE)
  {
    Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRefPage = 0;
    Dcm_CfgDidMgrIoDidHandleOptType ioDidIter;

    Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE; /* Assume all IODIDs will be deactivated */

    for(ioDidIter = 0; ioDidIter < Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS); ioDidIter++)
    {
      Dcm_UtiBitSetBasePtrType pActiveIoDids = Dcm_Svc2FGetActiveIoDids(ioDidIter);
      Dcm_UtiBitSetBaseType lActiveIoDids = *pActiveIoDids;
      Dcm_UtiBitSetBaseType lActiveIoDidScanner = 0x01u;
      Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef = opInfoRefPage;

      DCM_UTI_LOOP_BIT_SCAN(lActiveIoDids)
      {
        if(Dcm_UtiBitOpTest(Dcm_UtiBitSetBaseType, *pActiveIoDids, lActiveIoDidScanner))
        {
          Dcm_NegativeResponseCodeType lNrc;
          Std_ReturnType lStdReturn;

          lStdReturn = Dcm_DidMgrStaticDidStateCheck(Dcm_DidMgrGetCtrlOpExecCondRef(opInfoRef), &lNrc);                                              /* SBSW_DCM_POINTER_FORWARD_STACK */
          if (lStdReturn == DCM_E_NOT_OK)
          {
            Dcm_UtiBitOpClr(Dcm_UtiBitSetBaseType, *pActiveIoDids, lActiveIoDidScanner);                                                             /* PRQA S 0290 */ /* MD_Dcm_BitNegation_0290 */ /* SBSW_DCM_POINTER_WRITE_2FACTIVEIODIDS */
            Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_DidMgrGetCtrlOpInfoRef(opInfoRef));
          }
        }

        lActiveIoDidScanner<<=1;
        ++opInfoRef;
      }

      /* If still any IODID active in this row: */
      if(*pActiveIoDids != 0)
      {
        /* Update IODID activity statistics */
        Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = TRUE;
      }

      opInfoRefPage += (Dcm_CfgDidMgrDidOpClassHandleOptType)Dcm_UtiGetNumBitsOfXintType(Dcm_UtiBitSetBaseType);/* next bunch of IoDids */
    }
  }
# endif
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Inlined function implementations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_MemMgrInit(void)
{
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_NONE;
# endif
}

/**********************************************************************************************************************
 *  Dcm_MemMgrConvMemOpResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrConvMemOpResult(Dcm_MemMgrOpResultType memOpResult
                                                                         ,Dcm_OpStatusType opStatus
                                                                         ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                         ,Dcm_NegativeResponseCodeType DefaultNrc)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DIAG_CANCEL_OP_ENABLED     == STD_ON) && \
     (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  if (opStatus == DCM_CANCEL)
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
# endif
  {
    switch(memOpResult)
    {
    case DCM_MEMMGR_OP_RSLT_OK:
      lStdResult = DCM_E_OK;
      break;
    case DCM_MEMMGR_OP_RSLT_PENDING:
      lStdResult = DCM_E_PENDING;
      break;
    case DCM_MEMMGR_OP_RSLT_FORCE_RCRRP:
      lStdResult = DCM_E_FORCE_RCRRP;
      break;
    default: /* DCM_MEMMGR_OP_RSLT_FAILED */
      lStdResult = DCM_E_NOT_OK;
# if(DCM_DEV_ERROR_REPORT == STD_ON)
      if(memOpResult != DCM_MEMMGR_OP_RSLT_FAILED)
      {
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      }
# endif
# if (DCM_DCM_AR_VERSION < DCM_DCM_AR_VERSION_422)
      *ErrorCode = DefaultNrc; /* restore default NRC */                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
# endif
      break;
    }
  }

# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
  Dcm_DiagHandleApplNrc(lStdResult, ErrorCode, DefaultNrc);                                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_PARAM_PTR_FORWARD */
# endif

# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  if( (lStdResult != DCM_E_PENDING)
    &&(lStdResult != DCM_E_FORCE_RCRRP))
  {
    /* Release resource */
    Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_NONE;
  }
# endif
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_MemMgrGetMemMap()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrGetMemMap(Dcm_MemMgrMemBlockConstPtrType pMemBlock
                                                                   ,Dcm_CfgMemMgrMemIdInfoPtrType pMemMapDescriptor
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode)                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  sint16_least   lMidIdx = 0;

  DCM_IGNORE_UNREF_PARAM(pMemBlock);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
  lMidIdx = Dcm_UtiLookUpUint8(Dcm_CfgMemMgrMidLookUpTable, pMemBlock->Mid);                                                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  if(lMidIdx < 0)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    Dcm_UtiAssignStruct(*pMemMapDescriptor, Dcm_CfgMemMgrMidInfo[lMidIdx]);                                                                          /* PRQA S 0310, 3109 */ /* MD_Dcm_GenericStructAssign_0310, MD_MSR_14.3 */ /* SBSW_DCM_POINTER_WRITE_UTI_STRUCT */

    lStdResult = DCM_E_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_MemMgrCheckMemoryRange()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrCheckMemoryRange(Dcm_MemMgrMemBlockConstPtrType pMemBlock
                                                                   ,Dcm_MemMgrMemoryOpType memOp
                                                                   ,Dcm_CfgMemMgrMemIdInfoConstPtrType pMemMapDescriptor
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  Dcm_CfgMemMgrReqAddrType reqEndAddress;
  Dcm_CfgMemMgrMemMapInfoPtrType pUsedMemMap;

  pUsedMemMap = pMemMapDescriptor->MemMapTable;
  reqEndAddress = (Dcm_CfgMemMgrReqAddrType)(pMemBlock->Address + (Dcm_CfgMemMgrReqSizeType)(pMemBlock->Length - 1u)); /* possible overflows does not take any effect for now */

  /* Check for address overflow or no data required (length == 0) */
  if( (pMemBlock->Length != 0u)
    &&(reqEndAddress >= pMemBlock->Address) )
  {
    Dcm_CfgMemMgrMemMapIdxOptType  memMapIter = 0;
    Dcm_CfgMemMgrMemAddrType       lastEndAddr = pUsedMemMap->EndAddr;
    boolean                        isBlockBeginFound = FALSE;
    boolean                        isMemMapAreaFound = FALSE;

    lStdResult = DCM_E_OK;

    for(;memMapIter < pMemMapDescriptor->Size; ++memMapIter)
    {
      if(pUsedMemMap[memMapIter].EndAddr >= pMemBlock->Address) /* first block that may contain the requested range */
      {
        if(isBlockBeginFound == FALSE)
        {
          isBlockBeginFound = TRUE;
          if(pUsedMemMap[memMapIter].StartAddr > pMemBlock->Address) /* the start address must be within the configured block  */
          {
            /* the requested start address is not within the memory block */
            break;
          }
          /* else - OK, let's analyze the other properties of the configuration block */
        }
        else /* scanning subsequent blocks */
        {
          ++lastEndAddr; /* prepare for the potential next concatenated range startAddr */
          if(pUsedMemMap[memMapIter].StartAddr != lastEndAddr) /* no concatenated ranges */
          {
            /* Stop scanning due to an error */
            break;                                                                                                                                   /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
          }/* else - the end address block was not found yet, check this range borders and conditions */
        }

        if (pUsedMemMap[memMapIter].ExecCondRefs[memOp] == 0u) /* memory operation supported for this block in currently active variant(s) ? */
        {
          /* Stop scanning due to an error */
          break;                                                                                                                                     /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
        }
        else/* else - range supports operation - go on with state checks */
        {
# if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
          if (Dcm_VarMgrIsEnabledInActiveVariants((Dcm_CfgStateRefOptType)(pUsedMemMap[memMapIter].ExecCondRefs[memOp] - 1u)) == FALSE)
          {
            /* Stop scanning due to an error */
            break;                                                                                                                                   /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
          }
# endif
        }

        if(lStdResult == DCM_E_OK) /* still no error found */
        {
          lStdResult = Dcm_StateCheck((Dcm_CfgStateRefOptType)(pUsedMemMap[memMapIter].ExecCondRefs[memOp] - 1u),
                                      DCM_DIAG_CHK_LVL_PARAMETER,
                                      ErrorCode);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
        }/* else - ErrorCode already set, let see if the range is at least OK */

        if(((Dcm_CfgMemMgrReqAddrType)pUsedMemMap[memMapIter].EndAddr) >= reqEndAddress)
        {
          isMemMapAreaFound = TRUE;
          /* stop scanning: send either POS_RES or first condition error: depends on the last lStdResult value
           * (ErrorCode already set in case of E_NOT_OK)
           */
          break;                                                                                                                                     /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
        }/* else - try next range (if any still available) */
        lastEndAddr = pUsedMemMap[memMapIter].EndAddr;/* update for next iteration */
      }/* else - not reached a range from the bottom */
    }/* no valid range found */

    /* If requested start address is too high or end address was not met:
      * (e.g. due to wrong operation in any sub-area or end address too high, resp. outside of started area)
      */
    if(isMemMapAreaFound == FALSE)
    {
      /* Send negative response NRC 0x31 */
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }/* Otherwise - matching area found: either POS_RES for valid states or NEG_RES due to invalid states */
  }
  else/* else - length == 0 or req_addr > blockEnd */
  {
    /* Send negative response NRC 0x31 */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_MemMgrDwordExtract()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_MemMgrDwordExtract(Dcm_MsgContextPtrType pMsgContext
                                                              ,uint8_least           numBytes)
{
  uint8  lByteValue;
  uint32 lResult = 0;

  while(numBytes != 0u)
  {
    --numBytes;
    lResult <<= 8u;
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &lByteValue);                                                                                            /* SBSW_DCM_COMB_PTR_FORWARD */
    lResult |= lByteValue;
  }

  return lResult;
}
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId(uint8 ObdMID
                                                                                         ,Dcm_DiagDataContextPtrType pDataContext)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint32 lObdMidAvailMask;

  /* #10 If request of MID Mask value from Dem is successful */
  if (Dem_DcmGetAvailableOBDMIDs(ObdMID, &lObdMidAvailMask) == E_OK)                                                                                 /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    /* #20 Copy MID Mask value to data context */
    Dcm_DiagProvideDataAsU32(pDataContext, lObdMidAvailMask);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    /* #30 Otherwise return negative response */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_DataId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_DataId(uint8 ObdMID
                                                                                    ,Dcm_DiagDataContextPtrType pDataContext)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8 lNumOfTIDs;

  /* #10 Request number of TIDs for DID from Dem */
  if (Dem_DcmGetNumTIDsOfOBDMID(ObdMID, &lNumOfTIDs) == E_OK)                                                                                        /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    /* #20 If request is successful */
    uint8 lTidIter;
    uint16 lTestValue;
    uint16 lTestValuMin;
    uint16 lTestValueMax;
    uint8 lTidValue;
    uint8 lUaSid;

    /* #30 Request Test Result of each TID from Dem */
    for (lTidIter = 0; lTidIter < lNumOfTIDs; lTidIter++)
    {
      if (Dem_DcmGetDTRData(ObdMID, lTidIter, &lTidValue, &lUaSid, &lTestValue, &lTestValuMin, &lTestValueMax) == E_OK)                              /* SBSW_DCM_POINTER_FORWARD_STACK */
      {
        /* #40 If request is successful for a TID */
        /* #50 Copy response data to data context */
        Dcm_DiagProvideDataAsU8(pDataContext,lTidValue);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_DiagProvideDataAsU8(pDataContext,lUaSid);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_DiagProvideDataAsU16(pDataContext,lTestValue);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_DiagProvideDataAsU16(pDataContext,lTestValuMin);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_DiagProvideDataAsU16(pDataContext,lTestValueMax);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        /* #60 Otherwise return negative response */
        lStdResult = DCM_E_NOT_OK;
        break;
      }
    }
  }
  else
  {
    /* #70 Otherwise return negative response */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if (DCM_UTI_NVM_READ_ENABLED  == STD_ON) || \
     (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_UtiNvMGetErrorStatus()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiArEnvNvMGetErrorStatus(uint16 blockId
                                                         ,P2VAR(NvM_RequestResultType, AUTOMATIC, AUTOMATIC) nvmStatus)
{
  NvM_GetErrorStatus(blockId, nvmStatus);                                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
  return E_OK;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_NetIsRxPduIdValid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsRxPduIdValid(PduIdType rxPduId)
{
  boolean lResult = TRUE;

  if( (rxPduId >= Dcm_PbCfgNetNumRxPduIds)
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    ||(Dcm_NetGetConnIdOfRxPduId(rxPduId) >= Dcm_PbCfgNetNumConnections)
# endif
    )
  {
    lResult = FALSE;
  }

  return lResult;
}
#endif

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_NetIsTxPduIdValid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsTxPduIdValid(PduIdType txPduId)
{
  boolean lResult = TRUE;

  if( (txPduId >= Dcm_PbCfgNetNumTxPduIds)
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    ||(Dcm_NetGetConnIdOfTxPduId(txPduId) >= Dcm_PbCfgNetNumConnections)
# endif
    )
  {
    lResult = FALSE;
  }

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetGetComMContext()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetComMContextPtrType, DCM_CODE) Dcm_NetGetComMContext(Dcm_CfgNetNetIdRefOptType index)
{
  Dcm_NetComMContextPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= Dcm_PbCfgNetNumComMChannels)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETGETCOMMCONTEXT);
    lResult = &Dcm_PbRamNetComMContext[0];
  }
  else
#endif
  {
    lResult = &Dcm_PbRamNetComMContext[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetGetBufferContext()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetBufferContextPtrType, DCM_CODE) Dcm_NetGetBufferContext(Dcm_CfgNetBufferRefOptType index)
{
  Dcm_NetBufferContextPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= Dcm_PbCfgNetNumBuffers)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETGETBUFFERCONTEXT);
    lResult = &Dcm_PbRamNetBufferContext[0];
  }
  else
#endif
  {
    lResult = &Dcm_PbRamNetBufferContext[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetGetTransportObject()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetGetTransportObject(
                                                                                    Dcm_CfgNetTObjHandleOptType index)
{
  Dcm_NetTransportObjectPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= Dcm_PbCfgNetNumTransportObjects)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETGETTRANSPORTOBJECT);
    lResult = &Dcm_PbRamNetTransportObject[0];
  }
  else
#endif
  {
    lResult = &Dcm_PbRamNetTransportObject[index];
  }

  return lResult;
}

#if (DCM_NET_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetSetComControlChannelState()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetSetComControlChannelState(uint8_least index
                                                                      ,Dcm_CommunicationModeType value)
{
# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= Dcm_PbCfgNetNumAllComMChannels)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETSETCOMCONTROLCHANNELSTATE);
  }
  else
# endif
  {
    Dcm_PbRamNetComCtrlChannels[index] = value;                                                                                                      /* SBSW_DCM_POINTER_WRITE_COMCONTROLCHANNEL */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetPutToConn2TObjMap()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPutToConn2TObjMap(Dcm_NetConnRefOptType index
                                                              ,Dcm_CfgNetTObjHandleMemType value)
{
#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= Dcm_PbCfgNetNumConnections)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETPUTTOCONN2TOBJMAP);
  }
  else
#endif
  {
    Dcm_PbRamNetConnId2TObjMap[index] = value;                                                                                                       /* SBSW_DCM_POINTER_WRITE_TOBJHANDLE */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetWriteAddBufferU8At()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetWriteAddBufferU8At(Dcm_NetTransportObjectPtrType pTranspObj
                                                               ,uint8_least index
                                                               ,Dcm_MsgItemType value)
{
#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_NET_TOBJ_ADDBUFFER_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETWRITEADDBUFFERU8AT);
  }
  else
#endif
  {
    pTranspObj->AddBuffer[index] = value;                                                                                                            /* SBSW_DCM_POINTER_WRITE_TOBJ_ADDBUFFER */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetGetBufferInfo()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_PbCfgNetBufferInfoPtrType, DCM_CODE) Dcm_NetGetBufferInfo(Dcm_CfgNetBufferRefOptType index)
{
  Dcm_PbCfgNetBufferInfoPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= Dcm_PbCfgNetNumBuffers)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETGETBUFFERINFO);
    lResult = &Dcm_PbCfgNetBufferInfo[0];
  }
  else
#endif
  {
    lResult = &Dcm_PbCfgNetBufferInfo[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetCommonInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetCommonInit(void)
{
  Dcm_SingletonContext.Network.NumActiveConnections = 0u;
#if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.ActiveProtocol = DCM_NET_INVALID_PROTID;
#endif
  Dcm_SingletonContext.Network.ActiveDiagnostic = DCM_NET_COMM_ACTIVE;
#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.RxAllowed = TRUE;
#endif
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.KeepAlive = FALSE;
#endif
}

/**********************************************************************************************************************
 *  Dcm_NetComMInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComMInit(void)
{
  Dcm_CfgNetNetIdRefOptType lNetHandleIter;

  for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
  {
    Dcm_NetComMContextPtrType pComMContext;

    pComMContext = Dcm_NetGetComMContext(lNetHandleIter);

    pComMContext->ComState           = DCM_NET_COMM_STATE_RX_DIS_TX_DIS;                                                                             /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    pComMContext->RegisteredNetworks = 0u;                                                                                                           /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetBufferInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetBufferInit(void)
{
  Dcm_CfgNetBufferRefOptType lBufferIter;

  for(lBufferIter = 0; lBufferIter < Dcm_PbCfgNetNumBuffers; ++lBufferIter)
  {
    Dcm_NetBufferContextPtrType pBufferContext;

    pBufferContext = Dcm_NetGetBufferContext(lBufferIter);

    pBufferContext->IsInUseCnt = 0u;                                                                                                                 /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetConnectionInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetConnectionInit(void)
{
  Dcm_NetConnRefOptType lConnIter;

  for(lConnIter = 0; lConnIter < Dcm_PbCfgNetNumConnections; ++lConnIter)
  {
    Dcm_NetPutToConn2TObjMap(lConnIter, DCM_NET_INVALID_TOBJID);
  }
}

/**********************************************************************************************************************
 *  Dcm_NetTranspObjInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTranspObjInit(void)
{
  Dcm_CfgNetTObjHandleOptType lTObjIter;

  for(lTObjIter = 0; lTObjIter < Dcm_PbCfgNetNumTransportObjects; ++lTObjIter)
  {
    Dcm_NetTransportObjectPtrType pTranspObj;

    pTranspObj = Dcm_NetGetTransportObject(lTObjIter);

    pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_NONE;                                                                                                 /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pTranspObj->State   = DCM_NET_TOBJ_STATE_FREE;                                                                                                   /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pTranspObj->Flags   = DCM_NET_TOBJ_FLAG_NONE;                                                                                                    /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    Dcm_NetWriteAddBufferU8At(pTranspObj, 0, 0x7Fu); /* always used for negative responses */                                                        /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pTranspObj->Handle  = (Dcm_CfgNetTObjHandleMemType)lTObjIter;                                                                                    /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgInit(void)
{
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  /* Initialize periodic transmission manager state machine */
  Dcm_NetPeriodicMsgResetConnection();
  Dcm_NetPeriodicMsgInitDelayCntr();
  Dcm_NetPeriodicMsgInitFastestRate();
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  {
    /* Initialization of delay timers */
    uint8_least lDelayTmrIter;
    for (lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
    {
      Dcm_NetDelayTimerSet(lDelayTmrIter, 0);
    }
  }
# endif
  {
    Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;
    for(lPerTxObjIter = 0; lPerTxObjIter < Dcm_PbCfgNetNumPerTxObjects; ++lPerTxObjIter)
    {
      Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

      pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(lPerTxObjIter);

      /* Initialize the transport object */
      pPeriodicTxObj->Timer = 0u;                                                                                                                    /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
      pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_FREE;                                                                                        /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
      pPeriodicTxObj->TxPduInfo.SduDataPtr = pPeriodicTxObj->TxBuffer;                                                                               /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
    }
  }
#endif
}

/**********************************************************************************************************************
 *  Dcm_NetInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetInit(void)
{
  /* #10 First initialize common variables */
  Dcm_NetCommonInit();
  /* #20 Now initialize all remaining network related sub-elements. The order of execution shall not be relevant */
  Dcm_NetComMInit();
  Dcm_NetBufferInit();
  Dcm_NetConnectionInit();
  Dcm_NetTranspObjInit();
  Dcm_NetPeriodicMsgInit();
}

/**********************************************************************************************************************
 *  Dcm_NetComposeAddNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComposeAddNegResponse(Dcm_NetTransportObjectPtrType pTranspObj                                          /* COV_DCM_RTM_NO_RCR_RP_TX */
                                                                  ,Dcm_NetResponseType resType
                                                                  ,Dcm_NegativeResponseCodeType nrc)
{
  Dcm_NetWriteAddBufferU8At(pTranspObj, 2, nrc); /* NRC = nrc, 0x7F and SID are already copied! */                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  pTranspObj->BuffInfo.SduDataPtr = pTranspObj->AddBuffer; /* use the temp buffer to free the main buffer now */                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->BuffInfo.SduLength  = 3u;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->ResType             = resType;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->State               = DCM_NET_TOBJ_STATE_PREPTX;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
}

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetOnRequestDetection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetOnRequestDetection(Dcm_NetConnRefMemType connId)
{
  volatile Dcm_NetTransportObjectPtrType pTranspObj; /* Avoid any potential compiler optimizations declaring volatile kind of data */

  /* #10 Retrieve the transport object from the given connection */
  pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(connId);

  /* #20 Check whether a transport object is in use */
  if(pTranspObj != NULL_PTR)
  {
    /* #30 Enter critical section (Reason: the transport object may not be modified from outside (e.g. Dcm_TpTxConfirmation releases it) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    /* #40 Retrieve again the transport object from connection to guarantee it has still the same state */
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(connId);

    /* #45 Check the connection still uses the same transport object (it is always 1:1 association between connection and a transport object) */
    if(pTranspObj != NULL_PTR)                                                                                                                       /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
    {
      /* #50 Check whether the connection is free */
      if(pTranspObj->State != DCM_NET_TOBJ_STATE_FREE)
      {
# if (DCM_NET_SUPPRESS_ON_FUNC_REQ_ENABLED == STD_ON)
        /* #60 Check if suppression of responses on functional addressed requests is enabled */
        if( (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_TX_ON_FUNC_RX))
          &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE) )
        {
          /*
           * #70 Interruption of functional addressed request is not necessary because response will already be
           * suppressed
           */
        }
        /* #80 Otherwise, interrupt ongoing service processing */
        else
# endif
        {
          /* #90 If a new request is being received: */
          if(pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX)
          {
            /* #100 Isolate this connection */
            pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED;                                                                                         /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */

            /* #110 Terminate the ongoing reception immediately */
            (void)Dcm_NetArEnvPduRCancelReceive(pTranspObj->RxPduId);
          }
          /* #120 Otherwise, let the task cancel any pending jobs */
          else
          {
            /* #130 Mark transport object as obsolete. This is used to distinguish between two allocations of the same transport object before the Dcm_NetTaskTaMonitor is called */
            pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_OBSOLETE;                                                                                         /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
            Dcm_TskSetEvent(DCM_TSK_ID_NET_TA_MONITOR, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));
          }
        }
      }/* else - nothing to interrupt */
    }/* else - request no more in progress -> ignore */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* #140 Leave critical section */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }/* else - no request in progress or different tester -> ignore */
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if(DCM_NET_PROTOCOL_SWITCH_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetExecStartProtocolOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetExecStartProtocolOp(Dcm_ProtocolType newProtocol)
{
  boolean      lResult = TRUE;
  uint16_least lIter;

  for(lIter = 0u; Dcm_CfgNetProtocolNotificationInfo[lIter].StartFunc != NULL_PTR; ++lIter)
  {
    if(Dcm_CfgNetProtocolNotificationInfo[lIter].StartFunc(newProtocol) != DCM_E_OK)                                                                 /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */
    {
      lResult = FALSE;
      break;
    }
  }
  return lResult;
}
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetProcessStartProtocol()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetProcessStartProtocol(Dcm_NetTransportObjectPtrType pTranspObj)
{
# if(DCM_NET_PROTOCOL_SWITCH_NOTIFICATION_ENABLED == STD_ON)
  boolean startProtocolAllowed;

  startProtocolAllowed = Dcm_NetExecStartProtocolOp(Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfTranspObj(pTranspObj)].Id);
  if(startProtocolAllowed == FALSE)
  {
    Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    /* Neg response 0x22 */
    Dcm_NetComposeAddNegResponse(pTranspObj
                                ,DCM_NET_TOBJ_RESTYPE_SIMPLE
                                ,DCM_E_CONDITIONSNOTCORRECT);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
  }
  else
# endif
  {
    if(Dcm_NetGetProtIdOfActiveProtocol() < DCM_NET_INVALID_PROTID)
    {
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
      Dcm_DiagCancelProcessing();
# endif
      /* According to AR DCM SWS the session switch is executed at start protocol, not at stop! */
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);
    }/* else - no protocol enabled -> no need to reset anything */

    Dcm_SingletonContext.Network.ActiveProtocol = Dcm_NetGetProtIdOfTranspObj(pTranspObj);/* set new active protocol */

    /* Update P2 timings at once */
    Dcm_DiagSetP2Timings(0, Dcm_SingletonContext.Network.ActiveProtocol);

    Dcm_DiagRxIndication(pTranspObj);                                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisation_FindWinner()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetTObjHandleOptType, DCM_CODE) Dcm_NetRxPrioritisation_FindWinner(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pBusyEvents)
{
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
  uint16 lMaxPrio = 0x100u;/* lower than the lowest configurable priority (256 > 255) */
# endif
  Dcm_CfgNetTObjHandleOptType lTObjCntr = 0u;
  Dcm_CfgNetTObjHandleOptType lTranspObjWinnerId = DCM_NET_INVALID_TOBJID;

  *pBusyEvents = 0;                                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

  DCM_TSK_EVENT_SCAN_LOOP(ev)
  {
    /* Scan all arrived transport objects */
    if(Dcm_TskIsLocalEventSet(ev, 0x01u)) /* start scan from the LSB since TObjects are allocated by reversed iteration and thus -> first allocated (last checked here) will be the winner */
    {
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
      uint8 tmpProtPrio = Dcm_NetGetProtObjOfTranspObj(Dcm_NetGetTransportObject(lTObjCntr))->Priority;

      /* Higher priority */
      if(lMaxPrio <= tmpProtPrio)
      {
        /* Lower priority than current request/pending response */
        *pBusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, lTObjCntr);                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      else
# endif
      {
        if(lTranspObjWinnerId < DCM_NET_INVALID_TOBJID)
        {
          /* Mark busy for the last winner */
          *pBusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, lTranspObjWinnerId);                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
        }
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
        /* Update maximum priority */
        lMaxPrio = tmpProtPrio;
# endif
        /* potential winner found */
        lTranspObjWinnerId = lTObjCntr;
      }
    }
    ++lTObjCntr;
  }
  return lTranspObjWinnerId;
}
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessWinner()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_NetRxPrioritisationProcessWinner(
                                                                          Dcm_CfgNetTObjHandleOptType TranspObjWinnerId
                                                                         ,Dcm_TskTaskEvOptType BusyEvents)
{
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_NetGetTransportObject(TranspObjWinnerId);

  if(Dcm_NetGetProtIdOfActiveProtocol() != Dcm_NetGetProtIdOfTranspObj(pTranspObj))/* the winner is a different protocol as the old one -> interrupt the old protocol */
  {
    if( (Dcm_NetGetProtIdOfActiveProtocol() >= DCM_NET_INVALID_PROTID) /* very first protocol activation - start the protocol/send NRC 0x21 responses */
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
      ||(Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfTranspObj(pTranspObj)].Priority
         < Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfActiveProtocol()].Priority) /* new one is higher priority */
# endif
      ||( (((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE | DCM_DIAG_QUEUE_FLAG_IS_WAITING)
            & Dcm_InstanceContext.Diag.QueuedSet.Flags) == 0 ) /* if idle or post-processing (considered for back-to-back requests) ... */
        &&((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) != 0) ) /* ... still default session - continue with new request */
      )
    {
      Dcm_NetProcessStartProtocol(pTranspObj);                                                                                                       /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    }
    else
    {
      /* Mark busy for the winner */
      BusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, TranspObjWinnerId);
    }
  }
  else /* same protocol - proceed with the new request/NRC 0x21 responses */
  {
    Dcm_DiagRxIndication(pTranspObj);                                                                                                                /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
  return BusyEvents;
}
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessLoosers()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisationProcessLoosers(Dcm_TskTaskEvOptType BusyEvents)
{
  Dcm_CfgNetTObjHandleOptType lTObjCntr = 0u;

  DCM_TSK_EVENT_SCAN_LOOP(BusyEvents)
  {
    /* Check who did just loose */
    if(Dcm_TskIsLocalEventSet(BusyEvents, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTransportObject(lTObjCntr);
      Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

      Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                             /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      pTranspObj->Flags |= (Dcm_NetTransportObjectFlagType)(DCM_NET_TOBJ_FLAG_BUSY | DCM_NET_TOBJ_FLAG_IGNORE);                                      /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
# else
      Dcm_NetUnRegisterComMActivity(pTranspObj->ConnId);
      Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                               /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
# endif
    }
    ++lTObjCntr;
  }
}
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisation(Dcm_TskTaskEvOptType ev
                                                             ,Dcm_TskTaskEvPtrType pPostEv)                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lBusyEvents;
  Dcm_CfgNetTObjHandleOptType lTranspObjWinnerId;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lTranspObjWinnerId = Dcm_NetRxPrioritisation_FindWinner(ev, &lBusyEvents);                                                                         /* SBSW_DCM_POINTER_FORWARD_STACK */
  lBusyEvents = Dcm_NetRxPrioritisationProcessWinner(lTranspObjWinnerId, lBusyEvents);
  Dcm_NetRxPrioritisationProcessLoosers(lBusyEvents);
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetRegisterActiveConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRegisterActiveConnection(Dcm_NetTransportObjectPtrType pTranspObj)                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0)/* internal requests do not manage the S3 timer */
#endif
  {
    Dcm_DebugAssert((Dcm_SingletonContext.Network.NumActiveConnections != Dcm_UtiMaxValueOfUintType(uint8)), DCM_SID_INTERNAL, DCM_E_PARAM)          /* COV_DCM_RTM_DEV_DEBUG XF */

    /* Enter critical section (Reason: protect the statistic counter against parallel request notifications or transmission confirmations, executed from within interrupts ) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
     BEGIN CRITICAL SECTION
     *=================================*/
    if(Dcm_SingletonContext.Network.NumActiveConnections == 0u)
    {
      Dcm_TmrStopTimer(DCM_TMR_ID_S3);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
      Dcm_TmrStopTimer(DCM_TMR_ID_KEEP_ALIVE);
#endif
    }

    /* Register a new active connection */
    ++Dcm_SingletonContext.Network.NumActiveConnections;
    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetTransmitUsdtResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTransmitUsdtResponse(Dcm_NetTransportObjectPtrType pTranspObj)
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  boolean doCallTxConfirmation = TRUE;

  /* The Tx path must be still "ready" here. if not, check the caller - it shall take care about this state! */
  Dcm_DebugAssert((pTranspObj->State == DCM_NET_TOBJ_STATE_PREPTX), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                           /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Prepare the given transport object for USDT response transmission (set all relevant attributes to their initial values) */
  pTranspObj->BuffPos = 0u;                                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->State = DCM_NET_TOBJ_STATE_ONTX;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

  /* If the USDT response shall be suppressed for any non-diagnostic but transport protocol reasons (e.g. no response on functional requests or no TxPduId configured), do: */
#if (DCM_NET_SUPPRESS_ON_FUNC_REQ_ENABLED == STD_ON)
  if( (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_TX_ON_FUNC_RX))
    &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE) )
  {
    lStdResult = DCM_E_OK; /* No response on functional requests required -> leave with success */
  }
  else
#endif
#if (DCM_NET_CONNECTION_WITHOUT_TX_ENABLED == STD_ON)
  if (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_NO_MAIN_TX))
  {
    lStdResult = DCM_E_OK; /* No associated TxPduId -> leave with success */
  }
  else
#endif
  {
    /* Otherwise, if the communication mode on the ComM channel associated with the transport object still allows any response transmissions: */
    if((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByTranspObject(pTranspObj)) != 0)
    {
      lStdResult = PduR_DcmTransmit(Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnId].TxPduIdMain
                                  ,&pTranspObj->BuffInfo);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      /* If this transmission request was accepted, wait for the Tx-Confirmation from the XxxTp */
      if(lStdResult == E_OK)
      {
        doCallTxConfirmation = FALSE;
      }
    }
  }
  /* Otherwise, take the shortcut and loop-back through the USDT message confirmation with failed result (this response had to be sent, but couldn't and no retry is allowed (SWS)) */

  /* Make a loop-back and finalize transmission */
  if(doCallTxConfirmation == TRUE)
  {
    Dcm_NetUsdtTxConfirmation(pTranspObj, lStdResult);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}

#if (DCM_NET_CONN_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetLockConnectionOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetLockConnectionOrNull(Dcm_NetConnRefMemType connId)
{
  Dcm_NetTransportObjectPtrType pTranspObj;

  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Try allocating a new or getting an already allocated transport object */
  pTranspObj = Dcm_NetAllocateOrGetTranspObjectOrNull(connId);

  if(pTranspObj != NULL_PTR)
  {
    if(pTranspObj->State == DCM_NET_TOBJ_STATE_FREE)
    {
      Dcm_NetBufferContextPtrType pBufferContext;

      /* Setup the transport object */
      pTranspObj->ConnId = connId;                                                                                                                   /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
      pTranspObj->BufferHdl = Dcm_NetGetProtObjOfConnection(connId)->RxTxBufferRef;                                                                  /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

      pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

      /* Is the buffer still free ? */
      if(Dcm_NetBufferIsFree(pBufferContext))
      {
        Dcm_NetBufferLock(pBufferContext); /* the buffer is in use now */                                                                            /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
        pTranspObj->State  = DCM_NET_TOBJ_STATE_RESERVED;                                                                                            /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
      }
      else
      {
        Dcm_NetTranspObjRelease(pTranspObj);                                                                                                         /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        pTranspObj = NULL_PTR;
      }
    }
    else
    {
      pTranspObj = NULL_PTR;
    }
  }/* else - nothing found to be free */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  return pTranspObj;
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationNotOk()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationNotOk(Dcm_NetTransportObjectPtrType pTranspObj)
{
#if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) == 0) /* consider only real buffer usage */
#endif
  {
    Dcm_NetBufferContextPtrType pBufferContext;

    pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
  }
  Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
}

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationOk()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationOk(Dcm_NetTransportObjectPtrType pTranspObj)
{
#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0) /* CancelReceive was called before -> ignore request although reception couldn't be canceled */
  {
    Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
#endif
  {
    boolean keepTranspObj;
    keepTranspObj = Dcm_DiagAcceptNewRequest(pTranspObj);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    pTranspObj->State = DCM_NET_TOBJ_STATE_RX_END;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

    if(keepTranspObj == TRUE)
    {
      Dcm_NetRegisterComMActivity(pTranspObj);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
#if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) != 0)
      {
        Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
      }
      else
#endif
      {
        /* Store SID for RCR-RP/busy on protocol prioritisation responses */
        Dcm_NetWriteAddBufferU8At(pTranspObj, 1u, pTranspObj->RxData[0]);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        /* signal processing start */
#if (DCM_NET_TASK_RX_ENABLED == STD_ON)
        Dcm_TskSetEvent(DCM_TSK_ID_NET_RX, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));
#else
        Dcm_DiagRxIndication(pTranspObj);                                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
#endif
      }
    }
    else
    {
      Dcm_NetTpRxIndicationNotOk(pTranspObj);                                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
}

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerGet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerCntrOptType, DCM_CODE) Dcm_NetDelayTimerGet(uint8_least timer)
{
  return Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[timer];
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetDelayTimerSet(uint8_least timer, Dcm_TmrTimerCntrOptType timeout)
{
# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (timer >= DCM_NET_DELAY_BULK_TRANSMISSION)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETDELAYTIMERSET);
  }
  else
# endif
  {
    Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[timer] = (Dcm_TmrTimerCntrMemType)timeout;                                             /* SBSW_DCM_POINTER_WRITE_DELAYTIMER */
  }
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerExpired()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetDelayTimerExpired(uint8_least timer)
{
  return (boolean)(Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[timer] == 0u);
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerSet(Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
                                                           ,Dcm_TmrTimerCntrOptType timeout)
{
  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  pPeriodicTxObj->Timer = (Dcm_TmrTimerCntrMemType)timeout;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerStart(Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
                                                             ,Dcm_TmrTimerCntrOptType timeout)
{
  Dcm_NetPTxObjTimerSet(pPeriodicTxObj, timeout);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  if (!Dcm_TmrIsTimerRunning(DCM_TMR_ID_PERIODIC_TX))
  {
    Dcm_TmrStartTimer(DCM_TMR_ID_PERIODIC_TX, 1u);
  }
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerStop()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerStop(Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj)
{
  Dcm_NetPTxObjTimerSet(pPeriodicTxObj, 0u);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgIncNextDelayTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgIncNextDelayTimer(void)
{
  ++Dcm_SingletonContext.Network.PeriodicTxContext.NextDelayTimer;
  if (Dcm_NetPeriodicMsgGetNextDelayTimer() >= DCM_NET_DELAY_BULK_TRANSMISSION)
  {
    Dcm_NetPeriodicMsgResetNextDelayTimer();
  }
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgSetFastestRate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgSetFastestRate(Dcm_Svc2ASchedRateOptType Rate)
{
  /* If the new rate differs from the previous rate */
  if (Dcm_NetPeriodicMsgGetFastestRate() != Rate)
  {
    Dcm_TmrTimerCntrMemType lRateDiff;
    uint8_least lDelayTmrIter;

    /* If changing to a faster rate */
    if (Rate > Dcm_NetPeriodicMsgGetFastestRate())
    {
      lRateDiff = (Dcm_TmrTimerCntrMemType) ( Dcm_NetGetPeriodicDelayTime(Dcm_NetPeriodicMsgGetFastestRate())
                                            - Dcm_NetGetPeriodicDelayTime(Rate) );

      for (lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
      {
        /*=================================*
          BEGIN CRITICAL SECTION
         *=================================*/
        Dcm_SplitTaskEnterCS(); /* Protect against interrupt from timer task */                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
        /* If delay timer is set */
        if (Dcm_NetDelayTimerExpired(lDelayTmrIter) == FALSE)
        {
          if (Dcm_NetDelayTimerGet(lDelayTmrIter) <= lRateDiff)
          {
            Dcm_NetDelayTimerSet(lDelayTmrIter, 1); /* immediate timeout */
          }
          else
          {
            /* decrease timer value by rate difference */
            Dcm_NetDelayTimerSet(lDelayTmrIter, (Dcm_TmrTimerCntrOptType)(Dcm_NetDelayTimerGet(lDelayTmrIter) - lRateDiff));
          }
        }
        Dcm_SplitTaskLeaveCS();                                                                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
        /*=================================*
          END CRITICAL SECTION
         *=================================*/
      }
    }
    else /* Otherwise (changing to a slower rate) */
    {
      lRateDiff = (Dcm_TmrTimerCntrMemType) ( Dcm_NetGetPeriodicDelayTime(Rate)
                                            - Dcm_NetGetPeriodicDelayTime(Dcm_NetPeriodicMsgGetFastestRate()) );

      for (lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
      {
        /*=================================*
          BEGIN CRITICAL SECTION
         *=================================*/
        Dcm_SplitTaskEnterCS(); /* Protect against interrupt from timer task */                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
        /* If delay timer is set */
        if (Dcm_NetDelayTimerExpired(lDelayTmrIter) == FALSE)
        {
          /* increase timer value by rate difference */
          Dcm_NetDelayTimerSet(lDelayTmrIter, (Dcm_TmrTimerCntrOptType)(Dcm_NetDelayTimerGet(lDelayTmrIter) + lRateDiff));
        }
        Dcm_SplitTaskLeaveCS();                                                                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
        /*=================================*
          END CRITICAL SECTION
         *=================================*/
      }
    }

    Dcm_SingletonContext.Network.PeriodicTxContext.FastestRate = (Dcm_Svc2ASchedRateMemType)Rate;
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxDelayTimerStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxDelayTimerStart(void)
{
  Dcm_NetDelayTimerSet(Dcm_NetPeriodicMsgGetNextDelayTimer()
                      ,Dcm_NetGetPeriodicDelayTime(Dcm_NetPeriodicMsgGetFastestRate()));
  Dcm_NetPeriodicMsgIncNextDelayTimer();

  /* Make sure system timer for periodic tx is running */
  Dcm_TmrStartTimer(DCM_TMR_ID_PERIODIC_TX, 1u);
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutTxObjectHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutTxObjectHandler(void)
{
  Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;
  boolean                       lReloadTimer = FALSE;

  for(lPerTxObjIter = 0; lPerTxObjIter < Dcm_PbCfgNetNumPerTxObjects; ++lPerTxObjIter)
  {
    Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

    pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(lPerTxObjIter);
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvEnterCriticalSection(); /* protect against high level interrupts from the network interface */                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
    if(!Dcm_NetPTxObjTimerExpired(pPeriodicTxObj))
    {
      Dcm_NetPTxObjTimerSet(pPeriodicTxObj, (Dcm_TmrTimerCntrOptType)(Dcm_NetPTxObjTimerGet(pPeriodicTxObj)-1u));                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
      if(Dcm_NetPTxObjTimerExpired(pPeriodicTxObj))
      {
        (void)Dcm_NetArEnvPduRCancelTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(lPerTxObjIter)); /* try to cancel still ongoing Tx */
        Dcm_NetPeriodicMsgRelease(pPeriodicTxObj);                                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
      }
      else
      {
        lReloadTimer = TRUE; /* at least one active timer - reload timer */
      }
    }
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
  }

  return lReloadTimer;
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutDelayTimerHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutDelayTimerHandler(void)
{
  uint8_least lDelayTmrIter;
  boolean     lReloadTimer = FALSE;
  boolean     lSetTxEvent = FALSE;
  for(lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
  {
    if(Dcm_NetDelayTimerExpired(lDelayTmrIter) == FALSE)
    {
      Dcm_NetDelayTimerSet(lDelayTmrIter, (Dcm_TmrTimerCntrOptType)(Dcm_NetDelayTimerGet(lDelayTmrIter)-1u));
      if(Dcm_NetDelayTimerExpired(lDelayTmrIter) == TRUE)
      {
        Dcm_NetPeriodicMsgIncDelayCntr();
        lSetTxEvent = TRUE;
      }
      else
      {
        lReloadTimer = TRUE; /* at least one active timer - reload timer */
      }
    }
  }

  if (lSetTxEvent == TRUE)
  {
    Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_UUDT);
  }

  return lReloadTimer;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetGetPeriodicTxObject()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetPeriodicTxObjectPtrType, DCM_CODE) Dcm_NetGetPeriodicTxObject(
                                                                                   Dcm_CfgNetPTxObjHandleOptType index)
{
  Dcm_NetPeriodicTxObjectPtrType lResult;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= Dcm_PbCfgNetNumPerTxObjects)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETGETPERIODICTXOBJECT);
    lResult = &Dcm_PbRamNetPeriodicTxObject[0];
  }
  else
# endif
  {
    lResult = &Dcm_PbRamNetPeriodicTxObject[index];
  }

  return lResult;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgResetConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgResetConnection(void)
{
  Dcm_NetPeriodicMsgResetNextMsgHdl();
  Dcm_NetPeriodicMsgResetTxObjectSentCntr();
  Dcm_NetPeriodicMsgSetConnection(DCM_NET_INVALID_CONNID);
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgStopDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgStopDid(uint16 Did)
{
  Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;
  for (lPerTxObjIter = 0; lPerTxObjIter < Dcm_NetPeriodicMsgGetNextMsgHdl(); lPerTxObjIter++)
  {
    Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

    pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(lPerTxObjIter);

    if (  (pPeriodicTxObj->State != DCM_NET_PERIODIC_TX_STATE_FREE)
       && (pPeriodicTxObj->Did == Did))
    {
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
      Dcm_UtiArEnvEnterCriticalSection(); /* Enter critical section (Reason: Protect against high level interrupts from the network interface) */    /* PRQA S 3109 */ /* MD_MSR_14.3 */
      switch (pPeriodicTxObj->State)
      {
        case DCM_NET_PERIODIC_TX_STATE_ONTX:
          (void)Dcm_NetArEnvPduRCancelTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(lPerTxObjIter)); /* try to cancel still ongoing Tx */
          /* fall through */
        case DCM_NET_PERIODIC_TX_STATE_RESERVED:                                                                                                     /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
        case DCM_NET_PERIODIC_TX_STATE_QUEUED:
# endif
          Dcm_NetPeriodicMsgRelease(pPeriodicTxObj);                                                                                                 /* SBSW_DCM_POINTER_FORWARD_STACK */
          break;
        default:
          /* nothing to do */
          break;
      }
      Dcm_UtiArEnvLeaveCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
    }
  }
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgGetTxBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_MsgType, DCM_CODE) Dcm_NetPeriodicMsgGetTxBuffer(Dcm_CfgNetPTxObjHandleOptType perTxObjHandle)
{
  return Dcm_NetGetPeriodicTxObject(perTxObjHandle)->TxBuffer;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmitTxObj()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmitTxObj(Dcm_CfgNetPTxObjHandleOptType perTxObjHandle)
{
  Std_ReturnType lStdResult;
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

  pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(perTxObjHandle);

  if ((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByConnection(Dcm_NetPeriodicMsgGetConnection())) != 0)
  {
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
    if (Dcm_NetPeriodicMsgGetDelayCntr() == 0)
    {
      /* Retry sending */
      lStdResult = DCM_E_OK;
    }
    else
# endif
    {
      P2CONST(PduInfoType, AUTOMATIC, PDUR_APPL_DATA) pPduInfo;

      Dcm_NetPeriodicMsgDecDelayCntr();

      pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_ONTX;                                                                                        /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
      /* Note: In case the following two lines are not executed within 100ms, the timeout may occur before the message
       * was sent (only if split tasks used). This may lead to inconsistent periodic data, since the transmitted
       * message is free to be reused again while it is on transmission. The design avoiding this very rare scenario
       * will increase the software complexity unnecessarily. Entering such conditions means that the ECU is not
       * capable of holding the periodic rates too.
       */
      Dcm_NetPTxObjTimerStart(pPeriodicTxObj, Dcm_PbCfgNetConnectionInfo[Dcm_NetPeriodicMsgGetConnection()].PeriodicTxConfTimeout);                  /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */

      pPduInfo = &(pPeriodicTxObj->TxPduInfo);
      lStdResult = PduR_DcmTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(perTxObjHandle), pPduInfo);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
  else
  {
    lStdResult = DCM_E_NOT_OK;
  }

  if(lStdResult != DCM_E_OK)
  {
    /* Do not retry transmission -> make a loop-back and finalize transmission */
    Dcm_NetPeriodicMsgRelease(pPeriodicTxObj);                                                                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
  }
}
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTpTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpTxConfirmation(PduIdType txPduId
                                                             ,Dcm_NetArEnvNotifResultType result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfTxPduId(txPduId));

  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(pTranspObj == NULL_PTR)
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
  {
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    if(pTranspObj->State != DCM_NET_TOBJ_STATE_ONTX)
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
# endif
    {
      Dcm_NetUsdtTxConfirmation(pTranspObj, Dcm_NetArEnvGetTransmResult(result));                                                                    /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TXCONFIRMATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_NetIsPduInfoValid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsPduInfoValid(P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info)
{
  boolean lResult;

  if(info == NULL_PTR)
  {
    lResult = FALSE;
  }
  else if( (info->SduLength  != 0)
         &&(info->SduDataPtr == NULL_PTR) )
  {
    lResult = FALSE;
  }
  else
  {
    lResult = TRUE;
  }

  return lResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_NetCopyRxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyRxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                         ,P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info
                                                         ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr)
{
  BufReq_ReturnType lResult;
  uint8             lErrorId = DCM_E_NO_ERROR;

  /* #10 If the XxxTp (e.g. CanTp or FrTp) requests Dcm to copy any data: */
  if(info->SduLength != 0u) /* any payload now? */
  {
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    lResult = BUFREQ_E_NOT_OK;
    if (pTranspObj->BuffPos >= pTranspObj->RxLength)
    {
      lErrorId = DCM_E_PARAM;
    }
    else if((PduLengthType)(pTranspObj->RxLength - pTranspObj->BuffPos) < info->SduLength)
    {
      lErrorId = DCM_E_PARAM;
    }
    else
# endif
    {
# if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
      /* #30 If connection has been yet canceled (if RxPath supports cancellation), do return failed copy data result */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0)
      {
        lResult = BUFREQ_E_NOT_OK;
      }
      else
# endif
      {

        /* #40 If the transmission is for a main-client (full request reception), do copy the data portion provided by the XxxTp */
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
        if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) != 0)
        {
          /* #50 For the very first call of this function for this request reception, do copy the request head (SID and SubFunction) for later usage (i.e. for 0x3E 0x80 detection) */
          if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_COPYHEAD) != 0)
          {
            Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_COPYHEAD);  /* Toggle flag for next calls to not extract any SID/SUBSID data */ /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */ /* SBSW_DCM_PARAM_PTR_WRITE */
            Dcm_NetWriteAddBufferU8At(pTranspObj, 1, info->SduDataPtr[0]); /* copy the SID */                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
            Dcm_NetWriteAddBufferU8At(pTranspObj, 2, info->SduDataPtr[1]); /* copy the SUBSID */                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
          }
        }
        else
# endif
        {
          Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

          lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

          Dcm_UtiMemCopySafe(info->SduDataPtr
                            ,lBufferInfo->BufferPtr
                            ,pTranspObj->BuffPos
                            ,lBufferInfo->Size
                            ,info->SduLength);                                                                                                       /* SBSW_DCM_POINTER_WRITE_BUFFERINFO */
        }
        /* #60 Update the transport object's buffer-copy-progress */
        pTranspObj->BuffPos += (Dcm_CfgNetBufferSizeMemType)(info->SduLength);                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

        /* #70 Report the remaining available DCM buffer size to the XxxTp */
        *bufferSizePtr = (PduLengthType)(pTranspObj->RxLength - pTranspObj->BuffPos);                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = BUFREQ_OK;
      }
    }
    /* #80 Otherwise if connection has been canceled, return negative result to signal the XxxTp to abort the transmission (if RxPath supports cancellation) */
  }
  else
  {
    /* #90 Otherwise, the XxxTp requests Dcm only to report the available buffer size  */
    *bufferSizePtr = (PduLengthType)(pTranspObj->RxLength - pTranspObj->BuffPos); /* Notify lower layer about available buffer space */              /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = BUFREQ_OK;
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COPYRXDATA, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndication(PduIdType rxPduId
                                                           ,Dcm_NetArEnvNotifResultType result)
{
  Dcm_NetTransportObjectPtrType pTranspObj;
  pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfRxPduId(rxPduId));

  /* If no transport object has been associated with this connection yet, do ignore this indication */
  if(pTranspObj != NULL_PTR)
  {
    /* Otherwise, if the transport object is determined to belong to the expected request, that means: */
    if( (pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX) /* expected state for Rx indication? */
      &&(rxPduId == pTranspObj->RxPduId) ) /* Consider also any nested request on different TP connection but from the same tester! */
    {
      if(result != DCM_NET_ARENV_NTFRSLT_OK)
      {
        Dcm_NetTpRxIndicationNotOk(pTranspObj);                                                                                                      /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
      else
      {
        Dcm_NetTpRxIndicationOk(pTranspObj);                                                                                                         /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }/* Otherwise, just ignore this call since this API call is most probably due to a (concurrent request (i.e. 0x3E 0x80) from the same tester) OR
      * (indication of unexpected connection) */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetCopyLinearTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyLinearTxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                      ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                             /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                      ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr)
{
  BufReq_ReturnType lResult;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = BUFREQ_E_NOT_OK;

  if( (info->SduLength != 0u)
    &&(pTranspObj->BuffPos >= pTranspObj->BuffInfo.SduLength) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else if((PduLengthType)(pTranspObj->BuffInfo.SduLength - pTranspObj->BuffPos) < info->SduLength)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    /* Copy requested amount of data to the XxxTp */
    Dcm_UtiMemCopySafe(&(pTranspObj->BuffInfo.SduDataPtr[pTranspObj->BuffPos])
                      ,info->SduDataPtr
                      ,0u
                      ,info->SduLength
                      ,info->SduLength);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
    /* Update Tx-buffer read progress */
    pTranspObj->BuffPos += (Dcm_CfgNetBufferSizeMemType)(info->SduLength);                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Report remaining amount of data in the Tx-buffer */
    *availableDataPtr = (PduLengthType)(pTranspObj->BuffInfo.SduLength - pTranspObj->BuffPos);                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = BUFREQ_OK;
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COPYTXDATA, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetCopyTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyTxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                      ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                             /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                      ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr)
{
  BufReq_ReturnType lResult;

# if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0)
  {
    lResult = BUFREQ_E_NOT_OK;
  }
  else
# endif
  {
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
    if(pTranspObj->ResType == DCM_NET_TOBJ_RESTYPE_PAGED)
    {
      lResult = Dcm_PagedBufferCopyData(info, availableDataPtr);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
# endif
    {
      lResult = Dcm_NetCopyLinearTxData(pTranspObj, info, availableDataPtr);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }

  return lResult;
}
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_RepeaterNextStep()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_RepeaterNextStep(Dcm_RepeaterProgressType nextStep)
{
  Dcm_InstanceContext.Repeater.Contexts.Progress = nextStep;
  Dcm_RepeaterResetOpStatus();
}

/**********************************************************************************************************************
 *  Dcm_CfgDiagServiceInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgDiagServiceInfoPtrType, DCM_CODE) Dcm_CfgDiagServiceInfoGetEntryOrNull(uint8_least SidIndex)
{
  Dcm_CfgDiagServiceInfoPtrType lServiceInfo;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SidIndex >= DCM_CFGDIAGSERVICEINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGDIAGSERVICEINFOGETENTRY);
    lServiceInfo = NULL_PTR;
  }
  else
#endif
  {
    lServiceInfo = &Dcm_CfgDiagServiceInfo[SidIndex];
  }

  return lServiceInfo;
}
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_ModeInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeInit(void)
{
  /* Initialize ControlDTCsetting internal mode */
  Dcm_ModeSetControlDtcSettingGroup(DEM_DTC_GROUP_ALL_DTCS);
  Dcm_ModeSetControlDtcSettingMode(RTE_MODE_DcmControlDtcSetting_ENABLEDTCSETTING);

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  /* Initialize CommunicationControl internal mode */
  {
    uint8_least channelIter;
    for(channelIter = 0; channelIter < Dcm_PbCfgNetNumAllComMChannels; ++channelIter)
    {
      Dcm_ModeSetCommControlState(channelIter, DCM_ENABLE_RX_TX_NORM_NM);
    }
  }
# endif
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID = DCM_NET_DEFAULT_DEM_CLIENTID;
# endif
}

# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgModeMgrRulesGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_ModeRuleFuncType, DCM_CODE) Dcm_CfgModeMgrRulesGetEntryOrNull(Dcm_CfgModeMgrRuleRefOptType modeRuleRef)
{
  Dcm_ModeRuleFuncType lModeRuleFunc;

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (modeRuleRef >= DCM_CFGMODEMGRRULES_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGMODEMGRRULESGETENTRY);
    lModeRuleFunc = NULL_PTR;
  }
  else
#  endif
  {
    lModeRuleFunc = Dcm_CfgModeMgrRules[modeRuleRef];
  }

  return lModeRuleFunc;
}
# endif

# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeCheck(Dcm_CfgModeMgrRuleRefOptType modeRuleRef
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;
  Dcm_NegativeResponseCodeType lNrc = DCM_E_CONDITIONSNOTCORRECT;/* default NRC in case no rule specifies any NRC */
  Dcm_ModeRuleFuncType lModeRuleFunc;

  /* Retrieve mode rule verification handler */
  lModeRuleFunc = Dcm_CfgModeMgrRulesGetEntryOrNull(modeRuleRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (lModeRuleFunc == NULL_PTR)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_MODECHECK);
    lNrc = DCM_E_PANIC_NRC;
  }
  else
#  endif
  {
    /* Execute the mode-rule handler and return the result */
    if(lModeRuleFunc(&lNrc) == TRUE)                                                                                                                 /* SBSW_DCM_CALL_FUNCPTR_MODEMGRRULES */
    {
      lStdReturn = DCM_E_OK;
    }
  }

  *ErrorCode = lNrc;                                                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
  return lStdReturn;
}
# endif

# if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeMonitorControlDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeMonitorControlDtcSetting(Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_NegativeResponseCodeType lNrc;/* the value is not used, just the standard API requires it */
  Dcm_ModeRuleFuncType lModeRuleFunc;

  lModeRuleFunc = Dcm_CfgModeMgrRulesGetEntryOrNull(DCM_MODE_CTRLDTCSETTING_MONITOR_MODERULE_REF);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (lModeRuleFunc == NULL_PTR)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_MODEMONITORCONTROLDTCSETTING);
    /* Try to recover immediately since something obviously went wrong and no automatic recovery will take place later */
    /* fire and forget */
    (void)Dcm_Svc85EnableDtcSetting(Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID);
  }
  else
#  endif
  {
    if (lModeRuleFunc(&lNrc) == TRUE)                                                                                                                /* SBSW_DCM_CALL_FUNCPTR_MODEMGRRULES */
    {
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_MODE_MON_SVC85);                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* fire and forget */
      (void)Dcm_Svc85EnableDtcSetting(Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID);
    }
  }
}
# endif

# if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeMonitorCommunicationControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeMonitorCommunicationControl(Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_NegativeResponseCodeType lNrc;/* the value is not used, just the standard API requires it */
  Dcm_ModeRuleFuncType lModeRuleFunc;

  lModeRuleFunc = Dcm_CfgModeMgrRulesGetEntryOrNull(DCM_MODE_COMMCTRL_MONITOR_MODERULE_REF);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (lModeRuleFunc == NULL_PTR)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_MODEMONITORCOMMUNICATIONCONTROL);
    /* Try to recover immediately since something obviously went wrong and no automatic recovery will take place later */
    Dcm_Svc28EnableCommunication();
  }
  else
#  endif
  {
    if (lModeRuleFunc(&lNrc) == TRUE)                                                                                                                /* SBSW_DCM_CALL_FUNCPTR_MODEMGRRULES */
    {
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_MODE_MON_SVC28);                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      Dcm_Svc28EnableCommunication();
    }
  }
}
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON) || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(void)
{
  return DCM_E_OK;/* always succeeds */
}
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON) || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(Dcm_ResetModeType mode)
{
  BswM_Dcm_RequestResetMode(mode);
  return DCM_E_OK;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)   || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckResultInterpreter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckResultInterpreter(Std_ReturnType modeSwitchAckResult)
{
  Std_ReturnType lStdResult;

  switch(modeSwitchAckResult)
  {
  case RTE_E_TRANSMIT_ACK:
    /* switch accomplished */
    lStdResult = DCM_E_OK;
    break;
  case RTE_E_NO_DATA:
    lStdResult = DCM_E_PENDING;
    break;
  default: /* any error situation */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(void)
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_SwitchAck_DcmEcuReset_DcmEcuReset();

  return Dcm_ModeSwitchAckResultInterpreter(lStdResult);
}
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckRapidShutDown()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckRapidShutDown(void)
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_SwitchAck_DcmModeRapidPowerShutDown_DcmModeRapidPowerShutDown();

  return Dcm_ModeSwitchAckResultInterpreter(lStdResult);
}
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(Rte_ModeType_DcmEcuReset mode)
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_Switch_DcmEcuReset_DcmEcuReset(mode);

  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
  return lStdResult;
}
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchRapidShutDown()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchRapidShutDown(Rte_ModeType_DcmModeRapidPowerShutDown mode)
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_Switch_DcmModeRapidPowerShutDown_DcmModeRapidPowerShutDown(mode);

  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
  return lStdResult;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_StateInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateInit(void)
{
  Dcm_SingletonContext.StateMgr.Preconditions.Session  = DCM_STATE_VALUE_SESSION_INIT;
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  Dcm_SingletonContext.StateMgr.Preconditions.Security = DCM_STATE_VALUE_SECURITY_INIT;
#endif

  Dcm_StateSyncPendingSession();
}

#if (DCM_STATE_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateExecOnStateChangeFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateNotificationInfoPtrType notifList                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,uint8 formerStateId
                                                                    ,uint8 newStateId)
{
  /* Iterate over all with the diagnostic state group state change related notifications, as long as the EndOfList marker is not reached */
  while(notifList->OnChgFunc != NULL_PTR)
  {
    /* Invoke the configured notification function */
    notifList->OnChgFunc(formerStateId, newStateId);                                                                                                 /* SBSW_DCM_PARAM_FUNCPTR_CALL */
    Dcm_UtiNextItemByPtr(notifList,1u);/* take next function */
  }
}
#endif

#if (DCM_STATE_SECURITY_LOOKUP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateFindStateIndexFromSecLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint8_least, DCM_CODE) Dcm_StateFindStateIndexFromSecLevel(Dcm_SecLevelType secLevel)
{
  sint8_least lResult;

  /* #10 If "locked" level: */
  if(secLevel == DCM_SEC_LEV_LOCKED)
  {
    /* #20 Return the only possible index - 0 */
    lResult = 0;
  }
  else
  {
    /* #30 Otherwise locate the index of the security level value in the security info table */
    uint8_least lSecLvlIter;

    lResult = -1;
    for(lSecLvlIter = 0; lSecLvlIter < DCM_STATE_SECURITY_NUM_LEVELS; ++lSecLvlIter)
    {
      if (Dcm_CfgStateSecurityInfo[lSecLvlIter].Value == secLevel)
      {
        /* #40 Found the correct index into the table - compensate zero offset for locked level */
        lResult = (sint8_least)(lSecLvlIter + 1);
        break;
      }
    }
    /* #50 If the security level is not found, return -1 */
  }
  /* #60 Return final result */
  return lResult;
}
#endif

#if ((DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)  &&  (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON))
/**********************************************************************************************************************
*  Dcm_StateVsgGetSecurityFixedByteStateIdx()
*********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateVsgGetSecurityFixedByteStateIdx(
                                                            P2VAR(sint32_least, AUTOMATIC, DCM_APPL_DATA) pStateIndex)
{
  Std_ReturnType lStdResult;
  Dcm_CfgVarMgrDiagVariantIdOptType varRowIter;
  Dcm_VsgSizeType lNumberOfFixedBytes;
  sint32_least lRefToVsg;

  lRefToVsg = (sint32) Dcm_StateGetVsgMaskInfoIdx(*pStateIndex);
  lStdResult = DCM_E_NOT_OK;

  /* If there is any Securtiy Level with more than 1 security fixed byte configured */
  lNumberOfFixedBytes = Dcm_StateGetNumberOfVsgs(*pStateIndex);

  /* Iterate over all securtiy fixed bytes that are assigned to referenced security level */
  /* If lNumberOfFixedBytes is 0 -> no security fixed byte is configured for securtiy level */
  for (; lNumberOfFixedBytes > 0; --lNumberOfFixedBytes)
  {
    varRowIter = Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_CFG_VARIANTS);

    /* scan all variants (at least 8 way scan) for at least one match */
    do
    {
      --varRowIter;
      if ((Dcm_CfgStateVsgMaskSecurityFixedByte[lRefToVsg][varRowIter] & Dcm_SingletonContext.VarMgr.ActiveCfgVariants[varRowIter]) != 0)
      {
        lStdResult = DCM_E_OK;/* at least one matched variant */
        *pStateIndex = lRefToVsg;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
        break;
      }/* else - continue searching */
    } while (varRowIter != 0);                                                                                                                       /* PRQA S 3356, 3360 */ /* MD_Dcm_3356, MD_Dcm_3360 */

    /* If security level is assigned to active VSG */
    if (lStdResult == DCM_E_OK)
    {
      /* stop iterating over fixed bytes */
      break;
    }

    ++lRefToVsg;
  }

  return lStdResult;
}
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateGetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateGetSecurityLevelFixedBytes(Dcm_SecLevelType secLevel
                                                                    ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) fixedBytes
                                                                    ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) bufferSize)
{
  Std_ReturnType  lResult;
  sint32_least    lStateIdx;

  lStateIdx = Dcm_StateFindStateIndexFromSecLevel(secLevel);
  if (lStateIdx <= 0)
  {
    /* Locked, or unsupported security level */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    uint8 lFixedByteSize;
    --lStateIdx; /* norm to zero index (excluded locked state offset) */

# if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
    lResult = Dcm_StateVsgGetSecurityFixedByteStateIdx(&lStateIdx);                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
    if (lResult == DCM_E_NOT_OK)
    {
      lFixedByteSize = 0;
      lResult = E_OK;
    }
    else
# endif
    {
      lFixedByteSize = (uint8)(Dcm_CfgStateSecurityFixedByteInfo[lStateIdx + 1]
                             - Dcm_CfgStateSecurityFixedByteInfo[lStateIdx + 0]);
      if (lFixedByteSize > *bufferSize)
      {
        lResult = DCM_E_BUFFERTOOLOW;
      }
      else
      {
        Dcm_UtiMemCopySafe(&Dcm_CfgStateSecurityFixedBytes[Dcm_CfgStateSecurityFixedByteInfo[lStateIdx]]
                          ,fixedBytes
                          ,0u
                          ,*bufferSize
                          ,lFixedByteSize);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
        lResult = E_OK;
      }
    }
    *bufferSize = lFixedByteSize;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_StateNotifyServiceProcessors()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateNotifyServiceProcessors(void)
{
  /* now process session/security state updates:
    - on any session transition: security is always changed
    - on security state transition: security is always changed
  */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc27OnStateChanged();
#endif
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2COnStateChanged();
#endif
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2AOnStateChanged();
#endif
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2FOnStateChanged();
#endif
}
/**********************************************************************************************************************
 *  Dcm_TskGetTaskInfoOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskInfoPtrType, DCM_CODE) Dcm_TskGetTaskInfoOrNull(Dcm_TskTaskIdOptType index)
{
  Dcm_TskTaskInfoPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_TSK_NUM_TASKS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TSKGETTASKINFO);
    lResult = NULL_PTR;
  }
  else
#endif
  {
    lResult = &Dcm_TskTaskInfo[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_TskGetTaskContextOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskContextPtrType, DCM_CODE) Dcm_TskGetTaskContextOrNull(Dcm_TskTaskIdOptType taskId)
{
  Dcm_TskTaskContextPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(taskId >= DCM_TSK_NUM_TASKS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TSKGETTASKCONTEXT);
    lResult = NULL_PTR;
  }
  else
#endif
  {
    lResult = &Dcm_SingletonContext.TaskMgr.TaskContext[taskId];
  }

  return lResult;
}

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskRegisterActiveTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskRegisterActiveTask(Dcm_TskTaskIdOptType taskId)
{
  /* Enter critical section (Reason: To guarantee safe reentrancy policy for the task stack when split-tasks interrupt each other.) */
  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(Dcm_TskTraceIsFull())
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TSKREGISTERACTIVETASK);
  }
  else
# endif
  {
    Dcm_TskTraceTskPush(taskId);                                                                                                                     /* PRQA S 3440 */ /* MD_Dcm_OptimizedInlineCode_3440 */ /* SBSW_DCM_POINTER_WRITE_CURRENT_TASK_PRIO_STACK */
  }

  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();
}
#endif

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskUnRegisterActiveTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskUnRegisterActiveTask(void)
{
  /* Enter critical section (Reason: To guarantee safe reentrancy policy for the task stack when split-tasks interrupt each other.) */
  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(Dcm_TskTraceIsEmpty())
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TSKUNREGISTERACTIVETASK);
  }
  else
# endif
  {
    Dcm_TskTraceTskPop();
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();
}
#endif

/**********************************************************************************************************************
 *  Dcm_TskGetSchedulerContextOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskSchedulerContextPtrType, DCM_CODE) Dcm_TskGetSchedulerContextOrNull(
                                                                                  Dcm_TskTaskPrioOptType schedulerPrio)
{
  Dcm_TskSchedulerContextPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(schedulerPrio >= DCM_TSK_NUM_PRIOS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TSKGETSCHEDULERCONTEXT);
    lResult = NULL_PTR;
  }
  else
#endif
  {
    lResult = &Dcm_SingletonContext.TaskMgr.TaskScheduler[schedulerPrio];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_TskInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskInit(void)
{
  /* #10 Initialize task activity tracer */
  Dcm_TskTraceInit();

  /* #20 Initialize priority related states */
  {
    Dcm_TskTaskPrioOptType tskPrioIter;

    for(tskPrioIter = 0; tskPrioIter < DCM_TSK_NUM_PRIOS; ++tskPrioIter)
    {
      Dcm_TskSchedulerContextPtrType pSchedulerContext;
      pSchedulerContext = Dcm_TskGetSchedulerContextOrNull(tskPrioIter);
      pSchedulerContext->SchdIsActive = FALSE;                                                                                                       /* SBSW_DCM_POINTER_WRITE_SCHEDULERCONTEXT */
    }
  }

  /* #30 Initialize task related events */
  {
    Dcm_TskTaskIdOptType tskIter;

    for(tskIter = 0; tskIter < DCM_TSK_NUM_TASKS; ++tskIter)
    {
      Dcm_TskTaskContextPtrType pTaskContext;
      pTaskContext = Dcm_TskGetTaskContextOrNull(tskIter);
      pTaskContext->TaskEvents = DCM_TSK_EV_NONE;                                                                                                    /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
    }
  }
}

#if (DCM_TSK_TASK_KILL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskKillAllTasks()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskKillAllTasks(void)
{
  Dcm_TskTaskIdOptType tskIter;

  /* Enter critical section (Reason: A task event can be set during any ISR processing.) */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/

   for(tskIter = 0; tskIter < DCM_TSK_NUM_TASKS; ++tskIter)
   {
     if((Dcm_TskTaskInfo[tskIter].TskAtr & DCM_TSK_ATR_KILL_ALWAYS) != 0)
     {
       Dcm_TskTaskContextPtrType pTaskContext = Dcm_TskGetTaskContextOrNull(tskIter);
       pTaskContext->TaskEvents &= Dcm_TskTaskInfo[tskIter].NonKillEvents; /* clear only killable events */                                          /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */

# if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)
       Dcm_TskSetFlag(pTaskContext, DCM_TSK_TASK_FLAG_KILLED);                                                                                       /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
# endif
     }
   }

  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}
#endif

#if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskReviveAllTasks()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskReviveAllTasks(void)
{
   Dcm_TskTaskIdOptType tskIter;

   for(tskIter = 0; tskIter < DCM_TSK_NUM_TASKS; ++tskIter)
   {
     Dcm_TskTaskContextPtrType pTaskContext = Dcm_TskGetTaskContextOrNull(tskIter);
     Dcm_TskClrFlag(pTaskContext, DCM_TSK_TASK_FLAG_KILLED);                                                                                         /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */ /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
   }
}
#endif

/**********************************************************************************************************************
 *  Dcm_TskScheduleActiveTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskExecuteActiveTask(Dcm_TskTaskIdOptType taskId
                                                              ,Dcm_TskTaskEvOptType taskEv)
{
  Dcm_TskTaskInfoPtrType lTaskInfo;

  lTaskInfo = Dcm_TskGetTaskInfoOrNull(taskId);

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(lTaskInfo != NULL_PTR)                                                                                                                          /* COV_DCM_RTM_RUNTIME_CHECK TX */
#endif
  {
    Dcm_TskTaskEvOptType postEv = DCM_TSK_EV_NONE;

    /* Handle task execution: */
    do
    {
      /* Clear all already known global events */
      Dcm_TskClrEvent(taskId, (Dcm_TskTaskEvMemType)taskEv);

      /* Register the taskID to the task trace */
      Dcm_TskRegisterActiveTask(taskId);

      /* Execute the task */
      lTaskInfo->TskFunc(taskEv, &postEv);                                                                                                           /* SBSW_DCM_CALL_FUNCPTR_TASKINFO */

      /* Unregister the taskID from the task trace */
      Dcm_TskUnRegisterActiveTask();

      /* If the task supports multiple activations per scheduler invocation, do get any new events sent to this task */
      if((lTaskInfo->TskAtr & DCM_TSK_ATR_EXEC_MULTI) != 0)
      {
        taskEv = Dcm_TskGetEvent(taskId);
      }
      else
      {
        /* Otherwise do not re-activate the task in this scheduler invocation */
        taskEv = DCM_TSK_EV_NONE;
      }
    }
    /* As long as the task needs the be re-activated */
    while(taskEv != DCM_TSK_EV_NONE);

    /* Register any new events of the already finished task that are scheduled for its next activation */
    if(postEv != DCM_TSK_EV_NONE)
    {
      Dcm_TskSetEvent(taskId, (Dcm_TskTaskEvMemType)postEv);
    }
  }
}
/**********************************************************************************************************************
 *  Dcm_TmrGetTimerInfoOrNull()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerInfoPtrType, DCM_CODE) Dcm_TmrGetTimerInfoOrNull(Dcm_TmrTimerIdOptType index)
{
  Dcm_TmrTimerInfoPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_TMR_NUM_TIMERS_CASTED)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TMRGETTIMERINFO);
    lResult = NULL_PTR;
  }
  else
#endif
  {
    lResult = &Dcm_TmrTimerInfo[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_TmrSetTimer()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrSetTimer(Dcm_TmrTimerIdOptType timerId, Dcm_TmrTimerCntrMemType value)
{
#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(timerId >= DCM_TMR_NUM_TIMERS_CASTED)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TMRSETTIMER);
  }
  else
#endif
  {
    Dcm_SingletonContext.TimerMgr.Timer[timerId] = value;                                                                                            /* SBSW_DCM_POINTER_WRITE_TIMER */
  }
}

/**********************************************************************************************************************
 *  Dcm_TmrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrInit(void)
{
  Dcm_SingletonContext.TimerMgr.RunningMask = 0; /* mark all timers as not running */
}
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgRidMgrOpInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RidMgrOpInfoPtrType, DCM_CODE) Dcm_CfgRidMgrOpInfoGetEntryOrNull(Dcm_CfgRidMgrOpHandleOptType ridOpInfoIdx)
{
  Dcm_RidMgrOpInfoPtrType lRidOpInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (ridOpInfoIdx >= DCM_CFGRIDMGROPINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGRIDMGROPINFOGETENTRY);
    lRidOpInfo = NULL_PTR;
  }
  else
# endif
  {
    lRidOpInfo = &Dcm_CfgRidMgrOpInfo[ridOpInfoIdx];
  }

  return lRidOpInfo;
}

/**********************************************************************************************************************
 *  Dcm_RidMgrExecuteRoutine()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrExecuteRoutine(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc31RepeaterProxyContextPtrType pRepContext)                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType                       lStdResult;
  Dcm_CfgRidMgrRoutineInfoByteMemType  lRoutineInfoByte;
  Dcm_RidMgrOpInfoPtrType              pRidOpInfo;

  lRoutineInfoByte = Dcm_CfgRidMgrRidInfoRoutineInfoByte(pRepContext->RidInfoIdx);
  pRidOpInfo       = Dcm_CfgRidMgrOpInfoGetEntryOrNull(pRepContext->RidOpInfoIdx);

  /*
   * If the RID supports routine info byte, reserve 1 byte in response buffer by moving response buffer pointer
   * Note: Do not write the routine info byte yet since this would overwrite the request data (IN-parameter)
   *       Provide the routine info byte as a placeholder before checking the remaining response buffer size
   */
  if( (opStatus == DCM_INITIAL)
    &&(lRoutineInfoByte != DCM_CFGRIDMGR_INVALID_ROUTINEINFOBYTE) )
  {
    Dcm_DiagProvideResData(pMsgContext, 1u);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pRidOpInfo == NULL_PTR)                                                                                                                       /* PRQA S 3415 */ /* MD_Dcm_3415 */
    ||(Dcm_DiagMsgContextVerifySize(pMsgContext, pRidOpInfo->ResMaxLength) == FALSE) )                                                               /* COV_DCM_RTM_RUNTIME_CHECK TF xf xf */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
# endif
  {
    Dcm_RidMgrRidLengthType lReqResLen = (Dcm_RidMgrRidLengthType)(pMsgContext->reqDataLen - pRidOpInfo->ReqMinLength);

    /* Call appropriate function prototype */
    switch(pRidOpInfo->OpType)
    {
    case DCM_RIDMGR_OPTYPE_NONE:
      lStdResult = ((Dcm_RidMgrOpFuncNoParamsType)pRidOpInfo->OpFunc)(opStatus                                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                     ,ErrorCode);                                                                    /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
      break;
    case DCM_RIDMGR_OPTYPE_REQ:
      lStdResult = ((Dcm_RidMgrOpFuncReqType)pRidOpInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                ,opStatus
                                                                ,ErrorCode);                                                                         /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
      break;
    case DCM_RIDMGR_OPTYPE_REQ_RES:
      lStdResult = ((Dcm_RidMgrOpFuncReqResType)pRidOpInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                   ,opStatus
                                                                   ,Dcm_DiagGetResData(pMsgContext)                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                   ,ErrorCode);                                                                      /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
      break;
    case DCM_RIDMGR_OPTYPE_RES:
      lStdResult = ((Dcm_RidMgrOpFuncResType)pRidOpInfo->OpFunc)(opStatus                                                                            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                ,Dcm_DiagGetResData(pMsgContext)                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                ,ErrorCode);                                                                         /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
      break;
    case DCM_RIDMGR_OPTYPE_REQ_DYNLEN:
      lStdResult = ((Dcm_RidMgrOpFuncReqDynLenType)pRidOpInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                      ,opStatus
                                                                      ,lReqResLen
                                                                      ,ErrorCode);                                                                   /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
      break;
    case DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES:
      lStdResult = ((Dcm_RidMgrOpFuncReqDynLenResType)pRidOpInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                         ,opStatus
                                                                         ,Dcm_DiagGetResData(pMsgContext)                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                         ,lReqResLen
                                                                         ,ErrorCode);                                                                /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
      break;
    case DCM_RIDMGR_OPTYPE_RES_DYNLEN:
      lStdResult = ((Dcm_RidMgrOpFuncResDynLenType)pRidOpInfo->OpFunc)(opStatus                                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                      ,Dcm_DiagGetResData(pMsgContext)                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                      ,&lReqResLen
                                                                      ,ErrorCode);                                                                   /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
      break;
    case DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN:
      /* fall through */
    case DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN:                                                                                                           /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
      lStdResult = ((Dcm_RidMgrOpFuncReqAnyLenResDynLenType)pRidOpInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                               ,opStatus
                                                                               ,Dcm_DiagGetResData(pMsgContext)                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                               ,&lReqResLen
                                                                               ,ErrorCode);                                                          /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
      break;
    case DCM_RIDMGR_OPTYPE_WRAPPER:
      lStdResult = ((Dcm_RidMgrOpFuncWrapperType)pRidOpInfo->OpFunc)(opStatus                                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                    ,pMsgContext
                                                                    ,&lReqResLen
                                                                    ,ErrorCode);                                                                     /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
      break;
# if (DCM_DIDMGR_IO_CONTROL_SUPPORTEDDID_ENABLED == STD_ON)
    case DCM_RIDMGR_OPTYPE_SUPP_ID_WRAPPER:
      lStdResult = ((Dcm_RidMgrOpFuncSuppIDWrapperType)pRidOpInfo->OpFunc)(pMsgContext);                                                             /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
      break;
# endif
    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }

    /* If the operation result is success: */
    if(lStdResult == DCM_E_OK)
    {
      /* Provide the data to the response message, including the variable length part */
      Dcm_DiagProvideResData(pMsgContext, Dcm_CfgRidMgrOpInfoResMinLength(pRepContext->RidOpInfoIdx));                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(pRidOpInfo->ResMinLength != pRidOpInfo->ResMaxLength)
      {
        Dcm_DiagProvideResData(pMsgContext, lReqResLen); /* Register response length of the last signal  */                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      }

      /* Place the routine info byte, if applicable */
      if(lRoutineInfoByte != DCM_CFGRIDMGR_INVALID_ROUTINEINFOBYTE)
      {
        Dcm_DiagSetResDataAsU8At(pMsgContext, DCM_RIDMGR_ROUTINEINFOBYTE_IDX, (uint8)lRoutineInfoByte);                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }
  }

  /* Catch any RTE specific or unexpected errors in order to return a valid value to the core */
  if( (lStdResult != DCM_E_OK)
    &&(lStdResult != DCM_E_PENDING)
    &&(lStdResult != DCM_E_NOT_OK)
    &&(lStdResult != DCM_E_FORCE_RCRRP) )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  Dcm_DiagHandleApplNrc(lStdResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
/**********************************************************************************************************************
 *  Dcm_RidMgrGetOpInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrGetOpInfo(Dcm_CfgRidMgrInfoHandleOptType ridInfoIdx
                                                                   ,Dcm_RidMgrOpType ridOp
                                                                   ,Dcm_CfgRidMgrOpHandlePtrType pRidOpInfoIdx)
{
  Std_ReturnType lResult = DCM_E_NOT_OK;

  /* If the requested operation is supported at all */
  if ((Dcm_CfgRidMgrRidInfoOperations(ridInfoIdx) & ridOp) != 0)
  {
    Dcm_CfgRidMgrOpHandleOptType opHandle = Dcm_CfgRidMgrRidInfoOpBaseIdx(ridInfoIdx);
    do
    {
      ridOp>>= 1;/* pre-decrement! */
      if ((Dcm_CfgRidMgrRidInfoOperations(ridInfoIdx) & ridOp) != 0)
      {
        ++opHandle;
      }
    }
    while(ridOp != 0);
    *pRidOpInfoIdx = opHandle;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUpFilter(uint16 rid
                                                                         ,Dcm_CfgRidMgrInfoHandleOptType ridInfoIdx)
{
  Std_ReturnType lStdReturn = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(rid);                                                                                                                       /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ridInfoIdx);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
# if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  if (Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgRidMgrRidInfoExecCondRef(ridInfoIdx)) == FALSE)
  {
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  /* check session state */
  if (!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(Dcm_CfgRidMgrRidInfoExecCondRef(ridInfoIdx))))
  {
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
# if (DCM_SVC_31_OBD_CALIBRATION_ENABLED == STD_ON) && (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
    if( (rid >= (uint16)0xE000u)
      &&(rid <= (uint16)0xE1FFu) )
    {
      if(Dcm_ObdIdMgrIsIdEnabled(Dcm_UtiGetLoByte(rid),
                                     &Dcm_CfgSvc31SupportedIdMask[Dcm_CfgSvc31SupportedIdMaskOffset[Dcm_UtiGetHiByte(rid)-(uint8)0xE0u]]) == FALSE)  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
      {
        lStdReturn = DCM_E_NOT_OK;
      }/* else - an enabled (WWH-)OBD RID */
    }/* else - a non (WWH-)OBD RID */
# endif
  }
  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUp(Dcm_OpStatusType opStatus
                                                                   ,uint16 rid
                                                                   ,Dcm_CfgRidMgrInfoHandlePtrType pRidInfoIdx)
{
  Std_ReturnType lStdReturn;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdReturn = DCM_E_OK;

# if (DCM_RIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
  if(opStatus == DCM_INITIAL)
# endif
  {
    sint16_least lResult;

    lResult = Dcm_UtiLookUpUint16(Dcm_CfgRidMgrRidLookUpTable, rid);                                                                                 /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    if(lResult >= 0)
    {
      *pRidInfoIdx = (Dcm_CfgRidMgrInfoHandleOptType)lResult;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      lStdReturn = DCM_E_NOT_OK;
    }
  }

# if (DCM_RIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
  if(lStdReturn == DCM_E_OK)
  {
    /* If RID is suppressed by application filter: */
    lStdReturn = Dcm_FilterRidLookUpResult(opStatus, rid);

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    /* If that was last call (DCM_CANCEL), skip any further processing and return any valid value */
    if(opStatus == DCM_CANCEL)
    {
      /* Skip any further processing */
      lStdReturn = DCM_E_NOT_OK;
    }
#  endif

#  if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    /* Catch any unexpected errors in order to return a valid value to the core */
    if( (lStdReturn != DCM_E_OK)
      &&(lStdReturn != DCM_E_PENDING)
      &&(lStdReturn != DCM_E_NOT_OK) )
    {
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      lStdReturn = DCM_E_NOT_OK;
    }
#  endif
  }/* else - DCM_E_NOT_OK */
# endif

  if(lStdReturn == DCM_E_OK)
  {
    lStdReturn = Dcm_RidMgrRidLookUpFilter(rid, *pRidInfoIdx);
  }/* else - DCM_E_NOT_OK, DCM_E_PENDING */
  return lStdReturn;
}
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrSetNextStep()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ObdDtcMgrSetNextStep(Dcm_RepeaterProgressType NextStep
                                                              ,Dcm_ObdDtcManagerContextPtrType pRepContext)
{
  pRepContext->DcmObdDtcManagerProgress = NextStep;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
}

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrGetNextStep()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RepeaterProgressType, DCM_CODE) Dcm_ObdDtcMgrGetNextStep(
                                                                          Dcm_ObdDtcManagerContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  return pRepContext->DcmObdDtcManagerProgress;
}

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemGetNumFltrdDtc(Dcm_OpStatusType opStatus
                                                                          ,Dcm_MsgContextPtrType pMsgContext                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                          ,Dcm_ObdDtcManagerContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetNumberOfFilteredDTCType demResult;
  uint16 lNumDtc;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(pRepContext->DemClientId
                                                ,&lNumDtc);                                                                                          /* SBSW_DCM_POINTER_FORWARD_STACK */
# else
  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(&lNumDtc);                                                                                          /* SBSW_DCM_POINTER_FORWARD_STACK */
# endif

  switch(demResult)
  {
  case DCM_DEM_RET_NUMBER_OK:
    if(lNumDtc <= 0xFFu)
    {
      Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_UtiGetLoByte(lNumDtc));                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
      Dcm_PagedBufferStart((Dcm_MsgLenType)(lNumDtc * 2));
      lStdResult = DCM_E_STOP_REPEATER;
# else
      Dcm_ObdDtcMgrSetNextStep(DCM_OBDDTCMGR_PROGRESS_COPYLINEARDATA, pRepContext);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP;
# endif
    }
    else
    {
      /* else - NRC 0x22 */
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    break;
  case DCM_DEM_RET_NUMBER_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:/* DEM_NUMBER_FAILED or unknown */
    *ErrorCode  = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_DemApiNrcMapGetNumberOfFilteredDTC);                                                 /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCopyLinearData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCopyLinearData(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_ObdDtcManagerContextPtrType pRepContext)
{
  Std_ReturnType           lStdResult;
  Dcm_DiagDataContextType  lDataContext;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagInitDataContext(&lDataContext, Dcm_DiagGetResData(pMsgContext), pMsgContext->resMaxDataLen);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

  lStdResult = Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(&lDataContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Commit copied data */
  Dcm_DiagProvideResData(pMsgContext, lDataContext.Usage);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  switch (lStdResult)
  {
  case DCM_E_BUFFERTOOLOW:
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;/* for OBD send (suppress with) NRC 0x31 since 0x14 (ResponseTooLong is not defined!) */                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  case DCM_E_DATA_READY_PADDING:
    lStdResult = DCM_E_OK;
    break;
  default:
    /* ErrorCode already set */
    break;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_DiagSetNewReqBaseToCurProgress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewReqBaseToCurProgress(Dcm_MsgContextPtrType pMsgContext)
{
#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pMsgContext->reqIndex >= pMsgContext->reqBufSize)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGSETNEWREQBASETOCURPROGRESS);
  }
  else
#endif
  {
    pMsgContext->reqBufSize -= pMsgContext->reqIndex;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_UtiNextItemByPtr(pMsgContext->reqData, pMsgContext->reqIndex);                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->reqIndex = 0;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagSetQueuedTranspObj()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetQueuedTranspObj(Dcm_NetTransportObjectPtrType pTranspObj)                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
#if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.QueuedSet.TObjHdl = pTranspObj->Handle;
# if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
  Dcm_UtiBitOpSet(Dcm_TskTaskEvMemType
                 ,Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects
                 ,Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));                                                                 /* PRQA S 3453, 3458 */ /* MD_MSR_19.7, MD_MSR_19.4 */
# endif
#else
  Dcm_DiagSetTranspObj(pTranspObj);
#endif
}

/**********************************************************************************************************************
 *  Dcm_DiagSetNewResBaseToCurProgress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewResBaseToCurProgress(Dcm_MsgContextPtrType pMsgContext)
{
#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pMsgContext->resIndex >= pMsgContext->resBufSize)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGSETNEWRESBASETOCURPROGRESS);
  }
  else
#endif
  {
    pMsgContext->resBufSize -= pMsgContext->resIndex;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resMaxDataLen = pMsgContext->resBufSize;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resProtHeadLen += pMsgContext->resDataLen;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resDataLen = 0;                                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_UtiNextItemByPtr(pMsgContext->resData, pMsgContext->resIndex);                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resIndex = 0;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessorFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcConfirmationFuncType, DCM_CODE) Dcm_DiagGetPostProcessorFunc(uint8_least index)
{
  Dcm_DiagSvcConfirmationFuncType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_CFGDIAGSVCPOSTPROCESSORS_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGGETPOSTPROCESSORFUNC);
    lResult = Dcm_CfgDiagSvcPostProcessors[0];
  }
  else
#endif
  {
    lResult = Dcm_CfgDiagSvcPostProcessors[index];
  }

  return lResult;
}

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetUpdateFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcUpdateFuncType, DCM_CODE) Dcm_DiagGetUpdateFunc(uint8_least index)
{
  Dcm_DiagSvcUpdateFuncType lResult;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_CFGDIAGSVCUPDATERS_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGGETUPDATEFUNC);
    lResult = Dcm_CfgDiagSvcUpdaters[0];
  }
  else
# endif
  {
    lResult = Dcm_CfgDiagSvcUpdaters[index];
  }

  return lResult;
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetCancelFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcCancelFuncType, DCM_CODE) Dcm_DiagGetCancelFunc(uint8_least index)
{
  Dcm_DiagSvcCancelFuncType lResult;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_CFGDIAGSVCCANCELLERS_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGGETCANCELFUNC);
    lResult = Dcm_CfgDiagSvcCancellers[0];
  }
  else
# endif
  {
    lResult = Dcm_CfgDiagSvcCancellers[index];
  }

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInit(void)
{
  Dcm_InstanceContext.Diag.State           = DCM_DIAG_STATE_IDLE;
#if (DCM_DIAG_PROCESSOR_FLAGS_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.QueuedSet.Flags = DCM_DIAG_QUEUE_FLAG_NONE;
#endif
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects = 0;
#endif

#if (DCM_DIAG_SVC_INITIALIZERS_ENABLED == STD_ON)
  /* Initialize all processors */
  {
    uint8_least lIter;

    for(lIter = 0u; Dcm_CfgDiagSvcInitializers[lIter] != NULL_PTR; ++lIter)
    {
      Dcm_CfgDiagSvcInitializers[lIter]();                                                                                                           /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */
    }
  }
#endif

  Dcm_DiagSetP2Timings(0, 0);

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.RxAllowed = FALSE;
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RECOVERY, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE);
#endif

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  /* Delegate to the first task activation */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_SEND);
#endif
}

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagPutStartUpFblResBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagPutStartUpFblResBuffer(uint8_least index, Dcm_MsgItemType value)
{
# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_DIAG_START_UP_FBL_RES_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGPUTSTARTUPFBLRESBUFFER);
  }
  else
# endif
  {
    Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[index] = value;                                                                                    /* SBSW_DCM_POINTER_WRITE_START_UP_FBL_RES_BUFFER */
  }
}
#endif

#if (DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagExecConfirmationFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagExecConfirmationFunc(Dcm_CfgDiagNotificationInfoPtrType notifList                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_ConfirmationStatusType confStatus)
{
  uint16_least lIter;

  for(lIter = 0u; notifList[lIter].ConfFunc != NULL_PTR; ++lIter)
  {
    (void)notifList[lIter].ConfFunc(Dcm_InstanceContext.Diag.PostProcessorContext.Sid
                                   ,Dcm_InstanceContext.Diag.PostProcessorContext.ReqType
                                   ,Dcm_InstanceContext.Diag.PostProcessorContext.SrcAddr
                                   ,confStatus);                                                                                                     /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_ConfirmationStatusType, DCM_CODE) Dcm_DiagGetPostProcessResult(void)
{
  Dcm_ConfirmationStatusType confStatus  = DCM_DIAG_RES_ANY_OK;

  if(Dcm_InstanceContext.Diag.TxStatus != DCM_E_OK)
  {
    /* Set Tx error flag */
    confStatus |= DCM_DIAG_RES_ANY_NOT_OK;
  }

  if(Dcm_InstanceContext.Diag.ErrorRegister != DCM_E_POSITIVERESPONSE)
  {
    /* Set neg response flag */
    confStatus |= DCM_DIAG_RES_NEG_ANY;
  }
  return confStatus;
}

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoverySignature()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_DiagGetRecoverySignature(void)
{
  uint32 lResult;

  lResult = Dcm_PbCfgNetNumComMChannels;

# if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
  lResult |= Dcm_UtiMake32Bit(0u, 0u, Dcm_PbCfgNetNumAllComMChannels, 0u);
# endif

# if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
  lResult |= Dcm_UtiMake32Bit(Dcm_UtiGetHiNibble(Dcm_PbCfgNetNumProtocols) /* Since at most 32 protocols are allowed the high nibble never exceeds 1 bit */
                             ,Dcm_UtiGetLoNibble(Dcm_PbCfgNetNumProtocols)
                             ,0u
                             ,0u);                                                                                                                   /*lint !e572 if a constant fits into uint8, then lint threats it as such and ignores any casts */
# endif

  lResult |= Dcm_UtiGetBitFromIndex(uint32, 21u);

# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 22u);
# endif

# if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 23u);
# endif

# if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 24u);
# endif

# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 25u);
# endif

  lResult |= Dcm_UtiMake32Bit(0x08, 0x00, 0u, 0u);

  lResult |= Dcm_UtiMake32Bit(0xA0, 0u, 0u, 0u);

  return lResult;
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagProvideRecoveryStates()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagProvideRecoveryStates(
                                                    P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo)
{
  /* Retrieve ComM channel states */
  Dcm_CfgNetNetIdRefOptType lNetHandleIter;
  Dcm_RecoveryInfoComMChannelStatePtrType pChannelState;
  for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
  {
    pChannelState = Dcm_DiagGetRecoveryInfoComMChannelState(RecoveryInfo, lNetHandleIter);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    *pChannelState = (boolean)(Dcm_PbRamNetComMContext[lNetHandleIter].RegisteredNetworks != 0u);                                                    /* SBSW_DCM_POINTER_WRITE_RECOVERYINFOCOMMCHANNELSTATE */
  }

  /* Retrieve session state */
  RecoveryInfo->SessionLevel = Dcm_UtiGetBitPosition(Dcm_StateGetSession());                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Retrieve session connection */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  RecoveryInfo->SessionConnection = Dcm_NetGetSessionConnection();                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
# endif

  /* Retrieve active protocol */
# if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
  RecoveryInfo->ActiveProtocol = Dcm_NetGetProtIdOfActiveProtocol();                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
# endif

  /* Retrieve security state */
# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  RecoveryInfo->SecurityLevel = Dcm_UtiGetBitPosition(Dcm_StateGetSecurity());                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
# endif

  /* Retrieve DTC settings state */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
  RecoveryInfo->ControlDTCSettingDTCGroup = Dcm_ModeGetControlDtcSettingGroup();                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
#  endif
  RecoveryInfo->ControlDTCSettingDisabled = (boolean)(Dcm_ModeGetControlDtcSettingMode() == RTE_MODE_DcmControlDtcSetting_DISABLEDTCSETTING);        /* SBSW_DCM_PARAM_PTR_WRITE */
# endif

  /* Retrieve communication control state */
# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  {
    uint8_least lChannelIter;
    Dcm_RecoveryInfoCommControlStatePtrType pControlState;
    for(lChannelIter = 0; lChannelIter < Dcm_PbCfgNetNumAllComMChannels; ++lChannelIter)
    {
      pControlState = Dcm_DiagGetRecoveryInfoCommControlState(RecoveryInfo, lChannelIter);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      *pControlState = Dcm_ModeGetCommControlState(lChannelIter);                                                                                    /* SBSW_DCM_POINTER_WRITE_RECOVERYINFOCOMMCONTROLSTATE */
    }
  }
# endif

  RecoveryInfo->Signature = Dcm_DiagGetRecoverySignature();                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagProcessRecoveryInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagProcessRecoveryInfo(
                                                P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo
                                               ,Dcm_OpStatusType opStatus)
{
  Std_ReturnType lStdResult = DCM_E_OK;

  if (opStatus == DCM_INITIAL)
  {
    /* If a non-default session was active: */
    if(RecoveryInfo->SessionLevel != 0)
    {
      /* Activate ComM channels */
      Dcm_CfgNetNetIdRefOptType lNetHandleIter;
      for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
      {
        if(RecoveryInfo->ComMChannelState[lNetHandleIter] == TRUE)
        {
          Dcm_NetArEnvComMActiveDiag(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandleIter]]);
        }
      }

      /* Recover session state */
      Dcm_StateSetSession(RecoveryInfo->SessionLevel);

      /* Recover active protocol */
# if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
      Dcm_SingletonContext.Network.ActiveProtocol = RecoveryInfo->ActiveProtocol;
# endif

      /* Update P2 timings at once */
      Dcm_DiagSetP2Timings(RecoveryInfo->SessionLevel, Dcm_NetGetProtIdOfActiveProtocol());

      /* Recover session connection */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
      Dcm_NetSetSessionConnection(RecoveryInfo->SessionConnection);
# endif

      Dcm_TmrStartTimer(DCM_TMR_ID_S3, DCM_DIAG_TIME_S3);
    }

# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
    /* If any security level was unlocked: */
    if(RecoveryInfo->SecurityLevel != 0)
    {
      /* Recover security state */
      Dcm_StateSetSecurity(RecoveryInfo->SecurityLevel);
    }
# endif
  }

# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  /* If DTC settings were disabled: */
  if(RecoveryInfo->ControlDTCSettingDisabled == TRUE)
  {
    /* Recover DTC updating state */
    lStdResult = Dcm_Svc85DisableDtcSetting(
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
                                            RecoveryInfo->ControlDTCSettingDTCGroup
#  else
                                            DEM_DTC_GROUP_ALL_DTCS
#  endif
                                           ,Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol())
                                           );

  }
# endif

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
#  if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  /* If no DTC settings update was necessary or it succeeded */
  if (lStdResult == DCM_E_OK)
#  endif
  /* Recover communication control states */
  {
    uint8_least lChannelIter;
    for(lChannelIter = 0; lChannelIter < Dcm_PbCfgNetNumAllComMChannels; ++lChannelIter)
    {
      if(RecoveryInfo->CommControlState[lChannelIter] != DCM_ENABLE_RX_TX_NORM_NM)
      {
        Dcm_ModeSwitchCommControl(lChannelIter, RecoveryInfo->CommControlState[lChannelIter]);
      }
    }
  }
# endif
  return lStdResult;
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagSafeProcessRecoveryInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSafeProcessRecoveryInfo(
                                                 P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo
                                                ,Dcm_OpStatusType opStatus)
{
  uint8  lErrorId = DCM_E_NO_ERROR;
  Std_ReturnType lStdResult = DCM_E_OK;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(RecoveryInfo->Signature != Dcm_DiagGetRecoverySignature())
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(RecoveryInfo->SessionLevel >= DCM_STATE_NUM_SESSION)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
  if( (RecoveryInfo->SessionLevel != 0u) /* non-default session */
    &&(RecoveryInfo->ActiveProtocol >= DCM_NET_INVALID_PROTID) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
#  if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  if( (RecoveryInfo->SessionLevel != 0u) /* non-default session */
    &&(RecoveryInfo->SessionConnection >= DCM_NET_INVALID_CONNID) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
#  if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON) && \
      (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  if( (RecoveryInfo->SessionLevel != 0u) /* non-default session */
    &&(Dcm_NetGetProtIdOfConnection(RecoveryInfo->SessionConnection) != RecoveryInfo->ActiveProtocol) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
#  if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(RecoveryInfo->SecurityLevel >= DCM_STATE_NUM_SECURITY)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
# endif
  {
    lStdResult = Dcm_DiagProcessRecoveryInfo(RecoveryInfo, opStatus);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_GETRECOVERYSTATES, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcCancelOpenJobs()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcCancelOpenJobs(void)
{
  /* #10 If any diagnostic job still open (PagedBuffer transfers are not part of them), call the job handle one last time with DCM_CANCEL signal */
  if(Dcm_InstanceContext.Diag.State == DCM_DIAG_STATE_PROCESS)
  {
    Dcm_NegativeResponseCodeType lNrc;
    Dcm_InstanceContext.Repeater.Contexts.OpStatus = DCM_CANCEL;/* Override any other opStatus values up to now */
    (void)Dcm_RepeaterExecute(&lNrc);/* signal cancellation */                                                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
    Dcm_SetNegResponse(lNrc); /* register negative result */
  }

  /* #20 If any diagnostic job still open (including PagedBuffer transfers) or already on transmission: */
  if(((DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX) & Dcm_InstanceContext.Diag.State) != 0) /* any open diagnostic job? (optimize interrupt lock times) */
  {
    /* Immediately cancel any ongoing transmission (RCR-RP, final response (RoE or external)) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    if(((DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX) & Dcm_InstanceContext.Diag.State) != 0) /* STILL any open diagnostic job -> diagnostic transport object is still in use -> try cancel it */ /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
    {
      Dcm_NetTransportObjectPtrType pTranspObj;

      pTranspObj = Dcm_DiagGetTranspObj();

      /* #30 If any USDT response transmission is still ongoing (incl. RCR-RPs): */
      if(pTranspObj->State == DCM_NET_TOBJ_STATE_ONTX)
      {
        pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED;/* isolate this connection */                                                                /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        /* Short cut to speed up the service processing finalization - RCR-RP responses will just end with the cancellation below */
        Dcm_DiagTxFinalization(pTranspObj, DCM_E_NOT_OK);                                                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

        /* Try cancel any ongoing response. The return value does not matter:
          * OK -> there will be a confirmation for this cancellation
          * N_OK -> request rejected, but there will be a confirmation due to the ongoing transmission */
        (void)Dcm_NetArEnvPduRCancelTransmit(Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnId].TxPduIdMain);
        /* Any response (final, RCR-RP, etc) will just end with releasing the connection assigned to the tObject! No confirmation post-processing will be performed! */
      }
      /* #40 Otherwise, if there is no USDT response initiated yet, just notify the diagnostic kernel for the transmission finalization to accomplish the diagnostic job cycle */
      else if (pTranspObj->State == DCM_NET_TOBJ_STATE_READY)                                                                                        /* COV_DCM_RTM_UNREACHABLE TX */
      {
        /* no transmission yet started -> just loop back the diagnostic confirmation immediately. Note: no other Tx-confirmation type is expected here */
        Dcm_DiagTxFinalization(pTranspObj, DCM_E_NOT_OK);                                                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }
      else
      {
        /* #50 Otherwise, unexpected transport object state reached (inconsistent in the context of diagnostic kernel state, showing a job is still in progress) */
        Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                 /* COV_DCM_RTM_DEV_DEBUG XF */
      }
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
  /* #55 Otherwise, diagnostic kernel is in "post processing" or "idle" state and they are to be handled in a normal way
         Note: This case can be reached since the prioritization just fires a cancellation event, disregarding any internal states of the diagnostic kernel */
}                                                                                                                                                    /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcReviveKilledTasks()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcReviveKilledTasks(void)
{
  /* All cancellation activities are done now - revive all killed tasks to allow normal processing of the newly received diagnostic job (the one caused the interruption) */
  if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEvent(DCM_TSK_ID_DIAG_WORK)) == 0)/* Look ahead: Any nested kill job received? If so, no task revival! */ /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
  {
# if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
    Dcm_TskTaskEvOptType queuedTObjBitSet = 0; /* nothing to clean (for now) */
# endif
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEvent(DCM_TSK_ID_DIAG_WORK)) == 0)/* STILL no nested kill job received? */                        /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
    {
      Dcm_TskReviveAllTasks();/* from now on enable tasks for working */
# if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
      queuedTObjBitSet = Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects;
      /* Clear all except the last queued one  */
      Dcm_UtiBitOpClr(Dcm_TskTaskEvOptType, queuedTObjBitSet, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, Dcm_DiagGetQueuedTranspObj()->Handle));   /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
      /* Remove all processed transport objects from the queue (the last queued one will be removed from the queue once transfered to the active tObject or canceled by higher prio request here again) */
      Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects, queuedTObjBitSet);                                    /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
# endif
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
# if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
    if(queuedTObjBitSet > 0)
    {
      /* Some connections to clean up (in background)? */
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_GARB_COL, (Dcm_TskTaskEvMemType)queuedTObjBitSet);
    }
# endif                                                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerDoCancelProcessing(Dcm_TskTaskEvOptType ev
                                                                                      ,Dcm_TskTaskEvPtrType pPostEv)                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagWorkerDoCancelProcCancelOpenJobs(); /* Cancel open diagnostic jobs */

  /* Sync with TxEnd events set above OR Tx confirmation. No ISR lock since:
   * - No Tx confirmation can occur from now on
   * - If above Tx confirmation executed -> no other changes of the state are possible!
   * - If there was already a Tx Confirmation (above code not executed) -> the task will just be re-triggered
   */
  /* If the Dcm_DiagTaskWorker() has (by finished transmission or through the above cancellation activity) already received a post-processing event: */
  if((DCM_TSK_EV_DIAG_WORK_TX_END_FINAL & Dcm_TskGetEvent(DCM_TSK_ID_DIAG_WORK)) != 0)
  {
    Dcm_TskClrEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL);/* clear any potentially globally set Tx-end-response (from the above Tx cancellation code) */
    Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL);/* set/transfer the Tx end event */
  }
  /* Otherwise, either no Tx-end event OR nothing to do OR it is already set in the local "ev" -> will be post-processed in next task stages */

  Dcm_DiagWorkerDoCancelProcReviveKilledTasks(); /* Revive killed tasks */

  return lResultEv;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoPostProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoPostProcessing(void)
{
  Dcm_ConfirmationStatusType   confStatus;
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_NegativeResponseCodeType lNrc;
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  /* Reset any pending PB processing */
  if(Dcm_PagedBufferCancel(&lNrc) == DCM_E_NOT_OK)                                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    Dcm_SetNegResponse(lNrc);/* Set NRC now to affect the post-processor confirmation status */
  }
#endif

  confStatus = Dcm_DiagGetPostProcessResult();
  /* First process any diagnostic service post-handler (e.g. to perform any state transitions at this stage): */
  if((DCM_DIAG_APPL_NOTIFICATION_POSTPROCESSOR & Dcm_InstanceContext.Diag.ApplNotification) != 0)
  {
    Dcm_DiagSvcConfirmationFuncType lPostProcessorFunc;
    lPostProcessorFunc = Dcm_DiagGetPostProcessorFunc(Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].ConfFuncRef);

    lPostProcessorFunc(confStatus);/* execute any internal service processor post-handlers */                                                        /* SBSW_DCM_CALL_FUNCPTR_SVCPOSTPROCESSORS */
  }

  /* Process the application notification confirmation */
  if((DCM_DIAG_APPL_NOTIFICATION_CONFIRMATION & Dcm_InstanceContext.Diag.ApplNotification) != 0)
  {
    Dcm_Confirmation(0, Dcm_InstanceContext.Diag.MsgContext.rxPduId, confStatus);/* notify the application about transmission end (of any service) */
  }

  /* At next process any system supplier and OEM notification (e.g. to perform any additional state transitions at this stage): */
#if(DCM_DIAG_SYS_NOTIFICATION_ENABLED == STD_ON)
  if((DCM_DIAG_APPL_NOTIFICATION_SYS & Dcm_InstanceContext.Diag.ApplNotification) != 0)
  {
    Dcm_DiagExecConfirmationFunc(Dcm_CfgDiagSysNotificationInfo, confStatus);                                                                        /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
#endif
#if(DCM_DIAG_OEM_NOTIFICATION_ENABLED == STD_ON)
  if((DCM_DIAG_APPL_NOTIFICATION_OEM & Dcm_InstanceContext.Diag.ApplNotification) != 0)
  {
    Dcm_DiagExecConfirmationFunc(Dcm_CfgDiagOemNotificationInfo, confStatus);                                                                        /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
#endif
  /* At next process any internal service processors background task notifications: */
#if(DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.IsInternRequest == TRUE)/* manage ComM states only on processed requests from external clients */
  {
# if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
    Dcm_ExtSvc86TxEnd(confStatus);
# endif
  }
  else
#endif
  {
    Dcm_NetUnRegisterComMActivity(Dcm_NetGetConnIdOfRxPduId(Dcm_InstanceContext.Diag.MsgContext.rxPduId));/* process here to take a potentially new session change into account */
  }
  Dcm_InstanceContext.Diag.State = DCM_DIAG_STATE_IDLE;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetDefSessionExtern()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerSetDefSessionExtern(Dcm_TskTaskEvOptType ev
                                                                                       ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  /* If diagnostic kernel is still busy with a diagnostic job, retry next task activation if there is no other such request yet */
  if(Dcm_InstanceContext.Diag.State != DCM_DIAG_STATE_IDLE)
  {
    if(!Dcm_TskIsLocalEventSet(lResultEv, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF))                                                                         /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY XX */
    {
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF); /* retry later again */                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else
  {
    /* Redirect the external request for resetting the session to the internal request handler (same activity) */
    Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);

    /* If non-default session is active the current protocol id is unequal to DCM_NET_INVALID_PROTID */
    if(!Dcm_StateIsDefaultSessionActive())
    {
      Dcm_DiagSetP2Timings(0, Dcm_NetGetProtIdOfActiveProtocol());
    }/* else - P2 timings of default session already set */

#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
    Dcm_SingletonContext.Network.RxAllowed = TRUE;
#endif
  }

  return lResultEv;
}

/**********************************************************************************************************************
 *  Dcm_DiagSwitchProcessingContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSwitchProcessingContext(void)
{
  Std_ReturnType lStdResult = DCM_E_OK;

#if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON) || \
    (DCM_DIAG_GARB_COL_ENABLED == STD_ON) || \
    (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)
  Dcm_SplitTaskEnterCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
# if (DCM_DIAG_GARB_COL_ENABLED == STD_ON) && \
     (DCM_SPLIT_TASKS_ENABLED == STD_ON)
  if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEvent(DCM_TSK_ID_DIAG_WORK)) != 0)/* STILL no (nested) kill job received? */
  {
    lStdResult = DCM_E_NOT_OK; /* skip any further processing in this Dcm_DiagTaskWorker() activation (i.e. return immediately) */
  }
  else
# endif
  {
# if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON) || \
     (DCM_DIAG_GARB_COL_ENABLED ==STD_ON)
    Dcm_NetTransportObjectPtrType pQueuedTObj;
    pQueuedTObj = Dcm_DiagGetQueuedTranspObj();
# endif

# if (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)                                                                                                        /* COV_DCM_SUPPORT_ALWAYS TX */
    Dcm_UtiBitOpClr(Dcm_DiagProcessorFlagType, Dcm_InstanceContext.Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_WAITING);                            /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    Dcm_UtiBitOpSet(Dcm_DiagProcessorFlagType, Dcm_InstanceContext.Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_ACTIVE);
# endif

# if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON)
    Dcm_DiagSetTranspObj(pQueuedTObj); /* switch work contexts! RCR-RP will be sent also from this one (QueuedCtxt) */
# endif
# if (DCM_DIAG_GARB_COL_ENABLED ==STD_ON)
    Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects, (Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pQueuedTObj->Handle)));
# endif
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
#endif

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_DiagInitiateServiceProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInitiateServiceProcessing(Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_NetTransportObjectPtrType pTranspObj;
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

  /* Now take the active transport object */
  pTranspObj = Dcm_DiagGetTranspObj();

#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.IsInternRequest = (boolean)((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0);
#endif

  lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

  /* Compose message context (skip SID byte) */
  pMsgContext->reqData = &(lBufferInfo->BufferPtr[0]);                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resData = &(lBufferInfo->BufferPtr[0]);                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->reqDataLen = pTranspObj->RxLength;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resDataLen = 0u;                                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->reqBufSize = lBufferInfo->Size;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resBufSize = lBufferInfo->Size;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resMaxDataLen = lBufferInfo->Size;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resProtHeadLen = 0;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->reqIndex = 0u;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resIndex = 0u;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->rxPduId = pTranspObj->RxPduId;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->msgAddInfo.reqType  = (uint8)((Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE)?1u:0u);                                  /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->msgAddInfo.suppressPosResponse = 0;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Update diagnostic kernel context */
  Dcm_InstanceContext.Diag.ErrorRegister        = DCM_E_POSITIVERESPONSE;
  Dcm_InstanceContext.Diag.ApplNotification     = DCM_DIAG_APPL_NOTIFICATION_NONE;
  Dcm_InstanceContext.Diag.DoSuppressResponse   = FALSE;
  Dcm_InstanceContext.Diag.State                = DCM_DIAG_STATE_PROCESS;

  Dcm_PagedBufferInit();
}

/**********************************************************************************************************************
 *  Dcm_DiagHandleSuppressBit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleSuppressBit(Dcm_NetTransportObjectPtrType pTranspObj                                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                               ,Dcm_MsgContextPtrType         pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Check if the new service supports sub-function parameter */
  if((Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].Props & DCM_DIAG_SVC_CFG_PROP_HAS_SUBFUNC)  != 0)
  {
    uint8 reqSf = Dcm_DiagGetReqDataAsU8(pMsgContext);
    /* If so, deal with the SPRMIB: extract and store */
    if ((reqSf & 0x80u) != 0)
    {
      Dcm_DiagSetReqDataAsU8(pMsgContext, (uint8)(reqSf & 0x7Fu));/* mask out the SPRMIB */                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_SplitTaskEnterCS();/* protect against hi-priority Dcm_DiagTaskRx/Tx */                                                                     /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
      /* On split task it could happen that RCR-RP is already on transmission */
      if((pTranspObj->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_ON_TX | DCM_NET_TOBJ_FLAG_RCRRP_SENT)) == 0)/* RCR-RP is NOT on transmission or was sent */
#endif
      {
        pMsgContext->msgAddInfo.suppressPosResponse = 1;                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
      Dcm_SplitTaskLeaveCS();                                                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }
    /* copy the sub-function byte once split Rx/Tx buffers are supported.
    pMsgContext->resData[0] = pMsgContext->reqData[0];
    */
  }
}

/**********************************************************************************************************************
*  Dcm_DiagHandleDispatching()
*********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleDispatching(uint8                 sid
                                                               ,Dcm_MsgContextPtrType pMsgContext)                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  boolean lResult = FALSE;
  DCM_IGNORE_UNREF_PARAM(lResult);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(sid);                                                                                                                       /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#if(DCM_DIAG_SERVICE_DISPATCHER_ENABLED == STD_ON)
  /*  Check for necessity of service dispatching (service supports the dispatching parameter) */
  if((Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].Props & DCM_DIAG_SVC_CFG_PROP_CALL_SVC_DISPATCHER) != 0)
  {
    /* Execute the call-out to the application and verify the result */
    lResult = Dcm_HandleServiceExtern(sid
                                     ,pMsgContext->reqData
                                     ,(uint16)pMsgContext->reqDataLen
                                     ,(uint8) pMsgContext->msgAddInfo.reqType
                                     ,Dcm_InstanceContext.Diag.PostProcessorContext.SrcAddr);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */

    switch(lResult)
    {
      case TRUE:
        Dcm_InstanceContext.Diag.ProcessServiceExtern = TRUE;
        break;
      case FALSE:
        Dcm_InstanceContext.Diag.ProcessServiceExtern = FALSE;
        break;
      default:/* Check if the application has returned an unexpected value */                                                                        /* COV_DCM_RTM_UNREACHABLE X */
        Dcm_InstanceContext.Diag.ProcessServiceExtern = FALSE; /* Assure that the internal implementation is used */
        lResult = FALSE;
        Dcm_DebugReportError(DCM_SID_SVC_DISPATCHER, DCM_E_INTERFACE_RETURN_VALUE);
        break;
    }
  }
  else
  {
    Dcm_InstanceContext.Diag.ProcessServiceExtern = FALSE;
  }
  /* Set the flags for post processing on internal service handling */
  if(lResult == FALSE)
#endif
  {
    if(Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].ConfFuncRef != 0)
    {
      Dcm_InstanceContext.Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_POSTPROCESSOR; /* mark application post processor */
    }

    if(Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].FastConfFuncRef != 0)
    {
      Dcm_InstanceContext.Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_FASTPOSTPROCESSOR; /* mark application fast post processor */
    }
  }

  /* From now on, mark application calls for post-processing later */
  Dcm_InstanceContext.Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_CONFIRMATION; /* mark application notification at last here */
}

/**********************************************************************************************************************
 *  Dcm_DiagValidateAndDispatchService()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagValidateAndDispatchService(
                                                                            Dcm_MsgContextPtrType           pMsgContext
                                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  Dcm_MsgItemType lSid;

  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &lSid);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_DiagProvideResDataAsU8(pMsgContext, lSid + 0x40u);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Skip SID data, since already processed */
  Dcm_DiagSetNewReqBaseToCurProgress(pMsgContext);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_DiagSetNewResBaseToCurProgress(pMsgContext);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

#if(DCM_DIAG_OEM_NOTIFICATION_ENABLED == STD_ON)
  /* Execute manufacturer specific environment checks */
  if(Dcm_DiagExecIndicationFunc(lSid, DCM_DIAG_APPL_NOTIFICATION_OEM, Dcm_CfgDiagOemNotificationInfo, ErrorCode) == DCM_E_OK)                        /* SBSW_DCM_COMB_PTR_FORWARD */
#endif
  {
    sint16_least sidIter = Dcm_DiagLookUpFilter(Dcm_UtiLookUpUint8(Dcm_CfgDiagSvcIdLookUpTable, lSid)
                                               ,Dcm_CfgDiagSvcIdExecPrecondTable
                                               ,DCM_DIAG_CHK_LVL_SERVICE_ID
                                               ,ErrorCode);                                                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_COMB_PTR_FORWARD */
    /* Service found? */
    if(sidIter >= 0)
    {
      Dcm_NetTransportObjectPtrType pTranspObj;

      pTranspObj = Dcm_DiagGetTranspObj();
      Dcm_InstanceContext.Diag.SidIndex = (uint8)sidIter;
#if (DCM_DIAG_MULTI_SVC_TABLE_ENABLED == STD_ON)
      /* use protocol of the current working context! Otherwise a hi priority task (NetTaskRx) could interrupt this task and change the protocol! */
      if((Dcm_PbCfgDiagSvcId2ProtMap[Dcm_InstanceContext.Diag.SidIndex] & Dcm_UtiGetBitFromIndex(Dcm_CfgDiagSvc2ProtMapMemType, Dcm_NetGetProtIdOfTranspObj(pTranspObj))) == 0)
      {
        /* Unknown service requested */
        *ErrorCode = DCM_E_SERVICENOTSUPPORTED;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      else
#endif
      {
        if((Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].Props & DCM_DIAG_SVC_CFG_PROP_CALL_POST_HDLR_ALWAYS)  != 0)
        {
          /* mark application notification once the SID is identified! */
          Dcm_InstanceContext.Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_POSTPROCESSOR;
        }

        /* Check SID pre-conditions */
        lStdResult = Dcm_StateCheck(Dcm_CfgDiagSvcIdExecPrecondTable[Dcm_InstanceContext.Diag.SidIndex]
                                   ,DCM_DIAG_CHK_LVL_SERVICE_ID
                                   ,ErrorCode);                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
        if(lStdResult == DCM_E_OK)
        {
#if(DCM_DIAG_SYS_NOTIFICATION_ENABLED == STD_ON)
          /* Execute supplier specific environment checks */
          lStdResult = Dcm_DiagExecIndicationFunc(lSid, DCM_DIAG_APPL_NOTIFICATION_SYS, Dcm_CfgDiagSysNotificationInfo, ErrorCode);                  /* SBSW_DCM_COMB_PTR_FORWARD */
          if(lStdResult == DCM_E_OK)
#endif
          {
            /* Check for available minimum length */
            if(pMsgContext->reqDataLen >= Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].MinLength)
            {
              /* Handle SPRMIB */
              Dcm_DiagHandleSuppressBit(pTranspObj, pMsgContext);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

              /* Handle service dispatching and set the flags for post-processing */
              Dcm_DiagHandleDispatching(lSid, pMsgContext);                                                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
            }
            else
            {
              /* Minimum length is not reached  */
              *ErrorCode = ((lSid < 0x10u) ? DCM_E_REQUESTOUTOFRANGE : DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT );                                /* SBSW_DCM_PARAM_PTR_WRITE */
              lStdResult = DCM_E_NOT_OK;
            }
          } /* else - NRC already set - finalize processing */
        }/* else - NRC already set - finalize processing */
      }
    }/* else - already written "Unsupported service requested" */
  }/* else - NRC already set - finalize processing */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050, 6080 */ /* MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessNewRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerProcessNewRequest(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pPostEv)                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType         lResultEv = ev;
  Std_ReturnType               lStdResult;
  Dcm_NegativeResponseCodeType lNrc;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagSwitchProcessingContext();

  if(lStdResult == DCM_E_OK)
  {
    Dcm_DiagInitiateServiceProcessing(&(Dcm_InstanceContext.Diag.MsgContext));                                                                       /* SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT */

    /* Validate received diagnostic service on SID level */
    lStdResult = Dcm_DiagValidateAndDispatchService(&(Dcm_InstanceContext.Diag.MsgContext)
                                                   ,&lNrc);                                                                                          /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)
    {
      /* Set repeater per default to be no specific service */
      Dcm_RepeaterSetUser(DCM_REPEATER_USER_NONE);
      /* Execute Main-Handler (register it and it will be called immediately) */
      Dcm_RepeaterSetCallee(Dcm_InstanceContext.Diag.SidIndex);
      /* Let the service processor take over immediately */
      Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_WORK_REPEAT);
    }
    else
    {
      /* DCM_E_NOT_OK */
      Dcm_SetNegResponse(lNrc);
      Dcm_ProcessingDone();
    }
  }
  else
  {
    /* DCM_E_NOT_OK */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, (Dcm_TskTaskEvMemType)ev);/* repeat all still unprocessed events at once together with the kill-event in order to get these always synchronized */
    lResultEv = 0; /* skip any further processing in this Dcm_DiagTaskWorker() activation (i.e. return immediately) */
  }
  return lResultEv;
}

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessRcrRpTxEnd()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerProcessRcrRpTxEnd(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pPostEv)                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lResultEv = ev;
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj();

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if((DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL & pTranspObj->Flags) != 0)/* this is a RCR-RP response - check which kind */
  {
    Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL);                                           /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */ /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    Dcm_InstanceContext.Repeater.Contexts.OpStatus = (Dcm_OpStatusType)((Dcm_InstanceContext.Diag.TxStatus != DCM_E_OK)
                                                                        ?DCM_FORCE_RCRRP_NOT_OK
                                                                        :DCM_FORCE_RCRRP_OK);
    Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_WORK_REPEAT); /* notify immediately */
  }

  return lResultEv;
}

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON) && \
    (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerCancelOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerCancelOperation(Dcm_TskTaskEvOptType ev
                                                                                   ,Dcm_TskTaskEvPtrType pPostEv)                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType         lResultEv = ev;
  Dcm_NegativeResponseCodeType lNrc;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_PagedBufferCancel(&lNrc) == DCM_E_NOT_OK)                                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    /* Stop polling and wait for confirmation */
    Dcm_SetNegResponse(lNrc);
    Dcm_ProcessingDone();
  }

  return lResultEv;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoRepeat()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerDoRepeat(Dcm_TskTaskEvOptType ev
                                                                            ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;
  Std_ReturnType lStdResult;
  Dcm_NegativeResponseCodeType lNrc = DCM_E_POSITIVERESPONSE;
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj();

#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(lResultEv, DCM_TSK_EV_DIAG_WORK_CANCEL_OP))
  {
    Dcm_InstanceContext.Repeater.Contexts.OpStatus = DCM_CANCEL; /* override any other opStatus values up to now */
  }
#endif
  lStdResult = Dcm_RepeaterExecute(&lNrc);                                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */

  switch(lStdResult)
  {
  case DCM_E_NOT_OK:
    Dcm_SetNegResponse(lNrc);
    /* fall through */
  case DCM_E_OK:                                                                                                                                     /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
  case DCM_E_PROCESSINGDONE:
    Dcm_ProcessingDone();
    break;
  case DCM_E_PENDING:
    Dcm_InstanceContext.Repeater.Contexts.OpStatus = DCM_PENDING;
#if (DCM_RUNTIME_USAGE_LIMIT_ENABLED == STD_ON)
    /* fall through - keep the last opStatus on "pending" forced by Dcm_RepeaterExecute code */
  case DCM_E_PENDING_LIMITER:                                                                                                                        /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
#endif
    /* Retry next cycle with the same parameter */
    Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_WORK_REPEAT);                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case DCM_E_FORCE_RCRRP:
    Dcm_UtiArEnvEnterCriticalSection();/* protect against Dcm_TpTxConfirmation or hi-priority Dcm_DiagTaskRx */                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL;                                                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    if((pTranspObj->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_ON_TX | DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ))  == 0)/* no RCR-RP already requested for transmission/ongoing? */
    {
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_TMR_P2_TO);/* trigger a RCR-RP event timeout */
    }/* else - just wait for confirmation signal */

    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    break;
  default: /* DCM_E_STOP_REPEATER */
    Dcm_RepeaterSetCallee(DCM_DIAG_SERVICEINFO_REPEATEREND_IDX); /* any other return value leads to a dead end */
    break;
  }

  return lResultEv;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoGetProgCond()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoGetProgCond(Dcm_TskTaskEvOptType ev
                                                                                 ,Dcm_TskTaskEvPtrType pPostEv)                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* #10 Read the programming conditions of the pre-boot cycle */
  /* #20 If the ECU boot type is marked as a transition from the bootloader: */
  if(Dcm_GetProgConditions(&Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions) == DCM_WARM_START)                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  {
    sint16_least sesSfIter = -1;
# if (DCM_DIAG_NOTIF_BSWM_APPL_UPDATED_ENABLED == STD_ON)
    /* #30 If the application has been updated, notify the BswM (if enabled BswM notification) */
    if(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ApplUpdated == TRUE)
    {
      BswM_Dcm_ApplicationUpdated();
    }
# endif

    /* #40 Check the diagnostic service identifier to be processed here: */

    /* #41 If the SID is for "DiagnosticSessionControl": */
    if(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.Sid == 0x10u)
    {
      sesSfIter = Dcm_VarMgrLookUpFilter(Dcm_UtiLookUpUint8(Dcm_CfgSvc10SubFuncLookUpTable, Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.SubFuncId) /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
                                        ,Dcm_CfgSvc10SubFuncExecPrecondTable);                                                                       /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    }
    /* #50 Otherwise, send a response with any other SID and sub-function directly */

    if( (Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ResponseRequired == TRUE) /* a response is to be sent */
      ||(sesSfIter > 0) ) /* OR a non-default session is to be activated (need ComM active) */
    {
      Dcm_NetConnRefMemType connId;

      connId = Dcm_NetGetConnIdByTesterAddress(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.TesterSourceAddr);

      if(connId < DCM_NET_INVALID_CONNID)
      {
        Dcm_NetTransportObjectPtrType pTranspObj; /* use a local copy to avoid collision with a RxIndication! */

        pTranspObj = Dcm_NetLockConnectionOrNull(connId);

        if(pTranspObj != NULL_PTR) /* try to lock the connection to this tester */
        {
          Dcm_InstanceContext.Diag.StartUpFbl.ConnId = pTranspObj->ConnId;
          Dcm_DiagSetTranspObj(pTranspObj);/* store working context */
          Dcm_TmrStartTimer(DCM_TMR_ID_FBLRES, Dcm_InstanceContext.Diag.P2Timings.P2Star); /* wait at most P2 star to finalize the FBL positive response */
          /* Start communication */
          Dcm_NetRegisterActiveConnection(pTranspObj);                                                                                               /* SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ */
          Dcm_NetRegisterComMActivity(pTranspObj);                                                                                                   /* SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ */
          Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM);/* Try immediately */
        }
        /* else - there is a problem locking the channel (there is already a tester request) */
      }
      else
      {
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_PARAM);
      }
    }
    /* #60 In any case store any analysis results for later use (i.e. during the clear response required flag) */
    Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef = (sint8)sesSfIter;
    Dcm_InstanceContext.Diag.StartUpFbl.IsResponseRequired = Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ResponseRequired;
    /* #70 Signal the current task to start immediately the parallel job for clearing the response required flag, to avoid re-triggering of this sequence at next power on cycle */
    Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS);
  }

  return lResultEv;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoWaitTxComm()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoWaitTxComm(Dcm_TskTaskEvOptType ev
                                                                                ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj();

  /* If the corresponding ComM channel state is in "FullComMode": */
  if((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByTranspObject(pTranspObj)) != 0)
  {
    Dcm_TmrStopTimer(DCM_TMR_ID_FBLRES);

    if(Dcm_InstanceContext.Diag.StartUpFbl.IsResponseRequired == FALSE) /* is final response required ? */
    {
      Dcm_DiagOnFblResTxFinished(pTranspObj, DCM_E_OK);/* Loop-back to the confirmation (successful "virtual" transmission) to clean up transportObject and ComM */ /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    }
    else
    {
      pTranspObj->State   = DCM_NET_TOBJ_STATE_PREPTX;                                                                                               /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_UNSOLICITED;                                                                                        /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->BuffInfo.SduDataPtr = &Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[0];                                                           /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->BuffInfo.SduLength  = 2u; /* only service and a sub-function to be sent */                                                         /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      /* Prepare final response to be sent */
      Dcm_DiagPutStartUpFblResBuffer(0, (uint8)(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.Sid + 0x40u));
      Dcm_DiagPutStartUpFblResBuffer(1, Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.SubFuncId);

      if(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.Sid == 0x10u)
      {
        if(Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef >= 0)
        {
          Dcm_DiagPutStartUpFblResBuffer(2, Dcm_UtiGetHiByte(Dcm_CfgSvc10SubFuncInfo[Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2));
          Dcm_DiagPutStartUpFblResBuffer(3, Dcm_UtiGetLoByte(Dcm_CfgSvc10SubFuncInfo[Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2));
          Dcm_DiagPutStartUpFblResBuffer(4, Dcm_UtiGetHiByte(Dcm_CfgSvc10SubFuncInfo[Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2Star));
          Dcm_DiagPutStartUpFblResBuffer(5, Dcm_UtiGetLoByte(Dcm_CfgSvc10SubFuncInfo[Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2Star));
          pTranspObj->BuffInfo.SduLength = 6u;                                                                                                       /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
        else
        {
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_PARAM);
        }
      }/* else - for SID 0x11 or other it is not critical to send any response - it will be up to the application to use the API! */

      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
    }
  }
  else
  { /* Otherwise, check if still shall wait for ComM (deadline not yet expired): */
    if(Dcm_TskIsLocalEventSet(lResultEv, DCM_TSK_EV_DIAG_FBLRES_CANCEL))/* stop polling since time is up */
    {
      /* Loop-back to the confirmation (failed transmission) to clean up transportObject and ComM */
      Dcm_DiagOnFblResTxFinished(pTranspObj, DCM_E_NOT_OK);                                                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    }
    else
    {
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM);/* Retry next time */                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  return lResultEv;
}
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoResetFlags()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoResetFlags(Dcm_TskTaskEvOptType ev
                                                                                ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;
  Std_ReturnType lStdResult;

  /* Reset all programming condition fields to their inactive states */
  Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ReprogrammingRequest = FALSE;
  Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ApplUpdated      = FALSE;
  Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ResponseRequired = FALSE;

  /* Write the updated pre-conditions */
  lStdResult = Dcm_SetProgConditions(&Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  switch(lStdResult)
  {
  case DCM_E_OK:
    break;
  case DCM_E_PENDING:
    Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS);/* Retry next time */                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lResultEv;
}
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoProcessTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoProcessTxConfirmation(Dcm_TskTaskEvOptType ev
                                                                                           ,Dcm_TskTaskEvPtrType pPostEv)                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* #10 If the final response was for a non-default session and was successfully sent: */
  if( (Dcm_InstanceContext.Diag.StartUpFbl.TxStatus == DCM_E_OK) /* only if successfully sent response ... */
    &&(Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef > 0) )/* ... of diagnostic session control for a non-default session ... */
  {
    /* #20 Enter critical section (Reason: Protect against Dcm_StartOfReception) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* #30 Register the diagnostic client for this session */
    Dcm_NetSetSessionConnection(Dcm_InstanceContext.Diag.StartUpFbl.ConnId);/* set tester for the session */
# if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
    /* #40 Register new active protocol */
    Dcm_SingletonContext.Network.ActiveProtocol = Dcm_NetGetProtIdOfConnection(Dcm_InstanceContext.Diag.StartUpFbl.ConnId);
# endif
    /* #50 Leave critical section */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* #60 Perform the corresponding session transition */
    Dcm_StateSetSession((Dcm_StateIndexMemType)Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef);

    /* #70 Update P2 timings at once */
    Dcm_DiagSetP2Timings((Dcm_StateIndexMemType)Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef
                        ,Dcm_NetGetProtIdOfActiveProtocol());
  }
  /* #80 Unregister diagnostic client in order to consider any non-default session activated above */
  Dcm_NetUnRegisterComMActivity(Dcm_InstanceContext.Diag.StartUpFbl.ConnId);

  return lResultEv;
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagTxPostponeFinalPagedResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagTxPostponeFinalPagedResponse(
                                                                                          Dcm_TskTaskEvOptType ev
                                                                                         ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  /* Wait for RCR-RP if SPRMIB was set */
  if (Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.suppressPosResponse != 0)
  {
    /* wait for P2 timeout and RCR-RP response transmission */
    Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_TX_SEND_PAGED); /* retry later */                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_TskClrLocalEvent(lResultEv, DCM_TSK_EV_DIAG_TX_SEND_PAGED); /* avoid transmit attempt now */                                                 /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
  }

  return lResultEv;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTxStartFinalResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagTxStartFinalResponse(Dcm_TskTaskEvOptType ev
                                                                                  ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj();

  /* kill any pending RCR-RP orders */
  Dcm_TskClrLocalEvent(lResultEv, DCM_TSK_EV_DIAG_TX_SEND_RCRRP);                                                                                    /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
  Dcm_TmrStopTimer(DCM_TMR_ID_P2);/* stop in any case since from now on only the service will be finalized (either with or without response) */

  if ( (Dcm_InstanceContext.Diag.DoSuppressResponse == TRUE)                 /* No response to send */
      &&(0 == (pTranspObj->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_SENT | DCM_NET_TOBJ_FLAG_RCRRP_ON_TX /* Suppress only if RcrRp was not sent or not waiting for RCR-RP confirmation. If just attempted -> skip RCR-RP transmission */
                              /* | DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ - since DCM_TSK_EV_DIAG_TX_SEND_RCRRP cleared -> RCR-RP will not be sent. Instead finish the service processing at P2 time */))) )
  {
    Dcm_DiagTxFinalization(pTranspObj, DCM_E_OK);/* always OK */                                                                                     /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
  else
  {
    /* prepare final response transmission */
    if(pTranspObj->State == DCM_NET_TOBJ_STATE_READY)
    {
      Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

      lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

      /* clear flag */
      Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, (DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ | DCM_NET_TOBJ_FLAG_RCRRP_ON_TX));          /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */ /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->State = DCM_NET_TOBJ_STATE_PREPTX;                                                                                                 /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->BuffInfo.SduDataPtr = lBufferInfo->BufferPtr;/* reassign the worker buffer */                                                      /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

      if(Dcm_InstanceContext.Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
      {
        /* Positive response */
        pTranspObj->BuffInfo.SduLength = (PduLengthType)(Dcm_InstanceContext.Diag.MsgContext.resDataLen
                                                       + Dcm_InstanceContext.Diag.MsgContext.resProtHeadLen); /* don't forget the SID or/and SF bytes */ /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
        if(Dcm_TskIsLocalEventSet(lResultEv, DCM_TSK_EV_DIAG_TX_SEND_PAGED))
        {
          pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_PAGED;                                                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
        else
#endif
        {
          pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_LINEAR;                                                                                         /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
      }
      else
      {
        /* Neg response */
        Dcm_NetComposeAddNegResponse(pTranspObj
                                    ,DCM_NET_TOBJ_RESTYPE_LINEAR
                                    ,Dcm_InstanceContext.Diag.ErrorRegister);                                                                        /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }

      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
    }
    else
    {
      /* retry later */
      Dcm_TskSetLocalEvent(*pPostEv, (lResultEv & (Dcm_TskTaskEvOptType)(DCM_TSK_EV_DIAG_TX_SEND_PAGED | DCM_TSK_EV_DIAG_TX_SEND_LINEAR)));          /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  return lResultEv;
}

/**********************************************************************************************************************
 *  Dcm_DiagTxStartRcrRpResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxStartRcrRpResponse(void)
{
  Dcm_NetTransportObjectPtrType pQueuedTObj;

  pQueuedTObj = Dcm_DiagGetQueuedTranspObj();

  /* don't start the P2* timer within the RCR-RP confirmation but here because of prioritization and synchronization issues which could occur otherwise */
  Dcm_TmrStartTimer(DCM_TMR_ID_P2, Dcm_InstanceContext.Diag.P2Timings.P2Star);/* start now to cover also the application triggered RCR-RPs */

  Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.suppressPosResponse = 0; /* reset the suppress bit and send final response */

  Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pQueuedTObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ);                                               /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */ /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
  Dcm_UtiBitOpSet(Dcm_NetTransportObjectFlagType, pQueuedTObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_ON_TX); /* mark transmission flag */                   /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */

#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pQueuedTObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0)
  {
    /* suppress any RCR-RP responses on RoE - just do loop back ! */
    Dcm_DiagRcrRpTxFinished(pQueuedTObj, DCM_E_OK); /* always OK */                                                                                  /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
  }
  else
#endif
  {
    Dcm_NetComposeAddNegResponse(pQueuedTObj
                                ,DCM_NET_TOBJ_RESTYPE_RCRRP
                                ,DCM_E_REQUESTCORRECTLYRECEIVEDRESPONSEPENDING);                                                                     /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */

    Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT); /* delegate job */
  }
}

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoveryInfoComMChannelState()
*********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RecoveryInfoComMChannelStatePtrType, DCM_CODE) Dcm_DiagGetRecoveryInfoComMChannelState(
                                                  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                 ,Dcm_CfgNetNetIdRefOptType index)
{
  Dcm_RecoveryInfoComMChannelStatePtrType lResult;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (index >= DCM_NET_MAX_NUM_COMM_CHANNELS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGGETRECOVERYINFOCOMMCHANNELSTATEITEM);
    lResult = &(RecoveryInfo->ComMChannelState[0]);
  }
  else
# endif
  {
    lResult = &(RecoveryInfo->ComMChannelState[index]);
  }
  return lResult;
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON && DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoveryInfoCommControlState()
*********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RecoveryInfoCommControlStatePtrType, DCM_CODE) Dcm_DiagGetRecoveryInfoCommControlState(
                                                  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                 ,Dcm_CfgNetNetIdRefOptType index)
{
  Dcm_RecoveryInfoCommControlStatePtrType lResult;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (index >= DCM_NET_MAX_NUM_ALL_COMM_CHANNELS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGGETRECOVERYINFOCOMMCONTROLSTATE);
    lResult = &(RecoveryInfo->CommControlState[0]);
  }
  else
# endif
  {
    lResult = &(RecoveryInfo->CommControlState[index]);
  }
  return lResult;
}
#endif
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON) && \
    (DCM_DEV_RAM_SHREDDER_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF tf xf */
/**********************************************************************************************************************
 *  Dcm_VarMgrRamShredder()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrRamShredder(void)
{
 /*
  * Depending on the configuration all PBL related RAM object shall be shredded for debug purposes.
  * The order is not of importance.
  */
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  Dcm_UtiRamShredderArray(Dcm_PbRamNetPeriodicTxObject, Dcm_NetPeriodicTxObjectType,  Dcm_PbCfgNetNumPerTxObjects,      DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# endif
  Dcm_UtiRamShredderArray(Dcm_PbRamNetComMContext,      Dcm_NetComMContextType,       Dcm_PbCfgNetNumComMChannels,      DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# if(DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_OFF)
  Dcm_UtiRamShredderArray(Dcm_PbRamNetConnId2TObjMap,   Dcm_CfgNetTObjHandleMemType,  Dcm_PbCfgNetNumConnections,       DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# endif
  Dcm_UtiRamShredderArray(Dcm_PbRamNetTransportObject,  Dcm_NetTransportObjectType,   Dcm_PbCfgNetNumTransportObjects,  DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
  Dcm_UtiRamShredderArray(Dcm_PbRamNetBufferContext,    Dcm_NetBufferContextType,     Dcm_PbCfgNetNumBuffers,           DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  Dcm_UtiRamShredderArray(Dcm_PbRamNetComCtrlChannels,  Dcm_CommunicationModeType,    Dcm_PbCfgNetNumAllComMChannels,   DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# endif
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
#endif

#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_VarMgrInit(Dcm_ConfigPtrType configPtr)
{
  uint8 lErrorId = DCM_E_NO_ERROR;
  boolean lResult;

# if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
  Dcm_VarMgrInitActiveCfgVariants();
# endif

# if (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON)                                                                                               /* COV_DCM_SUPPORT_ALWAYS TX */
  /* Check plausibility of the configuration pointer parameter */
  if (configPtr == NULL_PTR)
  {
    Dcm_EcuMErrorNotification(ECUM_BSWERROR_NULLPTR);
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#  if(DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
  if (configPtr->FinalMagicNumber != DCM_CFG_FINAL_MAGIC_NUMBER)
  {
    Dcm_EcuMErrorNotification(ECUM_BSWERROR_MAGICNUMBER);
    lErrorId = DCM_E_INVALID_CONFIG;
  }
  else if (configPtr->GenOutputType != DCM_CFG_GEN_COMPATIBILITY_VERSION)
  {
    Dcm_EcuMErrorNotification(ECUM_BSWERROR_COMPATIBILITYVERSION);
    lErrorId = DCM_E_INVALID_CONFIG;
  }
  else
#  endif
  {
    /* If the passed configuration variant is valid: */

    /* Store currently active variant(s) */
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    Dcm_SingletonContext.VarMgr.ActiveComVariant = configPtr->ComVariant;
#  endif
    /* Set bridge */
#  if (DCM_DIAG_MULTI_SVC_TABLE_ENABLED == STD_ON)
    Dcm_UtiAssignStruct(Dcm_SingletonContext.VarMgr.ActiveBridgeVariant, configPtr->BridgeVariant);                                                  /* PRQA S 0310, 3109 */ /* MD_Dcm_GenericStructAssign_0310, MD_MSR_14.3 */ /* SBSW_DCM_POINTER_WRITE_UTI_STRUCT */
#  endif
#  if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
    Dcm_UtiAssignStruct(Dcm_SingletonContext.VarMgr.ActiveRamVariant, *(configPtr->RamVariant));                                                     /* PRQA S 0310, 3109 */ /* MD_Dcm_GenericStructAssign_0310, MD_MSR_14.3 */ /* SBSW_DCM_POINTER_WRITE_UTI_STRUCT */
    Dcm_UtiAssignStruct(Dcm_SingletonContext.VarMgr.ActiveRomVariant, *(configPtr->RomVariant));                                                     /* PRQA S 0310, 3109 */ /* MD_Dcm_GenericStructAssign_0310, MD_MSR_14.3 */ /* SBSW_DCM_POINTER_WRITE_UTI_STRUCT */
#  endif

    /* (Optional) DCM global PBL RAM shredding for debug purposes (must be done after the variant reference cache is initialized) */
    Dcm_VarMgrRamShredder();

    /* Store currently active CFG-criteria(s) */
#  if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
#   if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_OFF)
    Dcm_SingletonContext.VarMgr.ActiveCfgVariantId = configPtr->DiagVariantId;
#   endif
#  endif
  }

#  if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_INIT, lErrorId);
  }
#  endif
# endif

# if (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON)                                                                                               /* COV_DCM_SUPPORT_ALWAYS TX */
  lResult = (boolean) (lErrorId == DCM_E_NO_ERROR);
# else
  lResult = TRUE;
# endif

  DCM_IGNORE_UNREF_PARAM(configPtr);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return lResult;
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrInitActiveCfgVariants()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrInitActiveCfgVariants(void)
{
  Dcm_CfgVarMgrDiagVariantIdOptType lVariantIter;
  /* Deactivate all Variants in ActiveCfgVariant Bitmap */
  for (lVariantIter = 0; lVariantIter < Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_CFG_VARIANTS); ++lVariantIter)
  {
    Dcm_SingletonContext.VarMgr.ActiveCfgVariants[lVariantIter] = 0u;                                                                                /* SBSW_DCM_POINTER_WRITE_VSGACTIVECFGVARIANTS */
  }

  Dcm_VarMgrBitSetSetBit(Dcm_SingletonContext.VarMgr.ActiveCfgVariants, 0u);/* activate base variant */                                              /* SBSW_DCM_POINTER_WRITE_BITSET */
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrVsgSetSingle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrVsgSetSingle(Dcm_VsgIdentifierType VsgId, Dcm_VsgStateType State)
{
  if(State == DCM_VSG_ENABLED)
  {
    Dcm_VarMgrBitSetSetBit(Dcm_SingletonContext.VarMgr.ActiveCfgVariants, VsgId);                                                                    /* SBSW_DCM_POINTER_WRITE_BITSET */
  } /* else State == DCM_VSG_DISABLED */
  else
  {
    Dcm_VarMgrBitSetClrBit(Dcm_SingletonContext.VarMgr.ActiveCfgVariants, VsgId);                                                                    /* SBSW_DCM_POINTER_WRITE_BITSET */
  }
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrVsgIsActive()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrVsgIsActive(Dcm_VsgIdentifierType VsgId
                                                           ,P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State)
{
  /* If Bit assigned to VsgId is set */
  if ((boolean)Dcm_VarMgrBitSetTestBit(Dcm_SingletonContext.VarMgr.ActiveCfgVariants, VsgId) == TRUE)
  {
    /* Set out parameter to enabled */
    *State = DCM_VSG_ENABLED;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  /* If Bit assigned to VsgId is cleared */
  else
  {
    /* Set out parameter to disabled */
    *State = DCM_VSG_DISABLED;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}
#endif
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc01ServiceInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
 DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc01ServiceInfoPtrType, DCM_CODE) Dcm_CfgSvc01ServiceInfoGetEntryOrNull(
                                                                                                    uint8_least index)
{
  Dcm_CfgSvc01ServiceInfoPtrType lServiceInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_CFGSVC01SERVICEINFOTABLE_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC01SERVICEINFOGETENTTRY);
    lServiceInfo = NULL_PTR;
  }
  else
# endif
  {
    lServiceInfo = &Dcm_CfgSvc01ServiceInfoTable[index];
  }

  return lServiceInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc01Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc01Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc01RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pRepContext->ParserDesc.LookUpTable       = Dcm_CfgSvc01LookUpTable;                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.LookUpFilterTable = Dcm_CfgSvc01ExecPrecondTable;                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.MaskData          = Dcm_CfgSvc01SupportedIdMask;                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */

  if(Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[0]))
  {
    lStdResult = Dcm_ObdIdMgrProcessSupportedIdRequest(pMsgContext, &(pRepContext->ParserDesc), ErrorCode);                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    if(pMsgContext->reqDataLen <= 6u)
    {
      uint8_least lIdIter;

      for(lIdIter = 0; lIdIter < pMsgContext->reqDataLen; lIdIter++)
      {
        if(Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[lIdIter]))
        {
          /* Otherwise return NRC 0x31 (Mix of Data and Availability IDs is not allowed) */
          *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          break;
        }
      }

      if(lStdResult == DCM_E_OK)
      {
        Dcm_RepeaterNextStep(DCM_SVC01_PROGRESS_REPEATERPROXY);
        lStdResult = DCM_E_LOOP;
      }
    }
    else
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc01_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc01_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc01RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8_least    lNumberOfIds = (uint8_least)pMsgContext->reqDataLen;
  uint8          lIdList[DCM_OBDIDMGR_MAX_NUMBER_OF_IDS];
  uint8_least    lIdIter;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Copy all requested IDs to local list. This allows to write into response buffer during parsing. */
  Dcm_DiagConsumeReqDataAsUN(pMsgContext, lIdList, DCM_OBDIDMGR_MAX_NUMBER_OF_IDS, pMsgContext->reqDataLen);                                         /* SBSW_DCM_COMB_PTR_FORWARD */

  for(lIdIter = 0; lIdIter < lNumberOfIds; lIdIter++)
  {
    uint8 lId = lIdList[lIdIter];

    if(Dcm_ObdIdMgrIdLookUp(lId, &(pRepContext->ParserDesc)) == DCM_E_OK)                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    {
      Dcm_CfgSvc01ServiceInfoPtrType pServiceInfo;

      pServiceInfo = Dcm_CfgSvc01ServiceInfoGetEntryOrNull(pRepContext->ParserDesc.Handle);

      Dcm_DiagProvideResDataAsU8(pMsgContext, lId);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if( (pServiceInfo == NULL_PTR)                                                                                                                 /* PRQA S 3415 */ /* MD_Dcm_3415 */
        ||(Dcm_DiagMsgContextVerifySize(pMsgContext, pServiceInfo->ResLength) == FALSE) )                                                            /* COV_DCM_RTM_RUNTIME_CHECK XF xf xf */ /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        lStdResult = DCM_E_NOT_OK;
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        break;
      }
      else
# endif
      {
        lStdResult = pServiceInfo->OpFunc(Dcm_DiagGetResData(pMsgContext));                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_SVC01SERVICEINFO */

        if(lStdResult == DCM_E_OK)
        {
          Dcm_DiagProvideResData(pMsgContext, pServiceInfo->ResLength);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
        else
        {
          *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          break;                                                                                                                                     /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
        }
      }
    }
  }

  /* If no requested ID was supported: */
  if (pMsgContext->resDataLen == 0)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_Svc02Handler()
*********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc02Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_Svc02RepeaterProxyContextPtrType pRepContext)                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* At maximum 3 PID + 3 FF can be requested */
  if( (pMsgContext->reqDataLen <= 6u)
    &&(Dcm_UtiIsEven(pMsgContext->reqDataLen)) )
  {
    pRepContext->ParserDesc.LookUpTable       = Dcm_CfgSvc02LookUpTable;                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ParserDesc.LookUpFilterTable = Dcm_CfgSvc02ExecPrecondTable;                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ParserDesc.MaskData          = Dcm_CfgSvc02SupportedIdMask;                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
    pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
# endif

    Dcm_RepeaterNextStep(DCM_SVC02_PROGRESS_REPEATERPROXY);
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc02_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc02_XX_RepeaterProxy(
                                                                     Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc02RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  Dcm_ObdIdMgrHandleOptType lPidIter = (Dcm_ObdIdMgrHandleOptType)pMsgContext->reqDataLen;
  uint8_least lPidTypeMask = 0x00u;
  uint8 lPidList[6];
  uint8 lFreezeFrameId;
  uint8 lPid;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Store the requested data */
  Dcm_DiagConsumeReqDataAsUN(pMsgContext, lPidList, 6u, pMsgContext->reqDataLen);                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_PARAM_PTR_FORWARD */

  do
  {
    /* OBD specification does not specify the order of PIDs in the response, thus it is ok to scan the requested PIDs backwards */
    --lPidIter;      /* navigate to the FF */
    lFreezeFrameId = lPidList[lPidIter];
    --lPidIter;      /* navigate to the PID */
    lPid = lPidList[lPidIter];

    lPidTypeMask |= (uint8)(Dcm_ObdIdMgrIsAvailabilityId(lPid) ? 0x01u : 0x02u);  /* mark availability/DATA PID found (never matter whether it is supported or not!) */

    if (lPidTypeMask != 0x03u)
    {
      if( (Dcm_ObdIdMgrIdLookUp(lPid, &(pRepContext->ParserDesc)) == DCM_E_OK)                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
        &&(lFreezeFrameId == 0x00u) ) /* Accept only FF = 0 */
      {
        if(Dcm_Svc02ReadPidData(lPid, pMsgContext, pRepContext) == DCM_E_OK)                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
        {
          lStdResult = DCM_E_OK;
        }
      }/* else:
       - FreezeFrame != 0 --> ignore
       - PID not supported --> ignore */
    }
    else
    {
      /* Otherwise return NRC 0x31 (Mix of Data and Availability PIDs is not allowed) */
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      break;
    }
  } while (lPidIter != 0u);

  /* If no PID was read send NRC 0x31 */
  if( (lStdResult == DCM_E_NOT_OK)
    &&(*ErrorCode == DCM_E_POSITIVERESPONSE) )
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  return lStdResult;
}
/**********************************************************************************************************************
 *  Dcm_Svc02ReadPidData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc02ReadPidData(uint8 pid
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_Svc02RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult = DCM_E_OK;

  /*
   * Check for sufficent buffer - It is ensured by the buffer size validation,
   * that the buffer is large enough to hold three availability PIDs plus data in the response
   */
  if(pMsgContext->resMaxDataLen < 4)
  {
    lStdResult = DCM_E_NOT_OK;
  }
  else if(Dcm_ObdIdMgrIsAvailabilityId(pid))
  {
    Dcm_DiagProvideResDataAsU8(pMsgContext, pid);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU8(pMsgContext, 0x00u); /* Only FF 0x00 is supported */                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU32(pMsgContext, Dcm_ObdIdMgrGetAvailabilityMask(pid, &(pRepContext->ParserDesc)));                                      /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else if(pid == 0x02u)
  {
    uint32 lDtc;

    Dcm_DiagProvideResDataAsU8(pMsgContext, 0x02u);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU8(pMsgContext, 0x00u); /* Only FF 0x00 is supported */                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

# if (DCM_DEM_API_430_ENABLED == STD_ON)
    if (Dem_DcmGetDTCOfOBDFreezeFrame(0x00u, &lDtc) != E_OK)                                                                                         /* SBSW_DCM_POINTER_FORWARD_STACK */
# else
    if(Dcm_DemAPI(GetDTCOfOBDFreezeFrame)(0x00u, &lDtc) != E_OK)                                                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */
# endif
    {
      lDtc = 0x0000u;
    }

    /* PID 0x02: DTC that stored the freeze frame */
    Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_UtiGetHiLoByte(lDtc));                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_UtiGetLoHiByte(lDtc));                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    /* other PID: get data from freeze frame */
    Std_ReturnType lStdReturn;
    uint8          bufSize;
    Dcm_MsgLenType remainingLen;
    Dcm_MsgType    freezeFrameDataBuffer;

    remainingLen = Dcm_DiagGetRemainingResLenWithOffset(pMsgContext, 2u);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    freezeFrameDataBuffer = Dcm_DiagGetResDataRel(pMsgContext, 2);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Calculate maximum possible buffer size (reduce by two to compensate the place for PID and FF!) */
    bufSize = (uint8)Dcm_UtiMathMin(remainingLen, 0xFFu);

# if (DCM_DEM_API_430_ENABLED == STD_ON)
    lStdReturn = Dem_DcmReadDataOfOBDFreezeFrame(
# else
    lStdReturn = Dcm_DemAPI(ReadDataOfOBDFreezeFrame)(
# endif
                                                      pid
                                                     ,0x00u /* DCM does not know the data index, so 0x00 is used here */
                                                     ,freezeFrameDataBuffer
                                                     ,&bufSize);                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

    if( (lStdReturn == E_OK)
      &&(bufSize > 0) )
    {
      Dcm_DiagProvideResDataAsU8(pMsgContext, pid);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideResDataAsU8(pMsgContext, 0x00u); /* Only FF 0x00 is supported */                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

      /* PID have been successfully read */
      Dcm_DiagProvideResData(pMsgContext, bufSize);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* else - PID can not be read or no data stored --> ignore */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_Svc03Handler()
*********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc03Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_ObdDtcManagerContextPtrType pRepContext)                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if (pMsgContext->reqDataLen == 0u)
  {
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
    pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
# endif
    Dcm_RepeaterNextStep(DCM_SVC03_PROGRESS_SETDTCFILTER);
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc03UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc03UtiDemSetDTCFilter(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_ObdDtcMgrDemSetDTCFilter(DCM_DTC_BIT_CONF_DTC, DEM_DTC_ORIGIN_PRIMARY_MEMORY, pMsgContext, ErrorCode, pRepContext);               /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_RepeaterNextStep(DCM_SVC03_PROGRESS_READDTCBYSTATUSMASK);

  return lStdResult;
}
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc04Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext                                    /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                ,Dcm_Svc04RepeaterProxyContextPtrType pRepContext)                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lStdResult;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(pMsgContext->reqDataLen == 0u)
  {
    Dcm_RepeaterSetUser(DCM_REPEATER_USER_DEM); /* set user for central repeater handling */
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
    Dcm_RepeaterNextStep(DCM_SVC04_PROGRESS_REPEATERPROXY_SELECT_DTC);
# else
    Dcm_RepeaterNextStep(DCM_SVC04_PROGRESS_REPEATERPROXY);
# endif
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy_SelectDTC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy_SelectDTC(Dcm_OpStatusType      opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc04RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Std_ReturnType lDemResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lDemResult = Dcm_DemAPI(SelectDTC)(pRepContext->DemClientId
                                    ,DEM_DTC_GROUP_ALL_DTCS
                                    ,DEM_DTC_FORMAT_OBD
                                    ,DEM_DTC_ORIGIN_OBD_RELEVANT_MEMORY);

  switch(lDemResult)
  {
  case E_OK:
    lStdResult = DCM_E_LOOP;
    Dcm_RepeaterNextStep(DCM_SVC04_PROGRESS_REPEATERPROXY);
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy(Dcm_OpStatusType                opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc04RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnClearDTCType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lResult = Dcm_DemAPI(ClearDTC)(
# if (DCM_DEM_API_430_ENABLED == STD_ON)
                                 pRepContext->DemClientId
# else
                                 DEM_DTC_GROUP_ALL_DTCS
                                ,DEM_DTC_FORMAT_OBD
                                ,DEM_DTC_ORIGIN_PRIMARY_MEMORY
# endif
                                );

  switch(lResult)
  {
  case DCM_DEM_RET_CLEAR_OK:
    lStdResult = DCM_E_OK;
    break;
  case DCM_DEM_RET_CLEAR_PENDING:
    lStdResult = DCM_E_PENDING; /* try again later */
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lResult, Dcm_Svc04NrcMapClearDTC);                                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_Svc06Handler()
*********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_Svc06RepeaterProxyContextPtrType pRepContext)                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8 lObdMid = pMsgContext->reqData[0];

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if (Dcm_ObdIdMgrIsAvailabilityId(lObdMid))
  {
    lStdResult = Dcm_Service06ProcessSupportedMidRequest(pMsgContext, ErrorCode);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else if (pMsgContext->reqDataLen == 1u)
  {
    Dcm_RepeaterNextStep(DCM_SVC06_PROGRESS_REPEATERPROXY);
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc06_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc06RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8 lObdMid = pMsgContext->reqData[0];
  uint8 lNumOfTIDs;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* #10 Request number of TIDs for MID from Dem */
  if (Dem_DcmGetNumTIDsOfOBDMID(lObdMid, &lNumOfTIDs) == E_OK)                                                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    /* #20 If request is successful */
    uint8 lTidIter;
    uint8 lTIDValue;
    uint8 lUaSID;
    uint16 lTestValue;
    uint16 lTestValueMin;
    uint16 lTestValueMax;

    /* #30  Request Test Result of each TID from Dem */
    for (lTidIter = 0; lTidIter < lNumOfTIDs; lTidIter++)
    {
      if (Dem_DcmGetDTRData(lObdMid
                           ,lTidIter
                           ,&lTIDValue
                           ,&lUaSID
                           ,&lTestValue
                           ,&lTestValueMin
                           ,&lTestValueMax) == E_OK)                                                                                                 /* SBSW_DCM_POINTER_FORWARD_STACK */
      {

        /* #40 If request is successful for a TID */

        /* #50 If response data buffer has not enough space */
        if (pMsgContext->resMaxDataLen < 9)
        {
          /* #51 Set NRC DCM_E_REQUESTOUTOFRANGE */
          *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
        /* #60 Otherwise copy response data to response buffer */
        else
        {
          Dcm_DiagProvideResDataAsU8(pMsgContext, lObdMid);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

          Dcm_DiagProvideResDataAsU8(pMsgContext, lTIDValue);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */

          Dcm_DiagProvideResDataAsU8(pMsgContext, lUaSID);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

          Dcm_DiagProvideResDataAsU16(pMsgContext, lTestValue);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
          Dcm_DiagProvideResDataAsU16(pMsgContext, lTestValueMin);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
          Dcm_DiagProvideResDataAsU16(pMsgContext, lTestValueMax);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }
      else
      {
        /* #70 Otherwise set NRC DCM_E_CONDITIONSNOTCORRECT */
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }

      /* #80 If any unexpected error occurred */
      if( lStdResult != DCM_E_OK)
      {
        /* #81 Exit service processing */
        break;
      }
    }
  }
  else
  {
    /* #90 Otherwise set NRC DCM_E_REQUESTOUTOFRANGE */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service06ProcessSupportedMidRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service06ProcessSupportedMidRequest
                                                                           (Dcm_MsgContextPtrType pMsgContext                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8_least lMidIter;
  uint8_least lNumberOfMids = (uint8) pMsgContext->reqDataLen;

  if (pMsgContext->reqDataLen <= DCM_OBDIDMGR_MAX_NUMBER_OF_IDS) /* Up to 6 IDs possible */
  {
    /* Check if any MID in request is not an availability MID (0x00, 0x20, 0x40...) */
    for (lMidIter = 0; lMidIter < lNumberOfMids; lMidIter++)
    {
      if (!Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[lMidIter]))
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        break;
      }
    }

    if (lStdResult == DCM_E_OK)
    {
      lStdResult = Dcm_Service06Process_SupportedMids(pMsgContext, ErrorCode);                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service06Process_SupportedMids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service06Process_SupportedMids(Dcm_MsgContextPtrType pMsgContext
                                                                         ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8_least lMidIter;
  uint8_least lNumberOfMids = (uint8) pMsgContext->reqDataLen;

  uint8 lMidList[DCM_OBDIDMGR_MAX_NUMBER_OF_IDS];
  /* Copy all requested IDs to local list. This allows to write into response buffer during parsing. */
  Dcm_DiagConsumeReqDataAsUN(pMsgContext, lMidList, DCM_OBDIDMGR_MAX_NUMBER_OF_IDS, pMsgContext->reqDataLen);                                        /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Request from Dem value of each MID */
  for (lMidIter = 0; lMidIter < lNumberOfMids; lMidIter++)
  {
    uint32 lObdMidAvailMask;
    if (Dem_DcmGetAvailableOBDMIDs((lMidList[lMidIter]), &lObdMidAvailMask) == E_OK)                                                                 /* PRQA S 3353 */ /* MD_Dcm_3353 */ /* SBSW_DCM_POINTER_FORWARD_STACK */
    {
      /* If response data buffer has not enough space */
      if (pMsgContext->resMaxDataLen < 5)
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        break;
      }
      /* Otherwise copy MID and MID value to response buffer */
      else
      {
        Dcm_DiagProvideResDataAsU8(pMsgContext, (lMidList[lMidIter]));                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagProvideResDataAsU32(pMsgContext, lObdMidAvailMask);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }
    /* else NRC will be set later if response length equal 0 -> none of the OBD MIDs could be read */
  }

  /* If response data buffer is empty  */
  if (pMsgContext->resDataLen == 0)
  {
    /* return NRC DCM_E_REQUESTOUTOFRANGE */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc06MidTidInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
 DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc06MidTidInfoPtrType, DCM_CODE) Dcm_CfgSvc06MidTidInfoGetEntryOrNull(uint8_least index)
{
  Dcm_CfgSvc06MidTidInfoPtrType lMidTidInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_CFGSVC06MIDTIDINFOTABLE_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC06MIDTIDINFOGETENTTRY);
    lMidTidInfo = NULL_PTR;
  }
  else
# endif
  {
    lMidTidInfo = &Dcm_CfgSvc06MidTidInfoTable[index];
  }

  return lMidTidInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc06Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc06RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pRepContext->ParserDesc.LookUpTable       = Dcm_CfgSvc06LookUpTable;                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.LookUpFilterTable = Dcm_CfgSvc06ExecPrecondTable;                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.MaskData          = Dcm_CfgSvc06SupportedIdMask;                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */

  if(Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[0]))
  {
    lStdResult = Dcm_ObdIdMgrProcessSupportedIdRequest(pMsgContext, &(pRepContext->ParserDesc), ErrorCode);                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    if(pMsgContext->reqDataLen == 1u)
    {
      if(Dcm_ObdIdMgrIdLookUp(pMsgContext->reqData[0], &(pRepContext->ParserDesc)) == DCM_E_OK)                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        Dcm_RepeaterNextStep(DCM_SVC06_PROGRESS_REPEATERPROXY);
        lStdResult = DCM_E_LOOP;
      }
      else
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
    else
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc06_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc06RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType                 lStdResult = DCM_E_OK;
  uint16                         lTestValue;
  uint16                         lMinLimit;
  uint16                         lMaxLimit;
  Dcm_DTRStatusType              lStatus;
  Dcm_CfgSvc06Mid2TidRefOptType  lHandle    = Dcm_CfgSvc06Mid2TidRefMap[pRepContext->ParserDesc.Handle];
  Dcm_CfgSvc06Mid2TidRefOptType  lMaxHandle = Dcm_CfgSvc06Mid2TidRefMap[pRepContext->ParserDesc.Handle + 1];
  Dcm_CfgSvc06MidTidInfoPtrType  pMidTidInfo;                                                                                                        /* PRQA S 3112 */ /* MD_Dcm_3112 */

  for(; lHandle<lMaxHandle; lHandle++)
  {
    pMidTidInfo = Dcm_CfgSvc06MidTidInfoGetEntryOrNull(lHandle);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    if(pMidTidInfo == NULL_PTR)                                                                                                                      /* PRQA S 3415 */ /* MD_Dcm_3415 */
    {
      lStdResult = DCM_E_NOT_OK;
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
# endif
    {
      if(pMidTidInfo->OpFunc(opStatus, &lTestValue, &lMinLimit, &lMaxLimit, &lStatus) == DCM_E_OK)                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */ /* SBSW_DCM_CALL_FUNCPTR_SVC06MIDTIDINFO */
      {
        if(lStatus == DCM_DTRSTATUS_INVISIBLE)
        {
          lTestValue = 0;
          lMinLimit  = 0;
          lMaxLimit  = 0;
        }

        /* Copy data */
        Dcm_DiagProvideResDataAsU8(pMsgContext, pMsgContext->reqData[0]);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagProvideResDataAsU8(pMsgContext, pMidTidInfo->Tid);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagProvideResDataAsU8(pMsgContext, pMidTidInfo->Uasid);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagProvideResDataAsU16(pMsgContext, lTestValue);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagProvideResDataAsU16(pMsgContext, lMinLimit);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagProvideResDataAsU16(pMsgContext, lMaxLimit);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }

    if (lStdResult != DCM_E_OK)
    {
      break;
    }
  }
  return lStdResult;
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_Svc07Handler()
*********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc07Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_ObdDtcManagerContextPtrType pRepContext)                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if (pMsgContext->reqDataLen == 0u)
  {
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
    pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
# endif
    Dcm_RepeaterNextStep(DCM_SVC07_PROGRESS_SETDTCFILTER);
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc07UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc07UtiDemSetDTCFilter(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_ObdDtcMgrDemSetDTCFilter(DCM_DTC_BIT_PNDG_DTC, DEM_DTC_ORIGIN_PRIMARY_MEMORY, pMsgContext, ErrorCode, pRepContext);               /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_RepeaterNextStep(DCM_SVC07_PROGRESS_READDTCBYSTATUSMASK);

  return lStdResult;
}
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc08ServiceInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc08ServiceInfoPtrType, DCM_CODE) Dcm_CfgSvc08ServiceInfoGetEntryOrNull(
                                                                                                  uint8_least index)
{
  Dcm_CfgSvc08ServiceInfoPtrType lSvc08ServiceInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (index >= DCM_CFGSVC08SERVICEINFOTABLE_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC08SERVICEINFOGETENTRY);
    lSvc08ServiceInfo = NULL_PTR;
  }
  else
# endif
  {
    lSvc08ServiceInfo = &Dcm_CfgSvc08ServiceInfoTable[index];
  }

  return lSvc08ServiceInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc08Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc08Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc08RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pRepContext->ParserDesc.LookUpTable       = Dcm_CfgSvc08LookUpTable;                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.LookUpFilterTable = Dcm_CfgSvc08ExecPrecondTable;                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.MaskData          = Dcm_CfgSvc08SupportedIdMask;                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */

  if(Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[0]))
  {
    lStdResult = Dcm_ObdIdMgrProcessSupportedIdRequest(pMsgContext, &(pRepContext->ParserDesc), ErrorCode);                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    if(Dcm_ObdIdMgrIdLookUp(pMsgContext->reqData[0], &(pRepContext->ParserDesc)) == DCM_E_OK)                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    {
      Dcm_RepeaterNextStep(DCM_SVC08_PROGRESS_REPEATERPROXY);
      lStdResult = DCM_E_LOOP;
    }
    else
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc08_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc08_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc08RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType                  lStdResult;
  Dcm_CfgSvc08ServiceInfoPtrType  pServiceInfo;

  pServiceInfo = Dcm_CfgSvc08ServiceInfoGetEntryOrNull(pRepContext->ParserDesc.Handle);

  if(opStatus == DCM_INITIAL)
  {
    /* Move pointer to request and response buffer to correct position */
    Dcm_DiagConsumeReqData(pMsgContext, 1u);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResData(pMsgContext, 1u);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pServiceInfo == NULL_PTR)                                                                                                                     /* PRQA S 3415 */ /* MD_Dcm_3415 */
    ||(Dcm_DiagMsgContextVerifySize(pMsgContext, pServiceInfo->ResLength) == FALSE) )                                                                /* COV_DCM_RTM_RUNTIME_CHECK XF xf xf */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
# endif
  {
    /* Data TID -> only one possible */
    if(pMsgContext->reqDataLen == pServiceInfo->ReqLength)
    {
      lStdResult = pServiceInfo->OpFunc(Dcm_DiagGetResData(pMsgContext)
                                       ,Dcm_DiagGetReqData(pMsgContext));                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_SVC08SERVICEINFO */

      if(lStdResult == DCM_E_OK)
      {
        /* Prepare for positive response with specific length of the data (TID is already provided) */
        Dcm_DiagProvideResData(pMsgContext, pServiceInfo->ResLength);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
    else
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }
  return lStdResult;
}
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc09ServiceInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
 DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc09ServiceInfoPtrType, DCM_CODE) Dcm_CfgSvc09ServiceInfoGetEntryOrNull(
                                                                                                    uint8_least index)
{
  Dcm_CfgSvc09ServiceInfoPtrType lServiceInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_CFGSVC09SERVICEINFOTABLE_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC09SERVICEINFOGETENTTRY);
    lServiceInfo = NULL_PTR;
  }
  else
# endif
  {
    lServiceInfo = &Dcm_CfgSvc09ServiceInfoTable[index];
  }

  return lServiceInfo;
}


/**********************************************************************************************************************
 *  Dcm_Svc09Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc09RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pRepContext->ParserDesc.LookUpTable       = Dcm_CfgSvc09LookUpTable;                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.LookUpFilterTable = Dcm_CfgSvc09ExecPrecondTable;                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.MaskData          = Dcm_CfgSvc09SupportedIdMask;                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */

  if(Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[0]))
  {
    lStdResult = Dcm_ObdIdMgrProcessSupportedIdRequest(pMsgContext, &(pRepContext->ParserDesc), ErrorCode);                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    if(pMsgContext->reqDataLen == 1u)
    {
      if(Dcm_ObdIdMgrIdLookUp(pMsgContext->reqData[0], &(pRepContext->ParserDesc)) == DCM_E_OK)                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        Dcm_RepeaterNextStep(DCM_SVC09_PROGRESS_REPEATERPROXY);
        lStdResult = DCM_E_LOOP;
      }
      else
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
    else
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc09_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc09RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType                  lStdResult;
  Dcm_CfgSvc09ServiceInfoPtrType  pServiceInfo;

  pServiceInfo = Dcm_CfgSvc09ServiceInfoGetEntryOrNull(pRepContext->ParserDesc.Handle);

  if(opStatus == DCM_INITIAL)
  {
    /* Write the VID first, then the response data */
    Dcm_DiagProvideResDataAsU8(pMsgContext, pMsgContext->reqData[0]);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pServiceInfo == NULL_PTR)                                                                                                                     /* PRQA S 3415 */ /* MD_Dcm_3415 */
    ||(Dcm_DiagMsgContextVerifySize(pMsgContext, pServiceInfo->ResLength) == FALSE) )                                                                /* COV_DCM_RTM_RUNTIME_CHECK XF xf xf */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
# endif
  {
    uint8 lVidDataLength = pServiceInfo->ResLength;

    /* compose response record */
    lStdResult = pServiceInfo->OpFunc(opStatus
                                     ,Dcm_DiagGetResData(pMsgContext)                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
                                     ,&lVidDataLength
# endif
                                     );                                                                                                              /* SBSW_DCM_COMB_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_SVC09SERVICEINFO */

    if (lStdResult == DCM_E_OK)
    {
# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
#  if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      /* Update final response length only in positive/final case */
      if (lVidDataLength > pServiceInfo->ResLength)
      {
        lStdResult = DCM_E_NOT_OK;
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        Dcm_DebugReportError(DCM_SID_SVCPORT_DATASVCS_OP_READVID, DCM_E_INTERFACE_BUFFER_OVERFLOW);
      }
      else
#  endif
# endif
      {
        /* VID reading finished with OK -> check for next */
        Dcm_DiagProvideResData(pMsgContext, lVidDataLength); /* data size */                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }
    else if(lStdResult == DCM_E_PENDING)
    {
      /* Retry later */
    }
    else
    {
      Dcm_DebugApiCheckRte((lStdResult == DCM_E_NOT_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }
  return lStdResult;
}
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_Svc0AHandler()
*********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc0AHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_ObdDtcManagerContextPtrType pRepContext)                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if (pMsgContext->reqDataLen == 0u)
  {
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
    pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
# endif
    Dcm_RepeaterNextStep(DCM_SVC0A_PROGRESS_SETDTCFILTER);
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc0AUtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc0AUtiDemSetDTCFilter(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_ObdDtcMgrDemSetDTCFilter(DCM_DTC_BIT_DONT_CARE, DEM_DTC_ORIGIN_PERMANENT_MEMORY, pMsgContext, ErrorCode, pRepContext);            /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_RepeaterNextStep(DCM_SVC0A_PROGRESS_READDTCBYSTATUSMASK);

  return lStdResult;
}
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForResetAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForResetAck(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Check mode switch state */
  lStdResult = Dcm_ModeMgrArEnvSwitchAckEcuReset();
  switch(lStdResult)
  {
  case DCM_E_PENDING:
    break;
  case DCM_E_OK:
#  if (DCM_DIAG_RCRRP_ON_BOOT_ENABLED == STD_ON)
    Dcm_RepeaterNextStep(DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK);
    if(Dcm_NetGetProtObjOfTranspObj(Dcm_DiagGetTranspObj())->HasRespPendOnBoot == TRUE)                                                              /* COV_DCM_RTM_DEPENDS_ON_UNSUPPORTED TX */
    {
      lStdResult = DCM_E_FORCE_RCRRP;
    }
    else
    {
      lStdResult = DCM_E_LOOP;
    }
#  else
#   if (DCM_SVC_10_RST2BOOT_HIS_ENABLED == STD_ON)
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_SplitTaskEnterCS();/* avoid interrupt from the Dcm_DiagTaskTx */                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    if(pMsgContext->msgAddInfo.suppressPosResponse != 0)
    {
      pRepContext->ProgConditions.ResponseRequired = FALSE;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_TmrStopTimer(DCM_TMR_ID_P2);/* Stop to avoid inconsistency between P2 timer and the SetProgCond asynchronous API's "ResponseRequired" value */
    }
    else
    {
      pRepContext->ProgConditions.ResponseRequired = TRUE;                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    Dcm_SplitTaskLeaveCS();/* avoid interrupt from the Dcm_DiagTaskTx */                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
#   else
    pRepContext->ProgConditions.ResponseRequired = FALSE;/* no response required since DCM sends the final response */                               /* SBSW_DCM_PARAM_PTR_WRITE */
#   endif

    Dcm_RepeaterNextStep(DCM_SVC10_PROGRESS_SET_PRGCOND);
    lStdResult = DCM_E_LOOP;
#  endif
    break;/* go on with next step - fall through */
  default:
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
#  if (DCM_DIAG_RCRRP_ON_BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForRcrRpAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForRcrRpAck(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(opStatus == DCM_FORCE_RCRRP_NOT_OK)
  {
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
  {
#   if (DCM_SVC_10_RST2BOOT_HIS_ENABLED == STD_ON)
    pRepContext->ProgConditions.ResponseRequired = TRUE;/* always since at least one RCR-RP is sent! */                                              /* SBSW_DCM_PARAM_PTR_WRITE */
#   else
    pRepContext->ProgConditions.ResponseRequired = FALSE;/* no response required since DCM sends the final response */                               /* SBSW_DCM_PARAM_PTR_WRITE */
#   endif
    Dcm_RepeaterNextStep(DCM_SVC10_PROGRESS_SET_PRGCOND);
    lStdResult = DCM_E_LOOP;
  }
  return lStdResult;
}
#  endif
# endif

# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_SetProgConditions()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_SetProgConditions(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Consider the SPRMIB now in order to take any sent RCR-RP response */
  lStdResult = Dcm_SetProgConditions(&pRepContext->ProgConditions);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  switch(lStdResult)
  {
  case DCM_E_OK:
#  if (DCM_SVC_10_RST2BOOT_HIS_ENABLED == STD_ON)
    lStdResult = Dcm_ModeMgrArEnvSwitchReqEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE);
    if(lStdResult == DCM_E_OK)/* fire and forget */
    {
      /* just wait for reset */
      lStdResult = DCM_E_STOP_REPEATER;
    }
    else
    {
      /* This code shall not be reached, since the programming conditions are already set! */
      *ErrorCode = DCM_E_PANIC_NRC; /* Use panic NRC since the first mode switch has succeeded, and this one shall too */                            /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
#  endif
    break; /* send final response and if applicable - do reset */
  case DCM_E_PENDING:
    /* already set */
    break;
  case DCM_E_NOT_OK:
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
# endif

/**********************************************************************************************************************
 *  Dcm_Svc10Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext)
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc10SubFuncLookUpTable
                                                   ,Dcm_CfgSvc10SubFuncExecPrecondTable
                                                   ,Dcm_DiagSvcWithOnlySubFuncReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&subSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
  if(lStdResult == DCM_E_OK)
  {
    /* Compose positive response */
    Dcm_DiagProvideResDataAsU16(pMsgContext, Dcm_CfgSvc10SubFuncInfo[subSvcRef].ResponseTime.P2);                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU16(pMsgContext, Dcm_CfgSvc10SubFuncInfo[subSvcRef].ResponseTime.P2Star);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

    Dcm_StateSetPendingSession(Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, subSvcRef));
    /* Set always a potential tester owner:
      * in case of failed positive response confirmation or negative response, the session will remain in its old state (default) -> the set value does not matter!
      * The situation that the session was a non-default one and another client has requested SID 0x10 is not possible:
      * - Each protocol switch invokes session transition to the default one!
      * - As long as a non-default session is active, no other client with the same priority can access the ECU! */
    Dcm_NetSetSessionConnection(Dcm_DiagGetTranspObj()->ConnId);/* set potential tester for the session */

    pRepContext->SesStateIdx = (uint8)subSvcRef;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
    pRepContext->ResetMode = DCM_MODEMGR_ARENV_MODE_ECURESET_NONE;                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    if(Dcm_CfgSvc10SubFuncInfo[subSvcRef].BootType != DCM_SVC10_BOOT_TYPE_NONE)
    {
      /* Prepare programming conditions */
      (void)Dcm_GetActiveProtocol(&pRepContext->ProgConditions.ProtocolId);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      pRepContext->ProgConditions.TesterSourceAddr = Dcm_PbCfgNetConnectionInfo[Dcm_DiagGetTranspObj()->ConnId].ClientSrcAddr;                       /* SBSW_DCM_PARAM_PTR_WRITE */
      pRepContext->ProgConditions.Sid = 0x10u;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      pRepContext->ProgConditions.SubFuncId = Dcm_CfgSvc10SubFuncLookUpTable[subSvcRef+1];                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      pRepContext->ProgConditions.ReprogrammingRequest = TRUE;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      /* This flag shall be initialized from the FBL, not the DCM!
      pRepContext->ProgConditions.ApplUpdated = TRUE; */
      /* To be set once the Dcm_setProgCond API is called in order to consider the current RCR-RP status!
        * pRepContext->ProgConditions.ResponseRequired = ...; */
      pRepContext->ResetMode = (Dcm_ModeMgrArEnvModeEcuResetType)((Dcm_CfgSvc10SubFuncInfo[subSvcRef].BootType == DCM_SVC10_BOOT_TYPE_OEM)
                                                                                                   ?DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_OEM
                                                                                                   :DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_SYS);   /* SBSW_DCM_PARAM_PTR_WRITE */

      if(Dcm_ModeMgrArEnvSwitchReqEcuReset(pRepContext->ResetMode) == DCM_E_OK)
      {
        /* Determine entry point - with or without RCR-RP */
        Dcm_RepeaterNextStep(DCM_SVC10_PROGRESS_WAIT_RESET_ACK);
        lStdResult = DCM_E_LOOP; /* start immediately */
      }
      else
      {
        /* for some reason, no mode switch is possible - exit with NRC */
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }/* else - just send the final response */
# endif
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc11SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc11SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc11SubFuncInfoGetEntryOrNull(
                                                                                Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc11SubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC11SUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC11SUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc11SubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc11Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED == STD_ON)
  pRepContext->SubFuncId = Dcm_DiagGetReqDataAsU8(pMsgContext);                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
# endif

  /* Min Length already checked in DiagDispatcher and expected to be 1 !!! */
  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc11SubFuncLookUpTable
                                                   ,Dcm_CfgSvc11SubFuncExecPrecondTable
                                                   ,Dcm_DiagSvcWithOnlySubFuncReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_RepeaterNextStep(DCM_SVC11_PROGRESS_SUBFUNCTION); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc11SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11SubFuncHandler(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_CfgSvc11SubFuncInfoPtrType pSubFuncInfo;

  pSubFuncInfo = Dcm_CfgSvc11SubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(opStatus, pMsgContext, ErrorCode);                                                                         /* SBSW_DCM_CALL_FUNCPTR_SVC11SUBFUNC */
  }

  return lStdResult;
}

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_EcuRst_WaitForAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_EcuRst_WaitForAck(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_ModeMgrArEnvSwitchAckEcuReset();
  switch(lStdResult)
  {
  case DCM_E_OK:
    /* switch accomplished */
    break;
  case DCM_E_PENDING:
    /* Result already set
      lStdResult = DCM_E_PENDING; */
    break;
  default: /* any error situation */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_RapPwrDwn_WaitForAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_RapPwrDwn_WaitForAck(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_ModeMgrArEnvSwitchAckRapidPowerShutDown();
  switch(lStdResult)
  {
  case DCM_E_OK:
    /* switch accomplished */
    break;
  case DCM_E_PENDING:
    /* Result already set
      lStdResult = DCM_E_PENDING; */
    break;
  default: /* any error situation */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(pMsgContext->reqDataLen == 3u)
  {
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
    pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());                                                            /* SBSW_DCM_GLOBAL_PTR_WRITE */
# endif

    /* Store requested DTC for asynchronous processing */
    Dcm_DiagConsumeReqDataAsU24(pMsgContext, &(pRepContext->Dtc));                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    Dcm_RepeaterSetUser(DCM_REPEATER_USER_DEM); /* set user for central repeater handling */
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
    Dcm_RepeaterNextStep(DCM_SVC14_PROGRESS_REPEATERPROXY_SELECT_DTC);
# else
    Dcm_RepeaterNextStep(DCM_SVC14_PROGRESS_REPEATERPROXY);
# endif

    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxy(Dcm_OpStatusType                opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType            lStdResult;
  Dcm_DemReturnClearDTCType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEM_API_430_ENABLED == STD_ON)
  lResult = Dcm_DemAPI(ClearDTC)(pRepContext->DemClientId);
# else
  lResult = Dcm_DemAPI(ClearDTC)(pRepContext->Dtc
                                ,DEM_DTC_FORMAT_UDS
                                ,DEM_DTC_ORIGIN_PRIMARY_MEMORY);
# endif

  switch(lResult)
  {
  case DCM_DEM_RET_CLEAR_OK:
    lStdResult = DCM_E_OK;
    break;
  case DCM_DEM_RET_CLEAR_PENDING:
    lStdResult = DCM_E_PENDING; /* try again later */
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lResult, Dcm_Svc14NrcMapClearDTC);                                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }

  return lStdResult;
}

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxySelectDTC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxySelectDTC(
                                                                       Dcm_OpStatusType                     opStatus
                                                                      ,Dcm_MsgContextPtrType                pMsgContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                      ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                      ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext)                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Std_ReturnType lDemResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lDemResult = Dcm_DemAPI(SelectDTC)(pRepContext->DemClientId
                                    ,pRepContext->Dtc
                                    ,DEM_DTC_FORMAT_UDS
                                    ,DEM_DTC_ORIGIN_PRIMARY_MEMORY);

  switch(lDemResult)
  {
  case E_OK:
    lStdResult = DCM_E_LOOP;
    Dcm_RepeaterNextStep(DCM_SVC14_PROGRESS_REPEATERPROXY_CHECK_SELECTION_RESULT);
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult(
                                                                       Dcm_OpStatusType                     opStatus
                                                                      ,Dcm_MsgContextPtrType                pMsgContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                      ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                      ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext)                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType            lStdResult;
  Dcm_DemReturnClearDTCType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lResult = Dcm_DemAPI(GetDTCSelectionResult)(pRepContext->DemClientId);

  switch(lResult)
  {
  case DCM_DEM_RET_CLEAR_OK:
    lStdResult = DCM_E_LOOP;
    Dcm_RepeaterNextStep(DCM_SVC14_PROGRESS_REPEATERPROXY);
    break;
  case DCM_DEM_RET_CLEAR_PENDING:
    lStdResult = DCM_E_PENDING; /* try again later */
    break;
  case DCM_DEM_RET_CLEAR_W_DTC:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc19SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc19SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc19SubFuncInfoGetEntryOrNull(
                                                                               Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc19SubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC19SUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC19SUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc19SubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc19Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc19SubFuncLookUpTable
                                                   ,Dcm_CfgSvc19SubFuncExecPrecondTable
                                                   ,Dcm_Svc19ReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());                                                              /* SBSW_DCM_GLOBAL_PTR_WRITE */
# endif

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_RepeaterSetUser(DCM_REPEATER_USER_DEM); /* set user for central repeater handling */
    Dcm_RepeaterNextStep(DCM_SVC19_PROGRESS_SUBFUNCTION); /* delegate job */

    Dcm_ExtSvc19UtiPatchDtcStatusInit();
    lStdResult = DCM_E_LOOP;/* speed up processing */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc19SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19SubFuncHandler(Dcm_OpStatusType                   opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_CfgSvc19SubFuncInfoPtrType pSubFuncInfo;

  pSubFuncInfo = Dcm_CfgSvc19SubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(opStatus, pMsgContext, ErrorCode);                                                                         /* SBSW_DCM_CALL_FUNCPTR_SVC19SUBFUNC */
  }

  return lStdResult;
}
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectDTC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectDTC(Dcm_OpStatusType                  opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DemAPI(SelectDTC)(pRepContext->DemClientId
                                    ,pRepContext->Dtc
                                    ,DEM_DTC_FORMAT_UDS
                                    ,pRepContext->Origin);

  switch (lStdResult)
  {
    case E_OK:
      lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_DemApiNrcMapSelectDTC);                                                            /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_SETDTCFILTER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSetDTCFilter(
                                                                   Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                  ,Dcm_Svc19DemSetFilterClassType       DsfClass
                                                                  ,uint8                                DtcStatusMask
                                                                  ,Dem_DTCSeverityType                  DtcSeverityMask
                                                                  ,Dcm_DemFilterForFDCType              FilterForFDC
                                                                  ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnSetFilterType demResultSetFilter;
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  demResultSetFilter = Dcm_DemAPI(SetDTCFilter)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
                                                pRepContext->DemClientId,
#  endif
                                                DtcStatusMask
#  if (DCM_DEM_API_430_ENABLED == STD_OFF)
                                               ,Dcm_Svc19DemDtcFilterInfo[DsfClass].Kind
#  endif
                                               ,DEM_DTC_FORMAT_UDS
                                               ,Dcm_Svc19DemDtcFilterInfo[DsfClass].Origin
                                               ,Dcm_Svc19DemDtcFilterInfo[DsfClass].ConsiderSeverity
                                               ,DtcSeverityMask
                                               ,FilterForFDC);

  if(demResultSetFilter == DCM_DEM_RET_FILTER_ACCEPTED)
  {
    lStdResult = DCM_E_OK;
  }
  else
  {
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResultSetFilter, Dcm_DemApiNrcMapSetDTCFilter);                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_MSR_STPAR */
# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Sv19UtiStartReporting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Sv19UtiStartReporting(uint8                            subUpdater
                                                                     ,Dcm_MsgLenType                       reportSize
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  DCM_IGNORE_UNREF_PARAM(reportSize);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pRepContext->SubUpdater = subUpdater;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */

#  if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_PagedBufferStart(reportSize);
  return DCM_E_STOP_REPEATER;
#  else
  Dcm_RepeaterNextStep(DCM_SVC19_PROGRESS_UTI_COPYLINEARDATA);
  return DCM_E_LOOP;
#  endif
}
# endif

# if (DCM_SVC_19_ABSTRACT_RECORD_ITER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Sv19UtiRecordIterNext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc19UtiRecordIterResultType, DCM_CODE) Dcm_Svc19UtiRecordIterNext(
                                                                      Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Dcm_Svc19UtiRecordIterResultType lRecIterResult;

  lRecIterResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;

  if(pRepContext->RecordNumList != NULL_PTR)
  {
    Dcm_UtiNextItemByPtr(pRepContext->RecordNumList, 1u);                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->RecordNum = pRepContext->RecordNumList[0];                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
    if(pRepContext->RecordNum != DCM_SVC_19_RECLIST_END)
    {
      lRecIterResult = DCM_SVC19_UTI_REC_ITER_RSLT_OK;
    }
  }

  return lRecIterResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemDisableRecordUpdate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemDisableRecordUpdate(Dcm_OpStatusType        opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnDisableDTCRecordUpdateType demResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(DisableDTCRecordUpdate)(pRepContext->DemClientId);
#  else
  demResult = Dcm_DemAPI(DisableDTCRecordUpdate)(pRepContext->Dtc
                                                ,pRepContext->Origin);
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_DISABLE_DTC_REC_UP_OK:
    lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_DISABLE_DTC_REC_UP_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapAnyAbleRecordUpdate);                                                      /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetStatusOfDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetStatusOfDtc(Dcm_OpStatusType             opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetStatusOfDTCType demResult;
  uint8 dtcStatusMask;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetStatusOfDTC)(pRepContext->DemClientId
                                        ,&dtcStatusMask);                                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  demResult = Dcm_DemAPI(GetStatusOfDTC)(pRepContext->Dtc
                                        ,pRepContext->Origin
                                        ,&dtcStatusMask);                                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_STATUS_OK:
    Dcm_ExtSvc19UtiPatchDtcStatusApplyByResult(&dtcStatusMask);                                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_POINTER_FORWARD_STACK */

    Dcm_DiagProvideResDataAsU24(pMsgContext, pRepContext->Dtc);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcStatusMask);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#  if defined (DCM_DEM_RET_STATUS_NO_SUCH_ELEMENT)
  case DCM_DEM_RET_STATUS_NO_SUCH_ELEMENT:
    /* Skip committing data (SWS_Dcm_01409) */
    lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#  endif
  case DCM_DEM_RET_STATUS_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetStatusOfDTC);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfFFRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfFFRecord(Dcm_OpStatusType         opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetSizeOfFFRByDTCType demResult;
  uint16 dataLen;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetSizeOfFreezeFrameSelection)(pRepContext->DemClientId
                                                       ,&dataLen);                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  demResult = Dcm_DemAPI(GetSizeOfFreezeFrameByDTC)(pRepContext->Dtc
                                                   ,pRepContext->Origin
                                                   ,pRepContext->RecordNum
                                                   ,&dataLen);                                                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_SIZEOFFFR_OK:
    if(dataLen != 0u) /* consider only stored records */
    {
      if(pRepContext->RecordNumList != NULL_PTR)
      {
        pRepContext->RecordNum = pRepContext->RecordNumList[0]; /* take first one */                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
        Dcm_DebugAssert((DCM_SVC_19_RECNUM_ALL != pRepContext->RecordNum), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                    /* COV_DCM_RTM_DEV_DEBUG XF */
      }

      lStdResult = Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_FF_RECORD
                                            ,dataLen
                                            ,pRepContext);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* Otherwise, proceed with response transmission with no further data */
      lStdResult = DCM_E_OK;
    }
    break;
  case DCM_DEM_RET_SIZEOFFFR_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetSizeOfFreezeFrameByDTC);                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEM_API_SELECT_EDR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectExtRecord(Dcm_OpStatusType            opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  (void)Dcm_DemAPI(SelectExtendedDataRecord)(pRepContext->DemClientId
                                            ,pRepContext->RecordNum);

  return Dcm_Svc19UtiChainNext(pRepContext);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfExtRecord(Dcm_OpStatusType         opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;
  Dcm_DemReturnGetSizeOfEDRByDTCType demResult;
  uint16 dataLen;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetSizeOfExtendedDataRecordSelection)(pRepContext->DemClientId
                                                              ,&dataLen);                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  demResult = Dcm_DemAPI(GetSizeOfExtendedDataRecordByDTC)(pRepContext->Dtc
                                                          ,pRepContext->Origin
                                                          ,pRepContext->RecordNum
                                                          ,&dataLen);                                                                                /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_SIZEOFEDR_OK:
    if(dataLen != 0u) /* consider only stored records */
    {
      if(pRepContext->RecordNumList != NULL_PTR)
      {
        pRepContext->RecordNum = pRepContext->RecordNumList[0];/* take first one */                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
        Dcm_DebugAssert((DCM_SVC_19_RECNUM_ALL != pRepContext->RecordNum), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                    /* COV_DCM_RTM_DEV_DEBUG XF */
      }
#  if (DCM_DEM_API_403_ENABLED == STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF */
      else
      {
        ++dataLen; /* DEM considers the RecordNumberByte in case of ALL RECs, in single RecordNum -> add manually */
      }
#  endif
      lStdReturn = Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_EXT_RECORD
                                            ,dataLen
                                            ,pRepContext);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* Otherwise, proceed with response transmission with no further data */
      lStdReturn = DCM_E_OK;
    }
    break;
  case DCM_DEM_RET_SIZEOFEDR_PENDING:
    lStdReturn = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetSizeOfExtendedDataRecordByDTC);                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
    break;
  }
  return lStdReturn;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNumFltrdDtc(Dcm_OpStatusType             opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetNumberOfFilteredDTCType demResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(pRepContext->DemClientId
                                                ,&pRepContext->NumDtc);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(&pRepContext->NumDtc);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_NUMBER_OK:
    lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_NUMBER_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:/* DEM_NUMBER_FAILED or unknown */
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_DemApiNrcMapGetNumberOfFilteredDTC);                                                  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdSeverity(Dcm_OpStatusType        opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY
                                  ,(Dcm_MsgLenType)(pRepContext->NumDtc * 6)
                                  ,pRepContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSeverityOfDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSeverityOfDtc(Dcm_OpStatusType           opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetSeverityOfDTCType demResultSeverity;
  uint8 dtcSeverity;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResultSeverity = Dcm_DemAPI(GetSeverityOfDTC)(pRepContext->DemClientId
                                                  ,&dtcSeverity);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  demResultSeverity = Dcm_DemAPI(GetSeverityOfDTC)(pRepContext->Dtc
                                                  ,&dtcSeverity);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  switch(demResultSeverity)
  {
#  if defined (DCM_DEM_RET_GET_SEVERITY_OF_DTC_NOSEVERITY)
  case DCM_DEM_RET_GET_SEVERITY_OF_DTC_NOSEVERITY:
    dtcSeverity = 0; /* set to NO SEVERITY as specified in ISO14229-1 and go on with the remained part */
    /* fall through */
#  endif
  case DCM_DEM_RET_GET_SEVERITY_OF_DTC_OK:                                                                                                           /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSeverity);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_GET_SEVERITY_OF_DTC_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResultSeverity, Dcm_Svc19NrcMapGetSeverityOfDTC);                                                 /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetFuncUnitOfDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetFuncUnitOfDtc(Dcm_OpStatusType           opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  uint8 functionalUnit;
  Dcm_DemReturnGetFunctionalUnitOfDTCType lDemResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lDemResult = Dcm_DemAPI(GetFunctionalUnitOfDTC)(pRepContext->DemClientId
                                                 ,&functionalUnit);                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  lDemResult = Dcm_DemAPI(GetFunctionalUnitOfDTC)(pRepContext->Dtc
                                                 ,&functionalUnit);                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  switch(lDemResult)
  {
    case DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_OK:
      Dcm_DiagProvideResDataAsU8(pMsgContext, functionalUnit);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  if defined (DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_PENDING)
    case DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_PENDING:
      lStdResult = DCM_E_PENDING;
      break;
#  endif
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lDemResult, Dcm_Svc19NrcMapGetFunctionalUnitOfDTC);                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdDtc(Dcm_OpStatusType             opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_NXT_FLTRD_DTC
                                  ,(Dcm_MsgLenType)(pRepContext->NumDtc * 4)
                                  ,pRepContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiPutNumFilteredDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiPutNumFilteredDtc(Dcm_OpStatusType            opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagProvideResDataAsU16(pMsgContext, pRepContext->NumDtc);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

  return DCM_E_OK;
}
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdFDC(Dcm_OpStatusType              opStatus
                                                                      ,Dcm_MsgContextPtrType                pMsgContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                      ,Dcm_NegativeResponseCodePtrType      ErrorCode                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                      ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_NXT_FLTRD_FDC
                                  ,(Dcm_MsgLenType)(pRepContext->NumDtc * 4)
                                  ,pRepContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity(Dcm_OpStatusType  opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY_WWHOBD
                                  ,(Dcm_MsgLenType)(pRepContext->NumDtc * 5)
                                  ,pRepContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdRecord(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  uint32                                lDtc;
  uint8                                 recordNumber;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  while (pDataContext->AvailLen >= 4u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredRecord)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
        pRepContext->DemClientId,
#  endif
        &lDtc, &recordNumber);                                                                                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_DiagProvideDataAsU24(pDataContext, lDtc);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, recordNumber);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING)                                                                                    /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  uint32                                lDtc;
  uint8                                 dtcStatus;
  uint8                                 dtcFuncUnit;
  Dem_DTCSeverityType                   dtcSeverity;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  while (pDataContext->AvailLen >= 6u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTCAndSeverity)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
                                                          pRepContext->DemClientId,
#  endif
                                                          &lDtc
                                                         ,&dtcStatus
                                                         ,&dtcSeverity
                                                         ,&dtcFuncUnit);                                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(&dtcStatus);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_POINTER_FORWARD_STACK */

      Dcm_DiagProvideDataAsU8(pDataContext, (Dcm_MsgItemType)dtcSeverity);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, dtcFuncUnit);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU24(pDataContext, lDtc);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, dtcStatus);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING) /* signal retry */                                                                 /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdFDC(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  uint32                                lDtc;
  sint8                                 dtcFDC;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  while (pDataContext->AvailLen >= 4u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTCAndFDC)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
                                                     pRepContext->DemClientId,
#  endif
                                                     &lDtc, &dtcFDC);                                                                                /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_DiagProvideDataAsU24(pDataContext, lDtc);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, (uint8)dtcFDC);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING)                                                                                    /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  uint32                                lDtc;
  uint8                                 dtcStatus;
  uint8                                 dtcFuncUnit;
  Dem_DTCSeverityType                   dtcSeverity;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  while (pDataContext->AvailLen >= 5u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTCAndSeverity)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
                                                          pRepContext->DemClientId,
#  endif
                                                          &lDtc
                                                         ,&dtcStatus
                                                         ,&dtcSeverity
                                                         ,&dtcFuncUnit);                                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(&dtcStatus);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_POINTER_FORWARD_STACK */

      Dcm_DiagProvideDataAsU8(pDataContext, (Dcm_MsgItemType)dtcSeverity);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU24(pDataContext, lDtc);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, dtcStatus);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING)                                                                                    /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdDtc(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  uint32                                lDtc;
  uint8                                 dtcStatus;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  while (pDataContext->AvailLen >= 4u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTC)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
                                               pRepContext->DemClientId,
#  endif
                                               &lDtc, &dtcStatus);                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(&dtcStatus);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_POINTER_FORWARD_STACK */

      Dcm_DiagProvideDataAsU24(pDataContext, lDtc);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, dtcStatus);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING) /* signal retry */                                                                 /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetExtRecord(Dcm_DiagDataContextPtrType  pDataContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType  demResult;
  Std_ReturnType  lStdResult;
  uint16          dcmBufferSize;
  boolean         readNextData = TRUE;

  do
  {
    dcmBufferSize = (uint16) pDataContext->AvailLen;

    demResult = Dcm_DemAPI(GetNextExtendedDataRecord)(pRepContext->DemClientId
                                                     ,Dcm_DiagGetDataContextBuffer(pDataContext)                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                     ,&dcmBufferSize);                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */

    switch (demResult)
    {
    case DCM_DEM_RET_GET_EXT_DATA_REC_OK:
      Dcm_DiagCommitData(pDataContext, dcmBufferSize);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_OK;
      break;
    case DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_NUMBER:
      lStdResult = DCM_E_OK;
      readNextData = FALSE;
      break;
    case DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_BUFFERSIZE:
      lStdResult = DCM_E_BUFFERTOOLOW;
      readNextData = FALSE;
      break;
    case DCM_DEM_RET_GET_EXT_DATA_REC_PENDING:
      lStdResult = DCM_E_PENDING;/* signal retry */
      readNextData = FALSE;
      break;
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetExtendedDataRecordByDTC);                                             /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      readNextData = FALSE;
      break;
    }
  }
  while (readNextData == TRUE);

  /* If record data processing finished in this call (with or without success), enable DTC record update immediately */
  if((lStdResult == DCM_E_OK) || (lStdResult == DCM_E_NOT_OK))
  {
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)(pRepContext->DemClientId);
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#  else
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetExtRecord(Dcm_DiagDataContextPtrType  pDataContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Dem_ReturnGetExtendedDataRecordByDTCType demResult;
  Std_ReturnType                           lStdResult;
  uint16                                   dcmBufferSize;
  Dcm_Svc19UtiRecordIterResultType         dcmNextRecordResult;

  do
  {
    /* Move one byte up to reserve place for the record number */
    Dcm_DiagCommitData(pDataContext, 1);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

    dcmBufferSize = (uint16) pDataContext->AvailLen;

    demResult = Dcm_DemAPI(GetExtendedDataRecordByDTC)(pRepContext->Dtc
                                                      ,pRepContext->Origin
                                                      ,pRepContext->RecordNum
                                                      ,Dcm_DiagGetDataContextBuffer(pDataContext)                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                      ,&dcmBufferSize);                                                                              /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Move back to original position to write now the data */
    Dcm_DiagRevertData(pDataContext, 1);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(demResult == DCM_DEM_RET_GET_EXT_DATA_REC_OK)
    {
      if(dcmBufferSize != 0)/* consider only stored records */
      {
        Dcm_DiagProvideDataAsU8(pDataContext, pRepContext->RecordNum);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagCommitData(pDataContext, dcmBufferSize);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      }

      dcmNextRecordResult = Dcm_Svc19UtiRecordIterNext(pRepContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_OK;
    }
    else if(demResult == DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_NUMBER)
    {
      if(pRepContext->RecordNumList == NULL_PTR)/* single record query */
      {
        dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetExtendedDataRecordByDTC);                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
      else
      {
        dcmNextRecordResult = Dcm_Svc19UtiRecordIterNext(pRepContext);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = DCM_E_OK;
      }
    }
    else
    {
      dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;
      switch (demResult)
      {
      case DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_BUFFERSIZE:
        lStdResult = DCM_E_BUFFERTOOLOW;
        break;
      case DCM_DEM_RET_GET_EXT_DATA_REC_PENDING:
        lStdResult = DCM_E_PENDING;/* signal retry */
        break;
      default:
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetExtendedDataRecordByDTC);                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        break;
      }
    }

    /* If no more records to be reported or current iteration detected an error, stop iteration */
    if(dcmNextRecordResult == DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS)
    {
      break;
    }
  }
  while (pDataContext->AvailLen != 0u);

  if ( (pDataContext->AvailLen == 0u)
     &&(dcmNextRecordResult != DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS) )
  {
    lStdResult = DCM_E_BUFFERTOOLOW;
  }

  /* If record data processing finished in this call (with or without success), enable DTC record update immediately */
  if((lStdResult == DCM_E_OK) || (lStdResult == DCM_E_NOT_OK))
  {
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)();
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#  endif
# endif

# if (DCM_DEM_API_SELECT_FFR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectFFData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectFFData(
                                                                      Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  (void)Dcm_DemAPI(SelectFreezeFrameData)(pRepContext->DemClientId
                                         ,pRepContext->RecordNum);

  return Dcm_Svc19UtiChainNext(pRepContext);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetFFRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetFFRecord(Dcm_DiagDataContextPtrType   pDataContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType  demResult;
  Std_ReturnType  lStdResult;
  uint16          dcmBufferSize;
  boolean         readNextData = TRUE;

  do
  {
    dcmBufferSize = (uint16)pDataContext->AvailLen;

    demResult =  Dcm_DemAPI(GetNextFreezeFrameData)(pRepContext->DemClientId
                                                   ,Dcm_DiagGetDataContextBuffer(pDataContext)                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                   ,&dcmBufferSize);                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */

    switch (demResult)
    {
    case DCM_DEM_RET_FFDATABYDTC_OK:
      if(dcmBufferSize != 0u)/* consider only stored records */
      {
        Dcm_DiagCommitData(pDataContext, dcmBufferSize);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      lStdResult = DCM_E_OK;
      break;
    case DCM_DEM_RET_FFDATABYDTC_W_RNUM:
      lStdResult = DCM_E_OK;
      readNextData = FALSE;
      break;
    case DCM_DEM_RET_FFDATABYDTC_W_BUFSIZE:
      lStdResult = DCM_E_BUFFERTOOLOW;
      readNextData = FALSE;
      break;
    case DCM_DEM_RET_FFDATABYDTC_PENDING:
      lStdResult = DCM_E_PENDING;/* signal retry */
      readNextData = FALSE;
      break;
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetFreezeFrameDataByDTC);                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;/* finish processing */
      readNextData = FALSE;
      break;
    }
  }
  while (readNextData == TRUE);

  /* If record data processing finished in this call (with or without success), enable DTC record update immediately */
  if((lStdResult == DCM_E_OK) || (lStdResult == DCM_E_NOT_OK))
  {
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)(pRepContext->DemClientId);
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#  else
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetFFRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetFFRecord(Dcm_DiagDataContextPtrType   pDataContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Dem_ReturnGetFreezeFrameDataByDTCType demResult;
  Std_ReturnType                        lStdResult;
  uint16                                dcmBufferSize;
  Dcm_Svc19UtiRecordIterResultType      dcmNextRecordResult;

  do
  {
    dcmBufferSize = (uint16)pDataContext->AvailLen;

    demResult =  Dcm_DemAPI(GetFreezeFrameDataByDTC)(pRepContext->Dtc
                                                    ,pRepContext->Origin
                                                    ,pRepContext->RecordNum
                                                    ,Dcm_DiagGetDataContextBuffer(pDataContext)                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                    ,&dcmBufferSize);                                                                                /* SBSW_DCM_COMB_PTR_FORWARD */
    if(demResult == DCM_DEM_RET_FFDATABYDTC_OK)
    {
      Dcm_DiagCommitData(pDataContext, dcmBufferSize);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      dcmNextRecordResult = Dcm_Svc19UtiRecordIterNext(pRepContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_OK;
    }
    else if(demResult == DCM_DEM_RET_FFDATABYDTC_W_RNUM)
    {
      if(pRepContext->RecordNumList == NULL_PTR)/* single record query */
      {
        dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetFreezeFrameDataByDTC);                                              /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
      else
      {
        dcmNextRecordResult = Dcm_Svc19UtiRecordIterNext(pRepContext);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = DCM_E_OK;
      }
    }
    else
    {
      switch (demResult)
      {
      case DCM_DEM_RET_FFDATABYDTC_W_BUFSIZE:
        lStdResult = DCM_E_BUFFERTOOLOW;
        break;
      case DCM_DEM_RET_FFDATABYDTC_PENDING:
        lStdResult = DCM_E_PENDING;/* signal retry */
        break;
      default:
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetFreezeFrameDataByDTC);                                              /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;/* finish processing */
        break;
      }
      /* Finished for this cycle or error occurred */
      dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;
    }

    if(dcmNextRecordResult == DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS)
    {
      break;
    }
  }
  while(pDataContext->AvailLen != 0);

  if( (pDataContext->AvailLen == 0u)
    &&(dcmNextRecordResult != DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS) )
  {
    lStdResult = DCM_E_BUFFERTOOLOW;
  }

  /* If record data processing finished in this call (with or without success), enable DTC record update immediately */
  if((lStdResult == DCM_E_OK) || (lStdResult == DCM_E_NOT_OK))
  {
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)();
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#  endif
# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19UtiCopyData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service19UtiCopyData(Dcm_DiagDataContextPtrType           pDataContext
                                                                        ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                        ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  switch(pRepContext->SubUpdater)
  {
#  if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_DTC:
      lStdResult = Dcm_Svc19UtiCpyDemGetNxtFltrdDtc(pDataContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_RECORD:
      lStdResult = Dcm_Svc19UtiCpyDemGetNxtFltrdRecord(pDataContext, ErrorCode, pRepContext);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_FDC:
      lStdResult = Dcm_Svc19UtiCpyDemGetNxtFltrdFDC(pDataContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY:
      lStdResult = Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity(pDataContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY_WWHOBD:
      lStdResult = Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity(pDataContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_EXT_RECORD:
      lStdResult = Dcm_Svc19UtiCpyDemGetExtRecord(pDataContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_FF_RECORD:
      lStdResult = Dcm_Svc19UtiCpyDemGetFFRecord(pDataContext, ErrorCode, pRepContext);                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)
      break;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif

# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCopyLinearData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCopyLinearData(Dcm_OpStatusType                opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType           lStdResult;
  Dcm_DiagDataContextType  lDataContext;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagInitDataContext(&lDataContext, Dcm_DiagGetResData(pMsgContext), pMsgContext->resMaxDataLen);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

  lStdResult = Dcm_Service19UtiCopyData(&lDataContext, ErrorCode, pRepContext);                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Commit copied data */
  Dcm_DiagProvideResData(pMsgContext, lDataContext.Usage);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(  (lStdResult != DCM_E_PENDING)
    && (lStdResult != DCM_E_NOT_OK))
  {
    if(lStdResult == DCM_E_BUFFERTOOLOW)
    {
      *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
    {
      lStdResult = DCM_E_OK;
    }
  }
  return lStdResult;
}
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22GetDidInfoContext()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrDidInfoContextPtrType, DCM_CODE) Dcm_Svc22GetDidInfoContext(
                                                                     Dcm_Svc22RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_DidMgrDidInfoContextPtrType lResult;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(pRepContext->DidInfoContextIdx >= DCM_SVC_22_MAX_DID_LIST_LEN)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_SVC22GETDIDINFOCONTEXT);
    lResult = &(pRepContext->DidInfoContextList[0]);
  }
  else
# endif
  {
    lResult = &(pRepContext->DidInfoContextList[pRepContext->DidInfoContextIdx]);
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If the request length is even (SID is already extracted) and does not exceed the capacity of the ECU: */
  if( (Dcm_UtiIsEven(pMsgContext->reqDataLen))
    &&(pMsgContext->reqDataLen <= (Dcm_MsgLenType)(DCM_SVC_22_MAX_DID_LIST_LEN * 2)) )
  {
    pRepContext->DidInfoContextIdx = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->NumDids           = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->DidIter           = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ActualLength      = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ReservedLength    = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_DIDLOOKUP);
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22ReadDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadDid(Dcm_OpStatusType                  opStatus
                                                                ,Dcm_DiagDataContextPtrType        pDataContext
                                                                ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType lStdResult;

  /* Try to read the DID data */
  lStdResult = Dcm_DidMgrReadDid(opStatus
                                ,pDataContext
                                ,pDidInfoContext
                                ,pDidOpTypeContext
                                ,ErrorCode);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  switch(lStdResult)
  {
  case DCM_E_PENDING:
    /* Try it the next task cycle */
    break;
# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
  case DCM_E_BUFFERTOOLOW:
    /* Notify the page buffer and try it later */
    break;
# endif
# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
  case DCM_E_FORCE_RCRRP:
    break;
# endif
  case DCM_E_OK:
    /* Go on with next DID */
    Dcm_DidMgrDidRelease(DCM_DIDMGR_DIDLOCK_OWNER_READONCE);
    break;
  default: /* DCM_E_NOT_OK */
    /* Finish service processing immediately by sending the appropriate NRC */
    Dcm_DidMgrDidRelease(DCM_DIDMGR_DIDLOCK_OWNER_READONCE);
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22UtiReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22UtiReadData(Dcm_OpStatusType                     opStatus
                                                                    ,Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                   lStdResult;
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(Dcm_DidMgrDidHasLock(DCM_DIDMGR_DIDLOCK_OWNER_READONCE) == FALSE)
  {
# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
    if(pDataContext->AvailLen < 2u)
    {
      lStdResult = DCM_E_BUFFERTOOLOW;
    }
    else
# endif
    {
      lStdResult = Dcm_DidMgrDidLock(pDidInfoContext->Did, DCM_DIDMGR_DIDLOCK_OWNER_READONCE);

      if(lStdResult == DCM_E_OK)
      {
        Dcm_DiagProvideDataAsU16(pDataContext, pDidInfoContext->Did);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_DidMgrInitOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_READ);                                                                          /* SBSW_DCM_POINTER_WRITE_DIDINFOCONTEXT */

        lStdResult = DCM_E_LOOP;
      }
    }
  }
  else
  {
    /*
     *  Action/Return value | DCM_E_PENDING | DCM_E_BUFFERTOOLOW | DCM_E_OK
     * ---------------------+---------------+--------------------+----------
     *  call again          |      yes      |        yes         |   no
     *  data committed      |      no       |        yes         |   yes
     *  ready               |      no       |        no          |   yes
     */

    /* Try to read the DID data */
    lStdResult = Dcm_Svc22ReadDid(opStatus
                                 ,pDataContext
                                 ,pDidInfoContext
                                 ,&(pRepContext->DidOpTypeContext)
                                 ,ErrorCode);                                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)
    {
      --pRepContext->NumDids;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
      if(pRepContext->NumDids != 0)
      {
        /* Read next Did */
        pRepContext->DidInfoContextIdx++;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */

        lStdResult = DCM_E_LOOP;
      }
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22DidLookUp(Dcm_OpStatusType                     opStatus
                                                                  ,Dcm_MsgContextPtrType                pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                  ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                   lStdReturn;
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(opStatus == DCM_INITIAL)
  {
    Dcm_DiagConsumeReqDataAsU16(pMsgContext, &(pDidInfoContext->Did));                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,pDidInfoContext
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_READ);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */

  switch(lStdReturn)
  {
    case DCM_E_OK:
      ++(pRepContext->NumDids); /* register a supported DID */                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

      lStdReturn = Dcm_DidMgrDynDidStateCheck(pDidInfoContext, ErrorCode);                                                                           /* SBSW_DCM_COMB_PTR_FORWARD */
      if(lStdReturn == DCM_E_OK)
      {
        ++(pRepContext->DidInfoContextIdx); /* next DID */                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdReturn = DCM_E_LOOP; /* proceed with next DID */
      } /* else DCM_E_NOT_OK (ErrorCode already set) */
      break;
    case DCM_E_PENDING:
      /* Try it the next task cycle */
      break;
    default: /* DCM_E_NOT_OK */
      /* Just skip this DID - request a new look-up loop */
      lStdReturn = DCM_E_LOOP;
      break;
  }

  /* If next DID look-up is requested: */
  if(lStdReturn == DCM_E_LOOP)
  {
    /* If all DIDs are validated: */
    if(pMsgContext->reqDataLen == 0u)
    {
      if(pRepContext->NumDids != 0u) /* any DID to process? */
      {
        pRepContext->DidIter           = pRepContext->NumDids;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
        pRepContext->DidInfoContextIdx = 0u;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */

        Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_CHECKCONDITION); /* delegate job */
      }
      else
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdReturn = DCM_E_NOT_OK;
      }
    }
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc22CheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckCondition(Dcm_OpStatusType                   opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType                   lStdResult = DCM_E_OK;
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext), DCM_DIDMGR_OPTYPE_READCHKCOND))
  {
    Dcm_DidMgrInitOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_READCHKCOND);                                                                       /* SBSW_DCM_POINTER_WRITE_DIDINFOCONTEXT */

    /* check conditions */
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,pDidInfoContext
                                        ,&(pRepContext->DidOpTypeContext)
                                        ,ErrorCode);                                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
  }/* else - not supported operation - go on with getLength */

  if(lStdResult == DCM_E_OK)
  {
    /* DCM_E_OK - go on with next DID */
    Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_GETLENGTH); /* next job */
    lStdResult = DCM_E_LOOP;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22GetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22GetLength(Dcm_OpStatusType                     opStatus
                                                                  ,Dcm_MsgContextPtrType                pMsgContext                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                  ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                   lStdReturn = DCM_E_OK;
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext), DCM_DIDMGR_OPTYPE_READLENGTH))
  {
    Dcm_DidMgrInitOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_READLENGTH);                                                                        /* SBSW_DCM_POINTER_WRITE_DIDINFOCONTEXT */

    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,pDidInfoContext
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,ErrorCode);                                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_MsgLenType lMaxLength;

    pRepContext->ActualLength   += 2; /* cumulate DID length + DID itself */                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ActualLength   += pDidInfoContext->DidLength;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

    pRepContext->ReservedLength += 2;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ReservedLength += pDidInfoContext->ReservedLength;                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
    /* Note: Protocol->MaxLength includes the SID, so subtract it */
    lMaxLength = (Dcm_MsgLenType)(Dcm_NetGetProtObjOfTranspObj(Dcm_DiagGetTranspObj())->MaxLength - 1u);
# else
    /* Note: pMsgContext->resMaxDataLen excludes the SID already */
    lMaxLength = pMsgContext->resMaxDataLen;
# endif

    /* Check for buffer overrun */
    if(pRepContext->ReservedLength <= lMaxLength)
    {
      pRepContext->DidIter--;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
      if(pRepContext->DidIter == 0)
      {
        /* All DIDs processed without any errors. Prepare for reading
         * Now pRepContext->NumDids will be used as counter -> didIter not needed anymore!
         * pRepContext->DidIter = pRepContext->NumDids;
         */
        pRepContext->DidInfoContextIdx = 0u;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */

        Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_READDATA); /* delegate job */
      }
      else
      {
        pRepContext->DidInfoContextIdx++; /* next DID */                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */

        Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_CHECKCONDITION); /* start again with next DID  */
      }
      lStdReturn = DCM_E_LOOP; /* speed up processing */
    }
    else
    {
      /* the configured buffer will not be able to hold all of the data -> notify the client */
      *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
  }/* else - DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc22ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadData(Dcm_OpStatusType                     opStatus
                                                                 ,Dcm_MsgContextPtrType                pMsgContext                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                 ,Dcm_NegativeResponseCodePtrType      ErrorCode                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                 ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DebugAssert((pMsgContext->resDataLen == 0), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Start the paged-buffer to copy the DID data */
  Dcm_PagedBufferStart(pRepContext->ActualLength);
  return DCM_E_STOP_REPEATER;
# else
  Std_ReturnType           lStdResult;
  Dcm_DiagDataContextType  lDataContext;

  Dcm_DiagInitDataContext(&lDataContext, Dcm_DiagGetResData(pMsgContext), pMsgContext->resMaxDataLen);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

  lStdResult = Dcm_Svc22UtiReadData(opStatus, &lDataContext, ErrorCode, pRepContext);                                                                /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Commit copied data */
  Dcm_DiagProvideResData(pMsgContext, lDataContext.Usage);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
# endif
}
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc23Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc23RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  uint8          lAlfid;
  uint8          lBlockLength;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* dispatcher guarantees for minimum length of 3 bytes (ALFID + MEM + SIZE) available */
  lStdResult = Dcm_MemMgrValidateAndGetAlfid(pMsgContext, &lAlfid, &lBlockLength, ErrorCode);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  if(lStdResult == DCM_E_OK)
  {
    /* check for exact length match */
    if(pMsgContext->reqDataLen == lBlockLength)
    {
      Dcm_MemMgrParseMemStream(lAlfid
                              ,pMsgContext
                              ,&pRepContext->MemBlock);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

      lStdResult = Dcm_MemMgrCheckMemBlock(&pRepContext->MemBlock, DCM_MEMMGR_OP_READ, ErrorCode);                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(lStdResult == DCM_E_OK)
      {
        /* Check for overflow */
        if(pRepContext->MemBlock.Length <= pMsgContext->resMaxDataLen)
        {
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
          Dcm_RepeaterNextStep(DCM_SVC23_PROGRESS_CHECKACCESS);
# else
          Dcm_RepeaterNextStep(DCM_SVC23_PROGRESS_READMEMORY);
# endif
          lStdResult = DCM_E_LOOP;/* speed up processing */
        }
        else
        {
          *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }/* else DCM_E_NOT_OK - ErrorCode is already set */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }/* else DCM_E_NOT_OK - ErrorCode is already set */

  return lStdResult;
}

# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc23CheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23CheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_Svc23RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_InstanceContext.MemMgr.LockedByClient != DCM_MEMMGR_ACCESS_NONE)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
  {
    Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_REQ_EXT;
    Dcm_RepeaterNextStep(DCM_SVC23_PROGRESS_READMEMORY); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc23ReadMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23ReadMemory(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc23RepeaterProxyContextConstPtrType pRepContext)
{
  Std_ReturnType          lStdResult;
  Dcm_DiagDataContextType lDataContext;

  Dcm_DiagInitDataContext(&lDataContext, Dcm_DiagGetResData(pMsgContext), pMsgContext->resMaxDataLen);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

  lStdResult = Dcm_MemMgrReadMemory(opStatus
                                   ,&(pRepContext->MemBlock)
                                   ,&lDataContext
                                   ,ErrorCode);                                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    Dcm_DiagProvideResData(pMsgContext, pRepContext->MemBlock.Length);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  /*  Otherwise - any other result to be delegated to the core
   *  No DET monitoring needed since the Dcm_MemMgrReadMemory has already one!
   */
  return lStdResult;
}
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc24Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc24RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If valid service request length: */
  if(pMsgContext->reqDataLen == 2u)
  {
    /* Prepare for DID look up */
    Dcm_DiagConsumeReqDataAsU16(pMsgContext, &(pRepContext->DidInfoContext.Did));                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Initialize DID look up */
    Dcm_RepeaterNextStep(DCM_SVC24_PROGRESS_DIDLOOKUP);
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    /* Invalid length detected -> send NRC 0x13 */
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  /* Return control to DCM core */
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc24ExecuteOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24ExecuteOp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc24RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_DidMgrGetScalingInfo(opStatus
                                       ,pMsgContext
                                       ,&(pRepContext->DidInfoContext)
                                       ,&(pRepContext->DidOpTypeContext)
                                       ,ErrorCode);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc24DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24DidLookUp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc24RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->DidInfoContext)
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_SCALINGINFO);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
  if(lStdReturn == DCM_E_OK)
  {
    /*
     * Currently no state checks are possible on scaling DIDs in AR 4.x:
     * lStdReturn = Dcm_DidMgrStaticDidStateCheck(Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext)->ExecCondRef, ErrorCode);
     * if(lStdReturn == DCM_E_OK)
     */
    {
      Dcm_DiagProvideResData(pMsgContext, 2);    /* commit the DID only. The scaling record size will be calculated on the fly */                    /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_GETSCALING);                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_RepeaterNextStep(DCM_SVC24_PROGRESS_EXECUTEOP); /* delegate job */
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }/* else - ErrorCode already assigned */
  }
  else if(lStdReturn == DCM_E_PENDING)
  {
    /* DID verification takes longer -> retry later */
  }
  else
  {
    /* DID is not supported -> send NRC 0x31 */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }

  return lStdReturn; /* finish service processing immediately */
}
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc27SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc27SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc27SubFuncInfoGetEntryOrNull(
                                                                                Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc27SubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC27SUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC27SUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc27SubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_CfgSvc27SecLevelInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc27SecLevelInfoPtrType, DCM_CODE) Dcm_CfgSvc27SecLevelInfoGetEntryOrNull(
                                                                                                   uint8_least secLev)
{
  Dcm_CfgSvc27SecLevelInfoPtrType lSecLevelInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (secLev >= DCM_CFGSVC27SECLEVELINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC27SECLEVELINFOGETENTRY);
    lSecLevelInfo = NULL_PTR;
  }
  else
# endif
  {
    lSecLevelInfo = &Dcm_CfgSvc27SecLevelInfo[secLev];
  }

  return lSecLevelInfo;
}

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27CounterSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterSet(uint8_least secLev, uint8 value)
{
  uint8_least lCounterIdx = Dcm_Svc27GetCounterIdx(secLev);

  DCM_IGNORE_UNREF_PARAM(secLev);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_SVC_27_MULTI_ATTEMPT_COUNTER_ENABLED == STD_ON)
#   if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                            /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (lCounterIdx >= DCM_SVC_27_NUM_ATTEMPT_COUNTERS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_SVC27COUNTERSET);
  }
  else
#   endif
#  endif
  {
    Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[lCounterIdx] = value;                                                                       /* SBSW_DCM_POINTER_WRITE_ATTEMPTCOUNT */
  }
}
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27CounterInc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterInc(uint8_least secLev)
{
  uint8 lValue = Dcm_Svc27CounterGet(secLev);

  if(lValue < Dcm_UtiMaxValueOfUintType(uint8))
  {
    Dcm_Svc27CounterSet(secLev, (uint8)(lValue + 1u));
  }
}
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27TimerSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerSet(uint8_least secLev, Dcm_Svc27TimerType value)
{
  uint8_least lTimerIdx = Dcm_Svc27GetTimerIdx(secLev);

  DCM_IGNORE_UNREF_PARAM(secLev);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_SVC_27_MULTI_DELAY_TIMER_ENABLED == STD_ON)
#   if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                            /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(lTimerIdx >= DCM_SVC_27_NUM_DELAY_TIMERS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_SVC27TIMERSET);
  }
  else
#   endif
#  endif
  {
    /* Enter critical section (Reason: Avoid interrupt from Dcm_OnTimeoutSecurityAccess) */
    Dcm_SplitTaskEnterCS();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/

    Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[lTimerIdx] = value;                                                                            /* SBSW_DCM_POINTER_WRITE_DELAYTIME */

    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_SplitTaskLeaveCS();
  }
}
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27TimerStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerStart(uint8_least secLev, Dcm_Svc27TimerType value)
{
  /* Start the appropriate security timer */
  Dcm_Svc27TimerSet(secLev, value);

  if(!Dcm_TmrIsTimerRunning(DCM_TMR_ID_SECURITY_0))
  {
    /* Start the base security timer */
    Dcm_TmrStartTimer(DCM_TMR_ID_SECURITY_0, 1u);
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc27SubFuncLookUpTable
                                                   ,Dcm_CfgSvc27SubFuncExecPrecondTable
                                                   ,Dcm_Svc27ReqLengthGetter
                                                   ,Dcm_Svc27SubFuncSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Initialize service processor context for further processing */
  pRepContext->ErrorCode = DCM_E_POSITIVERESPONSE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);/* Store working sub-function reference (also in negative response cases) */   /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->SecLvlRef = Dcm_Svc27GetSecLvlRef(lSubSvcRef);                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */

  if(lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(DCM_SVC27_PROGRESS_SUBFUNCTION);
    lStdResult = DCM_E_LOOP; /* Speed up processing */
  }
  else
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
  /* If the requested key has wrong length or the sub-function sequence was not correct (if security retry is enabled): */
  if( (*ErrorCode == DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT)
    ||(*ErrorCode == DCM_E_REQUESTSEQUENCEERROR))
  {
    if( (Dcm_Svc27IsKeyRequest(pRepContext->SubSvcRef) == TRUE) /* wrong length key is an invalid key! */
      &&(Dcm_Svc27IsKeyRequestExpected() == TRUE) )
    {
      Dcm_Svc27CounterInc(pRepContext->SecLvlRef);                                                                                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
      Dcm_RepeaterNextStep(DCM_SVC27_PROGRESS_SETATTEMPTCNTR);
      pRepContext->ErrorCode = *ErrorCode; /* used in next step */                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_LOOP;/* Speed up processing */
#  endif
    }
    /* Send prepared NRC immediately */
  }
  else
# endif
  {
    /* Send prepared NRC immediately */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc27SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27SubFuncHandler(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_CfgSvc27SubFuncInfoPtrType pSubFuncInfo;

  pSubFuncInfo = Dcm_CfgSvc27SubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(opStatus, pMsgContext, ErrorCode);                                                                         /* SBSW_DCM_CALL_FUNCPTR_SVC27SUBFUNC */
  }

  return lStdResult;
}

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiGetAttemptCntr()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27UtiGetAttemptCntr(Dcm_OpStatusType opStatus
                                                                ,P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask)
{
  Std_ReturnType  lResult;
  uint8           lAttemptCount;
  uint8_least     lSecLvlIter = 0u;
  uint32          lMask = *levelMask;

  /* #10 For each security level: */
  DCM_UTI_LOOP_BIT_SCAN(lMask)
  {
    /* #20 If the attempt counter for that specific security level is not already read: */
    if(Dcm_TskIsLocalEventSet(lMask, 0x01u))
    {
      Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;

      pSecLevelInfo = Dcm_CfgSvc27SecLevelInfoGetEntryOrNull(lSecLvlIter);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if (pSecLevelInfo == NULL_PTR)                                                                                                                 /* COV_DCM_RTM_RUNTIME_CHECK XF */
      {
        break;
      }
      else
#  endif
      {
        /* #30 Try to read the attempt counter from the application */
        lResult = pSecLevelInfo->GetAttemptCntrFunc(opStatus, &lAttemptCount);                                                                       /* SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL */

        /* #40 If everything was ok: */
        if(lResult == DCM_E_OK)
        {
          /*
           * Note: Using critical sections is not necessary here because the features "power on delay" and
           *       "external attempt counter storage" are used mutually exclusive per security level.
           */

          /* #50 Mark the security level to prevent that this API is called again */
          Dcm_UtiBitOpClr(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

          /* #60 If the already initialized attempt counter has to be updated: */
          if(lAttemptCount != 0)
          {
            /* #70 Store the attempt counter */
            Dcm_Svc27CounterSet(lSecLvlIter, lAttemptCount);

            /* #80 If the current attempt counter value exceeded the maximum number of allowed attempts: */
            if(lAttemptCount >= Dcm_CfgStateSecurityInfo[lSecLvlIter].NumAttempts)
            {
              /* #90 Set the delay timer value. The timer will be started later with that value */
              Dcm_Svc27TimerSet(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeInvKey);                                                 /* PRQA S 3109 */ /* MD_MSR_14.3 */
            }
          }
        }/* #91 If more time needed: */
        else if (lResult == DCM_E_PENDING)
        {
          /* #92 Try it later */
        }
        else /* #100 If something went wrong: */
        {
          Dcm_DebugApiCheckRte((lResult == DCM_E_NOT_OK), DCM_SID_GETSECURITYATTEMPTCOUNTER, DCM_E_INTERFACE_RETURN_VALUE)

          /* #110 Mark the security level to prevent that this API is called again */
          Dcm_UtiBitOpClr(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

          /* #120 Reset the attempt counter */
          Dcm_Svc27CounterReset(lSecLvlIter);

#  if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
          /* #130 If delay time on failed read of attempt counter is enabled: */
          if(Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadOnZeroDelay == TRUE)
          {
            /* #140 If the configured delay time is zero: */
            if(Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadTime == 0u)
            {
              /* #150 Set the delay timer value to infinity */
              Dcm_Svc27ReloadReadFailedSet(lSecLvlIter);
              Dcm_Svc27TimerSet(lSecLvlIter, 1u);                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
            }
            else
            {
              /* #160 Otherwise set the configured delay timer value */
              Dcm_Svc27TimerSet(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadTime);                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
            }
          }
#  endif
        }
      }
    }
    ++lSecLvlIter;
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27ReadAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_Svc27ReadAttemptCounter(Dcm_TskTaskEvOptType ev
                                                                                 ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  /* #10 Restore the attempt counter values from the application */
  Dcm_Svc27UtiGetAttemptCntr(Dcm_InstanceContext.Diag.Services.Svc27.GetAttOpStatus
                            ,&Dcm_InstanceContext.Diag.Services.Svc27.GetAttCntrEventMask);                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* #20 If all attempt counters were read */
  if(Dcm_InstanceContext.Diag.Services.Svc27.GetAttCntrEventMask == 0u)
  {
    uint8_least lTmrIter;

    for(lTmrIter = 0; lTmrIter < DCM_SVC_27_NUM_DELAY_TIMERS; ++lTmrIter)
    {
      /* #30 If the corresponding security timer value is not zero: */
      if(Dcm_Svc27TimerGet(lTmrIter) != 0u)
      {
        /* #40 Start the base timer which starts the appropriate security timers */
        Dcm_TmrStartTimer(DCM_TMR_ID_SECURITY_0, 1u);
        break;
      }
    }
    /* Reset operation status */
    Dcm_InstanceContext.Diag.Services.Svc27.GetAttOpStatus = DCM_INITIAL;
  }
  else
  {
    /* #50 Otherwise resume the job next task cycle */
    Dcm_TskSetLocalEvent(*pPostEv, ev);                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_InstanceContext.Diag.Services.Svc27.GetAttOpStatus = DCM_PENDING;
  }

  return lResultEv;
}
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27WriteAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_Svc27WriteAttemptCounter(Dcm_TskTaskEvOptType ev
                                                                                  ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  /* #10 Notify the application about changed attempt counters */
  Dcm_Svc27UtiSetAttemptCntr(Dcm_InstanceContext.Diag.Services.Svc27.SetAttOpStatus
                            ,&Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask);                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* #20 If all attempt counters were written: */
  if(Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask == 0u)
  {
    /* #30 Finish the job and reset the opStatus for next write cycle */
    Dcm_InstanceContext.Diag.Services.Svc27.SetAttOpStatus = DCM_INITIAL;
  }
  else
  {
    /* #40 Otherwise resume the job next task cycle and notify application for the subsequent call via opStatus parameter */
    Dcm_TskSetLocalEvent(*pPostEv, ev);                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_InstanceContext.Diag.Services.Svc27.SetAttOpStatus = DCM_PENDING;
  }

  return lResultEv;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Service27SeedRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SeedRepeater(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lResult;
  Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;

  pSecLevelInfo = Dcm_CfgSvc27SecLevelInfoGetEntryOrNull(pRepContext->SecLvlRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pSecLevelInfo == NULL_PTR)                                                                                                                    /* PRQA S 3415 */ /* MD_Dcm_3415 */
    ||(Dcm_DiagMsgContextVerifySize(pMsgContext, pSecLevelInfo->SeedResLength) == FALSE) )                                                           /* COV_DCM_RTM_RUNTIME_CHECK XF xf xf */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    /* Read the seed of the appropriate security level */
    switch(pSecLevelInfo->GetSeedFuncClass)
    {
    case DCM_SVC27_OPCLS_SEED_WITHOUT_ADR:
      lResult = ((Dcm_Svc27OpFuncSeedWoAdr)pSecLevelInfo->GetSeedFunc)(opStatus                                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                      ,Dcm_DiagGetResData(pMsgContext)                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                      ,ErrorCode);                                                                   /* SBSW_DCM_CALL_FUNCPTR_SVC27GETSEED */
      break;
    case DCM_SVC27_OPCLS_SEED_WITH_ADR:
      lResult = ((Dcm_Svc27OpFuncSeedWAdr)pSecLevelInfo->GetSeedFunc)(Dcm_DiagGetReqData(pMsgContext)                                                /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                     ,opStatus
                                                                     ,Dcm_DiagGetResData(pMsgContext)                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                     ,ErrorCode);                                                                    /* SBSW_DCM_CALL_FUNCPTR_SVC27GETSEED */
      break;
    default:                                                                                                                                         /* COV_DCM_RTM_UNREACHABLE X */
      DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */

      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = DCM_E_NOT_OK;
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }

    switch(lResult)
    {
      case DCM_E_OK:
        /* Send response */
        Dcm_DiagProvideResData(pMsgContext, pSecLevelInfo->SeedResLength);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
        break;
      case DCM_E_PENDING:
        /* Retry later */
        break;
      case DCM_E_NOT_OK:
        Dcm_DiagHandleApplNrc(lResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
        break;
      default:
        Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_NOT_OK;
        break;
    }
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Service27KeyRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27KeyRepeater(Dcm_OpStatusType opStatus
                                                                     ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType                  lResult;
  Dcm_NegativeResponseCodeType    lNrc = DCM_E_POSITIVERESPONSE;
  Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;

  pSecLevelInfo = Dcm_CfgSvc27SecLevelInfoGetEntryOrNull(pRepContext->SecLvlRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSecLevelInfo == NULL_PTR)                                                                                                                     /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    /* Let the application compare the given key data */
    lResult = pSecLevelInfo->CompareKeyFunc(Dcm_DiagGetReqData(pMsgContext)                                                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                           ,opStatus
# if (DCM_DCM_AR_VERSION != DCM_DCM_AR_VERSION_403)
                                           ,&lNrc
# endif
                                           );                                                                                                        /* SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL */

    switch(lResult)
    {
      /*---------------------------*/
      case DCM_E_OK:
      /*---------------------------*/
        /* Reset the attempt counter of this security level */
        Dcm_Svc27CounterReset(pRepContext->SecLvlRef);

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
        /* Notify application about new attempt counter */
        Dcm_RepeaterNextStep(DCM_SVC27_PROGRESS_SETATTEMPTCNTR);
        lResult = DCM_E_LOOP;
# endif
        break;
      /*---------------------------*/
      case DCM_E_PENDING:
      /*---------------------------*/
        /* Try later */
        break;
      /*---------------------------*/
      case DCM_E_NOT_OK:
      /*---------------------------*/
        /* If an error occurred set the NRC given by the application */
# if (DCM_DCM_AR_VERSION != DCM_DCM_AR_VERSION_403)
        Dcm_DiagHandleApplNrc(lResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */
# endif
        /* fall through */
      case DCM_E_COMPARE_KEY_FAILED:                                                                                                                 /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
        /* Increment the attempt counter */
        Dcm_Svc27CounterInc(pRepContext->SecLvlRef);                                                                                                 /* PRQA S 3109 */ /* MD_MSR_14.3 */

        /* Notify application about new attempt counter */
        Dcm_RepeaterNextStep(DCM_SVC27_PROGRESS_CHECKATTEMPTSEXCEEDED);
        pRepContext->ErrorCode = lNrc; /* will be used in next step */                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_LOOP;
# else
        /* This NRC will be ignored if compare key function returned DCM_E_NOT_OK and therefore a NRC was already set */
#  if (DCM_DCM_AR_VERSION != DCM_DCM_AR_VERSION_403)
        if (lNrc == DCM_E_POSITIVERESPONSE)
#  endif
        {
          lNrc = DCM_E_INVALIDKEY;
        }
        *ErrorCode = lNrc;                                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_NOT_OK;
# endif
        break;
      /*---------------------------*/
      default:
      /*---------------------------*/
        Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_NOT_OK;
        break;
    }
  }

  return lResult;
}

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27CheckAttemptsExceededRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27CheckAttemptsExceededRepeater(Dcm_OpStatusType opStatus
                                                                     ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType  lResult;
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  uint32          lMask = Dcm_UtiGetBitFromIndex(uint32, pRepContext->SecLvlRef);
#  endif

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  /* #10 Notify the application about the new attempt counter value */
  Dcm_Svc27UtiSetAttemptCntr(opStatus, &lMask);                                                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

  /* #20 If the setting of the attempt counter was not successful: */
  if(lMask != 0)
  {
    /* #30 Try it later */
    lResult = DCM_E_PENDING;
  }
  else /* #40 Otherwise: */
#  endif
  {
    /* #50 If the number of allowed attempt were exceeded: */
    if( (Dcm_CfgStateSecurityInfo[pRepContext->SecLvlRef].NumAttempts != 0) /* Consider only levels with attempt monitoring */
      && (Dcm_Svc27CounterGet(pRepContext->SecLvlRef) >= Dcm_CfgStateSecurityInfo[pRepContext->SecLvlRef].NumAttempts))
    {
      /* #60 Set NRC 0x36 if not already set and start the timer */
      /* This NRC will be ignored if ErrorCode is already set due to failed compare key function */
      *ErrorCode = DCM_E_EXCEEDNUMBEROFATTEMPTS;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */

      Dcm_Svc27TimerStart(pRepContext->SecLvlRef, Dcm_CfgStateSecurityInfo[pRepContext->SecLvlRef].DelayTimeInvKey);
    }
    else
    {
      /* #70 Otherwise set NRC 0x35 if not already set */
      /* This NRC will be ignored if ErrorCode is already set due to failed compare key function */
      *ErrorCode = DCM_E_INVALIDKEY;                                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    if (pRepContext->ErrorCode != DCM_E_POSITIVERESPONSE)
    {
      /* Use previously set ErrorCode if available */
      *ErrorCode = pRepContext->ErrorCode;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    lResult = DCM_E_NOT_OK;
  }

  return lResult;
}
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SetAttemptCntrRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SetAttemptCntrRepeater(Dcm_OpStatusType opStatus
                                                                     ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType  lResult;
  uint32          lMask = Dcm_UtiGetBitFromIndex(uint32, pRepContext->SecLvlRef);

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Notify the application about the new attempt counter value */
  Dcm_Svc27UtiSetAttemptCntr(opStatus, &lMask);                                                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

  /* If the setting of the attempt counter was successful: */
  if(lMask == 0)
  {
    /* Finish the job */
    if (pRepContext->ErrorCode == DCM_E_POSITIVERESPONSE)
    {
      lResult = DCM_E_OK;
    }
    else
    {
      *ErrorCode = pRepContext->ErrorCode;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = DCM_E_NOT_OK;
    }
  }
  else
  {
    /* Otherwise try it later */
    lResult = DCM_E_PENDING;
  }

  return lResult;
}
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc28SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc28SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc28SubFuncInfoGetEntryOrNull(
                                                                                Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc28SubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC28SUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC28SUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc28SubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc28Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc28Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc28RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Prepare all generic part (independently of the SF validation result!) */
# if (DCM_SVC_28_USER_ENABLED == STD_ON)
  pRepContext->IsInternallyProcessed = FALSE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
# endif
  pRepContext->SubServiceId = Dcm_DiagGetReqDataAsU8(pMsgContext);                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc28SubFuncLookUpTable
                                                   ,Dcm_CfgSvc28SubFuncExecPrecondTable
                                                   ,Dcm_Svc28ReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

  if (lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(DCM_SVC28_PROGRESS_SUBFUNCTION); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc28SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc28SubFuncHandler(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc28RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_CfgSvc28SubFuncInfoPtrType pSubFuncInfo;

  pSubFuncInfo = Dcm_CfgSvc28SubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(opStatus, pMsgContext, ErrorCode);                                                                         /* SBSW_DCM_CALL_FUNCPTR_SVC28SUBFUNC */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc28ApplyCommControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc28ApplyCommControl(Dcm_CfgNetNetIdRefMemType networkRef
                                                               ,Dcm_CommunicationModeType mode)
{
  DCM_IGNORE_UNREF_PARAM(networkRef);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if ((DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_28_SUBNET_SUPPORT_ENABLED == STD_ON) ) && \
     (DCM_NET_COMCTRL_ALLNET_SUPPORT_ENABLED == STD_ON)                                                                                              /* COV_DCM_SUPPORT_PARTIALLY TF tf xf tf */
  if(networkRef == DCM_SVC_28_NETWORK_ALL)
# endif
  {
# if (DCM_NET_COMCTRL_ALLNET_SUPPORT_ENABLED == STD_ON)
    uint8_least lChannelIter;

    for(lChannelIter = Dcm_PbCfgNetComCtrlChannelListAll[0]; lChannelIter != 0; --lChannelIter)
    {
      Dcm_ModeSwitchCommControl(Dcm_PbCfgNetComCtrlChannelListAll[lChannelIter], mode);
    }
# endif
  }
# if ((DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_28_SUBNET_SUPPORT_ENABLED == STD_ON) ) && \
     (DCM_NET_COMCTRL_ALLNET_SUPPORT_ENABLED == STD_ON)                                                                                              /* COV_DCM_SUPPORT_PARTIALLY TF tf xf tf */
  else
# endif
  {
# if (DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_28_SUBNET_SUPPORT_ENABLED == STD_ON)                                                                                                   /* COV_DCM_SUPPORT_PARTIALLY TF tf xf */
    Dcm_ModeSwitchCommControl(networkRef, mode);
# endif
  }
}
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdNextEntryIdxInc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdNextEntryIdxInc(void)
{
  ++Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex;
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex >= DCM_SVC_2A_SCHEDULER_SIZE)
  {
    /* Write always zero (also when only one scheduler element exists, to keep the safe aspect when the wrap-around is
     * detected */
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex = 0u;
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2ASchdEntryPtrType, DCM_CODE) Dcm_Svc2ASchdGetEntry(
                                                                             Dcm_Svc2ASchdItemHandleOptType schdHandle)
{
  Dcm_Svc2ASchdEntryPtrType pSchdEntry;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (schdHandle >= DCM_SVC_2A_SCHEDULER_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_SVC2ASCHDGETENTRY);
    pSchdEntry = &Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[0];
  }
  else
# endif
  {
    pSchdEntry = &Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdHandle];
  }
  return pSchdEntry;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdUpdateTimers()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdUpdateTimers(void)
{
  boolean doActivateProcessorTask = FALSE;
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  Dcm_Svc2ASchedRateOptType lFastestRate = DCM_SVC2A_RATE_TYPE_SLOW;
# endif

  for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
  {
    Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);

    if(pSchdEntry->Timer != 0u)
    {
      --(pSchdEntry->Timer);                                                                                                                         /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
      if(pSchdEntry->Timer == 0u)
      {
        if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED) /* is it scheduled ? */
        {
          doActivateProcessorTask = TRUE;
        }
      }
    }
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
    if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED) /* is it scheduled ? */
    {
      if (pSchdEntry->Rate > lFastestRate)
      {
        lFastestRate = pSchdEntry->Rate;
      }
    }
# endif
  }
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  Dcm_NetPeriodicMsgSetFastestRate(lFastestRate);
# endif
  return doActivateProcessorTask;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFindFreeOrInUseItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdFindFreeOrInUseItemByDid(uint16 did
                                               ,P2VAR(Dcm_Svc2ASchdItemHandleOptType, AUTOMATIC, AUTOMATIC) schdHandle)
{
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;
  boolean lSlotFound = FALSE;

  for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
  {
    Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);

    if(pSchdEntry->Rate == DCM_SVC2A_RATE_TYPE_STOPPED)
    {
      if(lSlotFound == FALSE)
      {
        *schdHandle = lSchdIter; /* reserve first found free slot */                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
        lSlotFound = TRUE;
      }/* else - already set */
    }
    else if(did == pSchdEntry->DidContext.Did)
    {
      *schdHandle = lSchdIter; /* found already in used or just reserved DID -> use the same slot */                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      lSlotFound = TRUE;
      break;
    }
    else
    {
      /* do nothing */
    }
  }
  return lSlotFound;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdInitDidMgrResources()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdInitDidMgrResources(Dcm_DiagDataContextPtrType pDataContext
                                                                                ,uint16 did)
{
  Std_ReturnType lStdResult = DCM_E_OK;

  if(Dcm_DidMgrDidLock(did, DCM_DIDMGR_DIDLOCK_OWNER_READPERIODIC) == DCM_E_OK)
  {
    /* prepare first time reading */
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.OpStatus = DCM_INITIAL;
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.WriteIndex = 0u;
    Dcm_DiagProvideDataAsU8(pDataContext, Dcm_UtiGetLoByte(did));                                                                                    /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
  }
  else
  {
    lStdResult = DCM_E_PENDING;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdProcessEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdProcessEntry(Dcm_Svc2ASchdEntryPtrType pSchedTableEntry)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  boolean doSendData = FALSE;

  /* allocate buffer for response data */
  /* still nothing reserved for this DID? */
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle == DCM_NET_INVALID_PTXOBJ_HANDLE)
  {
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle = Dcm_NetPeriodicMsgAllocate(pSchedTableEntry->DidContext.Did);
    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle == DCM_NET_INVALID_PTXOBJ_HANDLE)
    {
      /* no free message buffer try again later */
      lStdResult = DCM_E_PENDING; /* exit loop and task */
    }
  }

  if(lStdResult == DCM_E_OK)
  {
    Dcm_DiagDataContextType lDataContext;

    /* Init data context */
    Dcm_DiagInitDataContext(&lDataContext
                           ,Dcm_NetPeriodicMsgGetTxBuffer(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle)
                           ,(Dcm_MsgLenType)(DCM_NET_PERIODIC_BUFFER_SIZE));                                                                         /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

    /* Allocate DID manager resource */
    if(Dcm_DidMgrDidHasLock(DCM_DIDMGR_DIDLOCK_OWNER_READPERIODIC) == FALSE)
    {
      lStdResult = Dcm_Svc2ASchdInitDidMgrResources(&lDataContext, pSchedTableEntry->DidContext.Did);                                                /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
    }

    if(lStdResult == DCM_E_OK)
    {
      Dcm_NegativeResponseCodeType lNrc; /* unused since no NR possible */

      /* Write index is initialized in Dcm_Svc2ASchdInitDidMgrResources and thus always valid */
      Dcm_DiagCommitData(&lDataContext, Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.WriteIndex);                                               /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

      /* read the response data */
      lStdResult = Dcm_DidMgrReadDid(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.OpStatus
                                    ,&lDataContext
                                    ,&(pSchedTableEntry->DidContext)
                                    ,&(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidOpTypeContext)
                                    ,&lNrc);                                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

      Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.WriteIndex = (Dcm_CfgNetBufferSizeMemType)lDataContext.Usage;

      switch(lStdResult)
      {
      case DCM_E_OK:
        doSendData = TRUE; /* now the response can be sent */
        break;
      case DCM_E_PENDING:
        Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.OpStatus = DCM_PENDING; /* prepare for next call */
        break;
      case DCM_E_NOT_OK:
        /* something went wrong - skip this DID */
        break;
      default:                                                                                                                                       /* COV_DCM_RTM_UNREACHABLE X */
        lStdResult = DCM_E_NOT_OK;
        Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                 /* COV_DCM_RTM_DEV_DEBUG XF */
        break;
      }

      if(lStdResult != DCM_E_PENDING)
      {
        /* reload the period timer from now on (see ISO14229-1 SID 0x2A scheduler example) */
        /*
         * No critical section for split tasks needed since:
         * - The timer that just has been processed is already stopped and will not be decrement in the
         *   Dcm_Svc2ASchdUpdateTimers utility.
         * - This tasks is a low-priority one and cannot interrupt the timer task (Dcm_OnTimeoutSvc2AScheduler). So
         *   setting a non-zero value will not be an issue.
         */
        pSchedTableEntry->Timer = Dcm_Svc2AGetSchedulingTimeOfEntry(pSchedTableEntry);                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

        /* Finish scheduled job */
        Dcm_Svc2ASchdFinishEntryProcessing(doSendData);
      }
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
/**********************************************************************************************************************
 *  Dcm_Service2ASchedulerInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service2ASchedulerInit(void)
{
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries = 0u;
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex = 0u;
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle = DCM_NET_INVALID_PTXOBJ_HANDLE;

  {
    Dcm_Svc2ASchdItemHandleOptType lSchdIter;

    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);
      pSchdEntry->Timer = 0u;                                                                                                                        /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
      pSchdEntry->Rate = DCM_SVC2A_RATE_TYPE_STOPPED;                                                                                                /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdAddItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdAddItemByDid(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext)                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_Svc2ASchdItemHandleOptType lSchdHandle;
  Dcm_Svc2ASchdEntryPtrType pSchdEntry;

  if (Dcm_Svc2ASchdFindFreeOrInUseItemByDid(pDidInfoContext->Did, &lSchdHandle) == TRUE)                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    pSchdEntry = Dcm_Svc2ASchdGetEntry((Dcm_Svc2ASchdItemHandleOptType)lSchdHandle);
    Dcm_UtiAssignStruct(pSchdEntry->DidContext ,*pDidInfoContext);                                                                                   /* PRQA S 0310, 3109 */ /* MD_Dcm_GenericStructAssign_0310, MD_MSR_14.3 */ /* SBSW_DCM_POINTER_WRITE_UTI_STRUCT */
    pSchdEntry->Rate |= DCM_SVC2A_RATE_TYPE_RESERVED;                                                                                                /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
  }
  else
  {
    /* there shall always be free space when this function is called, otherwise check the SID 0x2A processor */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCommit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdCommit(Dcm_Svc2ASchedRateMemType rate)
{
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;

  Dcm_SplitTaskEnterCS();/* protect against timer task update */                                                                                     /* PRQA S 3109 */ /* MD_MSR_14.3 */

  for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
  {
    Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);
    if((pSchdEntry->Rate & DCM_SVC2A_RATE_TYPE_RESERVED) != 0)
    {
      if((pSchdEntry->Rate & DCM_SVC2A_RATE_TYPE_STOPPED) != 0)
      {
        /* update statistic of first activation of this DID */
        ++Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries;
      }
      /* must not exceed the scheduler size */
      Dcm_DebugAssert((Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries <= DCM_SVC_2A_SCHEDULER_SIZE)
                     ,DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                         /* COV_DCM_RTM_DEV_DEBUG XF */
      pSchdEntry->Rate = rate; /* set the new rate */                                                                                                /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
      pSchdEntry->Timer = 0u; /* enforce immediate timeout */                                                                                        /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
    }
  }
  Dcm_SplitTaskLeaveCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
    Dcm_TmrStartTimer(DCM_TMR_ID_SVC2A_SCHEDULER, 1u);/* start timer updater */
# endif
    /* start updating the timers/processing new DIDs */
    Dcm_TskSetEvent(DCM_TSK_ID_SVC2A_SCHEDULER
                  ,(Dcm_TskTaskEvMemType)(DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD|DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS));
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdDiscard()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdDiscard(void)
{
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;

  for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
  {
    Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);
    Dcm_UtiBitOpClr(Dcm_Svc2ASchedRateMemType, pSchdEntry->Rate, DCM_SVC2A_RATE_TYPE_RESERVED);                                                      /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */ /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
  }
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AStoppedDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStoppedDidLookUp(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_Svc2ADidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_Svc2ASchdStopItemByDid(pRepContext->DidInfoContext.Did);
    lStdReturn = DCM_E_LOOP;/* go on with the next DID  */
  }
  else if (lStdReturn == DCM_E_PROCESSINGDONE)
  {
    lStdReturn = DCM_E_OK;
  }
  else
  {
    /* DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set), DCM_E_LOOP */
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AScheduledDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AScheduledDidLookUp(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_Svc2ADidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdReturn == DCM_E_OK)
  {
    lStdReturn = Dcm_DidMgrDynDidStateCheck(&(pRepContext->DidInfoContext), ErrorCode);                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
    if (lStdReturn == DCM_E_OK)
    {
      /* Proceed with next validation step */
      Dcm_RepeaterNextStep(DCM_SVC2A_PROGRESS_DID_CHECKCONDITION); /* next job */
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    } /* else DCM_E_NOT_OK (ErrorCode already set) */
  }
  else if (lStdReturn == DCM_E_PROCESSINGDONE)
  {
    lStdReturn = DCM_E_OK;
  }
  else
  {
    /* DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set), DCM_E_LOOP */
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ADidCheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidCheckCondition(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult = DCM_E_LOOP;

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext))
                                ,DCM_DIDMGR_OPTYPE_READCHKCOND))
  {
    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */

    /* check condition on this DID */
    Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READCHKCOND);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,&(pRepContext->DidInfoContext)
                                        ,&(pRepContext->DidOpTypeContext)
                                        ,ErrorCode);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

    switch(lStdResult)
    {
    case DCM_E_OK:
      lStdResult = DCM_E_LOOP;
      break; /* go on with next DID */
    case DCM_E_PENDING:
      break;
    default: /* DCM_E_NOT_OK */
      break; /* finish service processing immediately */
    }
  }/* else - not supported operation - go on with getLength */

  if(lStdResult == DCM_E_LOOP)
  {
    Dcm_RepeaterNextStep(DCM_SVC2A_PROGRESS_DID_GETLENGTH);
  }
  return lStdResult; /* speed up processing */
}

/**********************************************************************************************************************
 *  Dcm_Svc2ADidGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidGetLength(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext))
                                ,DCM_DIDMGR_OPTYPE_READLENGTH))
  {
    Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READLENGTH);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Calculate DID data length if applicable */
    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,&(pRepContext->DidInfoContext)
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,ErrorCode);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(lStdReturn == DCM_E_OK)
  {
    /* check for buffer overrun - uudt frame needs to be large enough for the periodic message (1 Byte DID + data) */
    if (pRepContext->DidInfoContext.DidLength >= Dcm_PbCfgNetConnectionInfo[pRepContext->ConnId].UudtFrameSize)
    {
      /* the configured buffer will not be able to hold all of the data -> notify the client */
      *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
    else
    {
      /* Add scheduler job - set the operation now since not changed later */
      Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READ);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_Svc2ASchdAddItemByDid(&pRepContext->DidInfoContext);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_RepeaterNextStep(DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP);
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }
  }/* else - DCM_E_PENDING, DCM_E_NOT_OK */

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AStopScheduledDids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStopScheduledDids(Dcm_MsgContextPtrType pMsgContext)                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn = DCM_E_OK;
  if(pMsgContext->reqDataLen == 0u)
  {
    Dcm_Svc2ASchdStopAll();
  }
  else
  {
    Dcm_RepeaterNextStep(DCM_SVC2A_PROGRESS_STOPPED_DID_LOOKUP); /* delegate job */
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ADoScheduleDids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADoScheduleDids(Dcm_MsgContextPtrType pMsgContext                                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                       ,Dcm_NegativeResponseCodePtrType ErrorCode)                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;

  if(pMsgContext->reqDataLen > Dcm_Svc2ASchdGetFreeSpace())
  {
  /*
   * not enough space in the scheduler table
   * (don't consider duplicates and unsupported DIDs in the request -> apply KISS) */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    Dcm_RepeaterNextStep(DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP); /* delegate job */
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }

  /* Reaching this point means diagnostic error was found */
  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pRepContext->ConnId = Dcm_DiagGetTranspObj()->ConnId;                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */

# if(DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  /* protected by the session connection ownership */
# else
  if( (Dcm_NetPeriodicMsgGetConnection() != DCM_NET_INVALID_CONNID)
    &&(Dcm_NetPeriodicMsgGetConnection() != pRepContext->ConnId) )
  {
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT; /* the 2A service is currently in use by another client */                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  if (!Dcm_NetPeriodicMsgSupportedFor(Dcm_DiagGetTranspObj()->ConnId))
  {
    *ErrorCode = DCM_E_PANIC_NRC; /* current client does not support periodic messages */                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
    pRepContext->HasAnySupportedDids = FALSE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &(pRepContext->UdsRate));                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Maximum number of DIDs per single request service shall not be exceeded.
     * Check minimum length for rates excluding stopSending */
    if( (pMsgContext->reqDataLen > DCM_SVC_2A_MAX_DID_LIST_LEN)
      ||((pMsgContext->reqDataLen == 0) && (pRepContext->UdsRate != DCM_SVC_2A_STOP_SENDING)) )
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
    {
      if(!Dcm_Svc2AIsUdsRateSupported(pRepContext->UdsRate))
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdReturn = DCM_E_NOT_OK;
      }
      else
      {
        if (pRepContext->UdsRate == DCM_SVC_2A_STOP_SENDING)
        {
          lStdReturn = Dcm_Svc2AStopScheduledDids(pMsgContext);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
        else
        {
          lStdReturn = Dcm_Svc2ADoScheduleDids(pMsgContext, ErrorCode);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }
    }
  }

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrInit(void)
{
  Dcm_CfgDidMgrDynDidHandleOptType dynDidIter;

  for(dynDidIter = 0; dynDidIter < DCM_NUM_DYNDIDS; ++dynDidIter)
  {
    Dcm_Svc2CDynDidItemPtrType pItem;

    pItem = Dcm_Svc2CGetItem(dynDidIter);
    pItem->Length = 0u;                                                                                                                              /* SBSW_DCM_POINTER_WRITE_2CITEM */
    pItem->Count  = 0u;                                                                                                                              /* SBSW_DCM_POINTER_WRITE_2CITEM */
  }

  Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = DCM_SVC2C_INVALID_DYNDID_HDL;
}

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01DefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01DefMgrRead(Dcm_OpStatusType opStatus
                                                                     ,Dcm_DiagDataContextPtrType pDataContext)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext;
  Dcm_Svc2CSrcDidItemInfoPtrType pDidInfo;

  pProcessContext = Dcm_Svc2CGetDDDidProcessContext(DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED);
  pDidInfo = &(Dcm_Svc2CGetSrcItem(pProcessContext->ItemInProgress)->DidDescriptor);

  if(Dcm_DidMgrDidHasLock(DCM_DIDMGR_DIDLOCK_OWNER_READDYNAMIC) == FALSE)
  {
    if(opStatus == DCM_CANCEL)
    {
      /*
       * we have waited for too long to get access to the DID reader, but it was canceled -> Stop here since no reading
       * has been started yet
       */
      lStdResult = DCM_E_NOT_OK;
    }
    else
    {
      /* Check for access rights (avoids race conditions) */
      lStdResult = Dcm_DidMgrDidLock(pDidInfo->DidContext.Did, DCM_DIDMGR_DIDLOCK_OWNER_READDYNAMIC);

      if(lStdResult == DCM_E_OK)
      {
        Dcm_InstanceContext.Diag.Services.Svc2C.ReadIndex = 0;
      }
    }
  }

  if(lStdResult == DCM_E_OK)
  {
    Dcm_NegativeResponseCodeType lNrc;
    Dcm_DiagDataContextType lDataContext;

    Dcm_DidMgrInitOpClassInfo(&(pDidInfo->DidContext)
                             ,DCM_DIDMGR_OPTYPE_READ);                                                                                               /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */

    /* Init data context for asynchronous DIDs only initialy (not in pending status) */
    Dcm_DiagInitDataContext(&lDataContext                                                                                                            /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
                           ,Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer
                           ,DCM_SVC_2C_READ_BUFFER_SIZE);

    Dcm_DiagCommitData(&lDataContext, Dcm_InstanceContext.Diag.Services.Svc2C.ReadIndex);                                                            /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

    lStdResult = Dcm_DidMgrReadDid(opStatus
                                  ,&lDataContext                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
                                  ,&(pDidInfo->DidContext)                                                                                           /* SBSW_DCM_POINTER_WRITE_2CITEM */
                                  ,&(pProcessContext->DidOpTypeContext)                                                                              /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
                                  ,&lNrc);                                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */

    Dcm_InstanceContext.Diag.Services.Svc2C.ReadIndex = lDataContext.Usage;

    /* Finished processing a DIDSrcItem */
    if(lStdResult != DCM_E_PENDING)
    {
      if(lStdResult == DCM_E_OK)
      {
        Dcm_DiagProvideDataAsUN(pDataContext, &lDataContext.Buffer[pDidInfo->Offset], pDidInfo->Size);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      Dcm_DidMgrDidRelease(DCM_DIDMGR_DIDLOCK_OWNER_READDYNAMIC);
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02DefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02DefMgrRead(Dcm_OpStatusType opStatus
                                                                     ,Dcm_DiagDataContextPtrType pDataContext)
{
  Std_ReturnType lStdResult;
  Dcm_OpStatusType lOpStatus = opStatus;

#  if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  lStdResult = DCM_E_OK;

  if(Dcm_InstanceContext.MemMgr.LockedByClient == DCM_MEMMGR_ACCESS_REQ_INT)
  {
    /* Proceed with reading */
  }
  else
  {
    /* Still in process getting access! */
    if(lOpStatus == DCM_CANCEL)
    {
      lStdResult = DCM_E_NOT_OK; /* we have waited for too long to get access to the memory reader, but it was canceled -> Stop here since no reading has been started yet */
    }
    else
    {
      if(Dcm_InstanceContext.MemMgr.LockedByClient == DCM_MEMMGR_ACCESS_NONE)
      {
        Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_REQ_INT;
        lOpStatus = DCM_INITIAL; /* prepare for first reading */
      }
      else /* DCM_MEMMGR_ACCESS_REQ_EXT */
      {
        lStdResult = DCM_E_PENDING;
      }
    }
  }

  if(lStdResult == DCM_E_OK)
#  endif
  {
    Dcm_NegativeResponseCodeType lNrc;
    Dcm_CfgDidMgrDynDidSrcItemIdxMemType lItemInProgress;

    lItemInProgress = Dcm_Svc2CGetDDDidProcessContext(DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED)->ItemInProgress;
    lStdResult = Dcm_MemMgrReadMemory(lOpStatus
                                    ,&(Dcm_Svc2CGetSrcItem(lItemInProgress)->MemDescriptor.MemBlock)
                                    ,pDataContext
                                    ,&lNrc);                                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadSrcItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadSrcItems(Dcm_OpStatusType opStatus
                                                                           ,Dcm_DiagDataContextPtrType pDataContext)
{
  Std_ReturnType lStdReturn = DCM_E_OK;
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext;
  Dcm_OpStatusType lOpStatus = opStatus;

  pProcessContext = Dcm_Svc2CGetDDDidProcessContext(DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED);

  for(; pProcessContext->ItemInProgress < pProcessContext->ItemToStop; pProcessContext->ItemInProgress++)                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  {
    if(Dcm_Svc2CIsDidSrcItem(pProcessContext->ItemInProgress))
    {
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
      lStdReturn = Dcm_Svc2C01DefMgrRead(lOpStatus, pDataContext);                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
# endif
    }
    else
    {
# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
      lStdReturn = Dcm_Svc2C02DefMgrRead(lOpStatus, pDataContext);                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
# endif
    }

    if(lStdReturn == DCM_E_OK)
    {
      /* prepare for next item */
      lOpStatus = DCM_INITIAL;
    }
    else
    {
      break;
    }
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadCheckAccessAndInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadCheckAccessAndInit(
                                                               Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                              ,P2VAR(Dcm_OpStatusType, AUTOMATIC, AUTOMATIC) pOpStatus)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(dynDidHandle);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /*-----------------------------------------------*
   * DynDID usage check and initialization
   *-----------------------------------------------*/
  if(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse == DCM_SVC2C_INVALID_DYNDID_HDL)
  {
    if(*pOpStatus == DCM_CANCEL)
    {
      lStdResult = DCM_E_NOT_OK; /* we have waited for too long to get access to the DynDID reader, but it was canceled -> Stop here since no reading has been started yet */
    }
    else
    {
      /*
       * Reset opStatus in case some DCM_E_PENDING had to be returned due to concurrent access (i.e. 0x22 and 0x2A for
       * different DDDIDs)
       */
      *pOpStatus = DCM_INITIAL;                                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
# if (DCM_SVC_2C_RACE_CONDITION_READ_ENABLED == STD_ON)
  else
  {
    if(dynDidHandle != Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse)
    {
      lStdResult = DCM_E_PENDING;
    } /* else - same handle -> process it */
  }
# endif
  return lStdResult;
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc2CSubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc2CSubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc2CSubFuncInfoGetEntryOrNull(
                                                                                Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc2CSubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC2CSUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC2CSUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc2CSubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DiagSubServiceRefOptType lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc2CSubFuncLookUpTable
                                                   ,Dcm_CfgSvc2CSubFuncExecPrecondTable
                                                   ,Dcm_Svc2CReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Perform SID specific checks */
    if (Dcm_CfgSvc2CSubFuncInfo[(pRepContext->SubSvcRef)].MinReqLength <= pMsgContext->reqDataLen) /* min length = (DDID, (MEMdef|DIDdef))? */
    {
      Dcm_RepeaterNextStep(DCM_SVC2C_PROGRESS_SUBFUNCTION); /* delegate job */
      lStdResult = DCM_E_LOOP; /* speed up processing */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CSubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CSubFuncHandler(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_CfgSvc2CSubFuncInfoPtrType pSubFuncInfo;

  pSubFuncInfo = Dcm_CfgSvc2CSubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(opStatus, pMsgContext, ErrorCode);                                                                         /* SBSW_DCM_CALL_FUNCPTR_SVC2CSUBFUNC */
  }

  return lStdResult;
}

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidLookUp(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;
  Dcm_Svc2CDynDidSrcItemPtrType pSrcItem;

  pSrcItem = Dcm_Svc2CGetSrcItem(pRepContext->SrcItemIndex);

  if(opStatus == DCM_INITIAL)
  {
     /* Extract source DID */
    Dcm_DiagConsumeReqDataAsU16(pMsgContext, &(pSrcItem->DidDescriptor.DidContext.Did));                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pSrcItem->DidDescriptor.DidContext)
                                   ,&(pRepContext->DynDidOpTypeContext) /* Use OpTypeContext of DynDID since no more needed at this time! */
                                   ,DCM_DIDMGR_OP_READ);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */

  switch(lStdReturn)
  {
  case DCM_E_OK:
    if(Dcm_DidMgrIsOpSupported(Dcm_CfgDidMgrGetDidInfo(&(pSrcItem->DidDescriptor.DidContext)), DCM_DIDMGR_OP_DEFINE))                                /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
    {
      /* else - no DynDID may be referenced! */
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
    {
      lStdReturn = Dcm_StateCheck(Dcm_CfgDidMgrGetDidOpInfo(&(pSrcItem->DidDescriptor.DidContext))->ExecCondRef
                                 ,DCM_DIAG_CHK_LVL_PARAMETER
                                 ,ErrorCode);                                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
      if(lStdReturn == DCM_E_OK)
      {
        Dcm_RepeaterNextStep(DCM_SVC2C_PROGRESS_01SRC_DIDCHECKCONDITIONS); /* next job */
        lStdReturn = DCM_E_LOOP;
      } /* else DCM_E_NOT_OK (ErrorCode already set) */
    }
    break;
  case DCM_E_PENDING:
    /* lStdReturn is already set */
    break;
  default: /* DCM_E_NOT_OK */
    /* source DID is not supported */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
    break;
  }

  return lStdReturn;
}
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidCheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidCheckCondition(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_Svc2CDynDidSrcItemPtrType pSrcItem;
  Std_ReturnType lStdResult = DCM_E_OK;

  pSrcItem = Dcm_Svc2CGetSrcItem(pRepContext->SrcItemIndex);

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pSrcItem->DidDescriptor.DidContext)), DCM_DIDMGR_OPTYPE_READCHKCOND))                   /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
  {
    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */

    /* check condition on this DID */
    Dcm_DidMgrInitOpClassInfo(&(pSrcItem->DidDescriptor.DidContext), DCM_DIDMGR_OPTYPE_READCHKCOND);                                                 /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,&(pSrcItem->DidDescriptor.DidContext)
                                        ,&(pRepContext->DynDidOpTypeContext) /* Use OpTypeContext of DynDID since no more needed at this time! */
                                        ,ErrorCode);                                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */

  } /* else - not supported operation - go on with getLength */

  if(lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(DCM_SVC2C_PROGRESS_01SRC_DIDGETLENGTH); /* next job */
    lStdResult = DCM_E_LOOP; /* speed up processing */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidGetLength(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)
{
  Dcm_Svc2CDynDidSrcItemPtrType pSrcItem;
  Std_ReturnType lStdReturn = DCM_E_OK;

  pSrcItem = Dcm_Svc2CGetSrcItem(pRepContext->SrcItemIndex);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pSrcItem->DidDescriptor.DidContext)), DCM_DIDMGR_OPTYPE_READLENGTH))                    /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
  {
    Dcm_DidMgrInitOpClassInfo(&(pSrcItem->DidDescriptor.DidContext), DCM_DIDMGR_OPTYPE_READLENGTH);                                                  /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */

    /* Calculate DID data length if applicable */
    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,&(pSrcItem->DidDescriptor.DidContext)
                                     ,&(pRepContext->DynDidOpTypeContext) /* Use OpTypeContext of DynDID since no more needed at this time! */
                                     ,ErrorCode);                                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  if(lStdReturn == DCM_E_OK)
  {
    uint8 srcDidPos;
    uint8 srcDidSize;

    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &srcDidPos);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &srcDidSize);                                                                                            /* SBSW_DCM_COMB_PTR_FORWARD */

    /* else - check for definition length overflow */
#  if (DCM_SVC_2C_READ_BUFFER_SIZE < 255u)
    if(srcDidSize > DCM_SVC_2C_READ_BUFFER_SIZE)
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* too much data referenced for temporary read buffer */                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
    else
#  endif
    if ((srcDidPos == 0u)
      ||((srcDidPos + srcDidSize - 1u) > pSrcItem->DidDescriptor.DidContext.DidLength) )
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* source DID referenced data out of boundary */                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    } /* check for possible read buffer or response overflow */
    else if ((!Dcm_UtiIsAdditionSafe(Dcm_DidMgrDidLengthType, pRepContext->DynDidLength, srcDidSize))
      || (Dcm_UtiPromotedSum(Dcm_DidMgrDidLengthType, pRepContext->DynDidLength, srcDidSize) > pRepContext->MaxAllowedLength))
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* too much data referenced */                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
    else /* Add this DID to the definition */
    {
      /* update total length of the DynDID for commitment */
      pRepContext->DynDidLength += srcDidSize;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

      /* store referenced data */
      pSrcItem->DidDescriptor.Offset = (uint8)(srcDidPos - 1u);                                                                                      /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
      pSrcItem->DidDescriptor.Size = srcDidSize;                                                                                                     /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
      Dcm_Svc2CSetDidSrcItem(pRepContext->SrcItemIndex); /* set the type of the source item to DID */                                                /* SBSW_DCM_POINTER_WRITE_BITSET */

      ++(pRepContext->SrcItemIndex); /* next item to be configured */                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      ++(pRepContext->DynDidItemCount); /* update number of items for commitment */                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

      --(pRepContext->ReqNumOfItems); /* commit processed item */                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
      if (pRepContext->ReqNumOfItems > 0u) /* any item left? */
      {
        Dcm_RepeaterNextStep(DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP); /* next job */
        lStdReturn = DCM_E_LOOP; /* speed up processing */
      }
      else
      {
        lStdReturn = DCM_E_OK; /* all source items finished service processing immediately */
      }
    }
  }
  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_02SrcItemsGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_02SrcItemsGetLength(uint8 alfid
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;
  Dcm_MemMgrMemBlockType lMemBlock;

  while(pRepContext->ReqNumOfItems > 0u)
  {
    Dcm_MemMgrParseMemStream(alfid, pMsgContext, &lMemBlock);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
    lStdReturn = Dcm_MemMgrCheckMemBlock(&lMemBlock, DCM_MEMMGR_OP_READ, ErrorCode);                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */

    if (lStdReturn == DCM_E_NOT_OK)
    {
      /* stop immediately and report the error */
      pRepContext->ReqNumOfItems = 0u; /* break */                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    } /* else - check for definition length overflow */
    else if( (lMemBlock.Length > DCM_SVC_2C_READ_BUFFER_SIZE)
      || (!Dcm_UtiIsAdditionSafe(uint32, pRepContext->DynDidLength, lMemBlock.Length))
      || (Dcm_UtiPromotedSum(uint32, pRepContext->DynDidLength, lMemBlock.Length) > pRepContext->MaxAllowedLength))
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* too much data referenced */                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
      /* finish service processing immediately */
      pRepContext->ReqNumOfItems = 0u; /* break */                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* else - add this address to the DynDID definition */
      Dcm_Svc2CDynDidSrcItemPtrType pSrcItem = Dcm_Svc2CGetSrcItem(pRepContext->SrcItemIndex);

      /* update total length of the DynDID for commitment */
      pRepContext->DynDidLength += (Dcm_CfgNetBufferSizeMemType)(lMemBlock.Length);                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */


      Dcm_UtiAssignStruct(pSrcItem->MemDescriptor.MemBlock, lMemBlock);                                                                              /* PRQA S 0310, 3109 */ /* MD_Dcm_GenericStructAssign_0310, MD_Dcm_CfgDepend_3109 */ /* SBSW_DCM_POINTER_WRITE_UTI_STRUCT */

      Dcm_Svc2CSetMemSrcItem(pRepContext->SrcItemIndex); /* set the type of the source item to MEMORY */                                             /* SBSW_DCM_POINTER_WRITE_BITSET */
      ++(pRepContext->DynDidItemCount); /* update number of items for commitment */                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      ++(pRepContext->SrcItemIndex);    /* next item to be configured */                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
      --(pRepContext->ReqNumOfItems);   /* commit processed item */                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  return lStdReturn;
}
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Svc2C_03DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_03DidLookUp(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
    Dcm_DiagConsumeReqDataAsU16(pMsgContext, &(pRepContext->DynDidInfoContext.Did));                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU16(pMsgContext, pRepContext->DynDidInfoContext.Did); /* positive response contains the DynDID (2Byte) */                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&pRepContext->DynDidInfoContext
                                   ,&pRepContext->DynDidOpTypeContext
                                   ,DCM_DIDMGR_OP_DEFINE);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  switch(lStdReturn)
  {
  case DCM_E_OK:
    /* clear concrete DynDID */
    Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DynDidInfoContext))->OpRef));
    break;
  case DCM_E_PENDING:
    /* lStdReturn is already set */
    break;
  default: /* DCM_E_NOT_OK */
    /* source DID is not supported */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  }

  return lStdReturn;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2C_SetMaxAllowedDynDIDLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2C_SetMaxAllowedDynDIDLength(
                                                                      Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)
{
  /* initialize common DynDID request context */
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
  if (Dcm_Svc2AIsPeriodicDid(pRepContext->DynDidInfoContext.Did))
  {
    Dcm_NetConnRefMemType connectionId = Dcm_Svc2AGetConnectionOfDID(pRepContext->DynDidInfoContext.Did);
    if (connectionId < DCM_NET_INVALID_CONNID)
    {
      pRepContext->MaxAllowedLength = (Dcm_DidMgrDidLengthType)Dcm_PbCfgNetConnectionInfo[connectionId].UudtFrameSize;                               /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      pRepContext->MaxAllowedLength = DCM_SVC2A_MAX_RESPONSE_LEN;                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else
# endif
  {
    /*
     * Perform length check based on the current protocol only. Sid 0x22 will do additional checks at read time in
     * case a client from another protocol is trying to access the DynDID!
     */
    pRepContext->MaxAllowedLength = Dcm_Svc2CGetMaxDynDidProtocolLen();                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2EHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2ERepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  if (opStatus == DCM_INITIAL)
  {
    /* Min Length already checked in DiagDispatcher and expected to be 3 !!! */
    Dcm_DiagConsumeReqDataAsU16(pMsgContext, &(pRepContext->DidInfoContext.Did));                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdResult = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->DidInfoContext)
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_WRITE);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)
  {
    Dcm_DiagProvideResData(pMsgContext, 2u);/* return the DID (shared Rx-Tx buffer) */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Check DID specific length */
    if ( (pMsgContext->reqDataLen >= Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->MinLength)
       &&(pMsgContext->reqDataLen <= Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->MaxLength) )
    {
      lStdResult = Dcm_DidMgrStaticDidStateCheck(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext))->ExecCondRef, ErrorCode);                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      if (lStdResult == DCM_E_OK)
      {
        Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_WRITE);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_RepeaterNextStep(DCM_SVC2E_PROGRESS_CHECKACCESS); /* delegate job */

        lStdResult = DCM_E_LOOP;/* speed up processing */
      } /* else DCM_E_NOT_OK - ErrorCode already assigned */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }
  else if (lStdResult == DCM_E_PENDING)
  {
    /* DCM_E_PENDING -> try again */
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ECheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ECheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_Svc2ERepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DidMgrDidLock(pRepContext->DidInfoContext.Did, DCM_DIDMGR_DIDLOCK_OWNER_WRITE);

  if(lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(DCM_SVC2E_PROGRESS_WRITEDATA); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2EWriteData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EWriteData(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc2ERepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_DidMgrWrite(opStatus
                              ,pMsgContext
                              ,&(pRepContext->DidInfoContext)
                              ,&(pRepContext->DidOpTypeContext)
                              ,ErrorCode);                                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdResult != DCM_E_PENDING)
  {
    Dcm_DidMgrDidRelease(DCM_DIDMGR_DIDLOCK_OWNER_WRITE);
  }

  return lStdResult;
}
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FReturnControlToEcu()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FReturnControlToEcu(void)
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid == TRUE)
  {
    Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRefPage = 0;
    Dcm_CfgDidMgrIoDidHandleOptType ioDidIter;

    Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE;

    for(ioDidIter = 0; ioDidIter < Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS); ioDidIter++)
    {
      Dcm_UtiBitSetBasePtrType pActiveIoDids = Dcm_Svc2FGetActiveIoDids(ioDidIter);
      Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef = opInfoRefPage;
      DCM_UTI_LOOP_BIT_SCAN(*pActiveIoDids)                                                                                                          /* SBSW_DCM_POINTER_WRITE_2FACTIVEIODIDS */
      {
        if(Dcm_UtiBitOpTest(Dcm_UtiBitSetBaseType, *pActiveIoDids, 0x01u))
        {
          Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_DidMgrGetCtrlOpInfoRef(opInfoRef));
        }
        ++opInfoRef;
      }
      opInfoRefPage += (Dcm_CfgDidMgrDidOpClassHandleOptType)Dcm_UtiGetNumBitsOfXintType(Dcm_UtiBitSetBaseType);/* next bunch of IoDids */
    }
  }
# endif
}

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FExtractCEMR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_Svc2FExtractCEMR(Dcm_ReadOnlyMsgType cemrStream
                                                            ,Dcm_CfgDidMgrIoDidCemrLengthMemType cemrSize)
{
  uint32 lResult = 0;

  if(cemrSize <= 4)
  {
    Dcm_CfgDidMgrIoDidCemrLengthOptType lCemrIter;

    /* Extract the CEMR byte-wise */
    for(lCemrIter = 0; lCemrIter < cemrSize; ++lCemrIter)
    {
      lResult <<= 8u;
      lResult |= cemrStream[lCemrIter];
    }

    /* For a 3 byte CEMR a 32bit value will be passed -> move to the MSB to fulfill the IO C/S API convention */
    if(cemrSize == 3)
    {
      lResult <<= 8u;
    }
  }/* else - leave the result = 0 (invalid value) */

  return lResult;
}
# endif

# if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FProcessCEMR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FProcessCEMR(Dcm_MsgContextPtrType pMsgContext                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                          ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)
{
  Dcm_CfgDidMgrIoDidCemrLengthMemType lCemrSize;

  /* Consider requests with and without CEMR */
  lCemrSize = Dcm_DidMgrGetCtrlEnblMaskLength(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext)));                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lCemrSize != 0)
  {
    /*
     * Subtract CEMR length from request length to get only the requested DID size in order to get the concrete length
     * of the last DID signal (if variable length)
     */
    Dcm_DiagUpdateReqLength(pMsgContext, lCemrSize);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    pRepContext->DidOpTypeContext.OpType.Io.EnableMaskPtr = Dcm_DiagGetReqDataRel(pMsgContext, pMsgContext->reqDataLen);                             /* SBSW_DCM_PARAM_PTR_FORWARD */

#  if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
    /* Extract CEMR as a value */
    pRepContext->DidOpTypeContext.OpType.Io.ControlEnableMaskRecord = Dcm_Svc2FExtractCEMR(pRepContext->DidOpTypeContext.OpType.Io.EnableMaskPtr     /* SBSW_DCM_PARAM_PTR_WRITE */ /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                                          ,lCemrSize);
#  endif
  }
  else
  {
    /* else - the request does not contain any CEMR */
    pRepContext->DidOpTypeContext.OpType.Io.EnableMaskPtr = NULL_PTR;                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FCalculateExpectedReqLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FCalculateExpectedReqLength(Dcm_DidMgrDidLengthPtrType expLengthMin
                                                                     ,Dcm_DidMgrDidLengthPtrType expLengthMax
                                                                     ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_CfgDidMgrIoDidCemrLengthMemType lCemrSize;

  if(Dcm_UtiBitOpTest(Dcm_DidMgrOpMemType, pRepContext->OpType, DCM_DIDMGR_OPTYPE_IO_SHRTTRMADJ))
  {
    /* Initialize DID handler */
    Dcm_DidMgrInitOpTypeHandler(&(pRepContext->DidInfoContext), &(pRepContext->DidOpTypeContext));                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* short term adjustment - consider optional enable mask record and the DID data! */
    *expLengthMax = Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->MaxLength;                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
# if (DCM_DIDMGR_IODID_DYNLEN_ENABLED == STD_ON)
    *expLengthMin = Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->MinLength;                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    if(*expLengthMin == 0) /* IO DID with dynamic length AND single signal */
    {
      /* Non-"Supported IDs" must have at least one request data byte! */
      if(Dcm_CfgDidMgrSignalOpClassInfo[pRepContext->DidOpTypeContext.Base.SignalOpClassInfoRef].FuncClass != DCM_DIDMGR_OPCLS_IO_WRAPPER)
      {
        *expLengthMin = 1;                                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
# else
    /* Constant IODID length -> min == max */
    *expLengthMin = *expLengthMax;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
# endif
  }
  else
  {
    *expLengthMin = 0u;                                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    *expLengthMax = 0u;                                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  lCemrSize = Dcm_DidMgrGetCtrlEnblMaskLength(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext)));                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
  *expLengthMin += lCemrSize;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  *expLengthMax += lCemrSize;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
}

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckReqLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2FCheckReqLength(Dcm_MsgContextPtrType pMsgContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)
{
  Dcm_NegativeResponseCodeType lNrc = DCM_E_POSITIVERESPONSE;
  Dcm_DidMgrDidLengthType expMinReqLen;
  Dcm_DidMgrDidLengthType expMaxReqLen;

  Dcm_Svc2FCalculateExpectedReqLength(&expMinReqLen, &expMaxReqLen, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Check DID specific length */
  if( (pMsgContext->reqDataLen < expMinReqLen)
    ||(pMsgContext->reqDataLen > expMaxReqLen) )
  {
    lNrc = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }

  return lNrc;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FIoDidOperationProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FIoDidOperationProcessor(Dcm_MsgContextPtrType pMsgContext                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType  lStdResult = DCM_E_NOT_OK;

  /* Initialize the IO-Control operation class from now for any checks that may come
   * (i.e. within Dcm_Svc2FCheckReqLength or later for the IO Control execution)  */
  Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext)
                           ,pRepContext->OpType);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Validate request length */
  *ErrorCode = Dcm_Svc2FCheckReqLength(pMsgContext, pRepContext);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_WRITE */

  if(*ErrorCode == DCM_E_POSITIVERESPONSE)
  {
    /* Validate remaining state preconditions */
    lStdResult = Dcm_DidMgrStaticDidStateCheck(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext))->ExecCondRef, ErrorCode);                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    if(lStdResult == DCM_E_OK)
    {
# if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
      /* Process any eventually supported CEMR */
      Dcm_Svc2FProcessCEMR(pMsgContext, pRepContext);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
# endif
      Dcm_RepeaterNextStep(DCM_SVC2F_PROGRESS_CHECKACCESS); /* delegate job */

      lStdResult = DCM_E_LOOP;/* speed up processing */
    }/* else DCM_E_NOT_OK (ErrorCode already set) */
  }/* else DCM_E_NOT_OK (ErrorCode already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FCheckAccess(Dcm_OpStatusType opStatus                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_MsgContextPtrType pMsgContext                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DidMgrDidLock(pRepContext->DidInfoContext.Did, DCM_DIDMGR_DIDLOCK_OWNER_IO);

  if(lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(DCM_SVC2F_PROGRESS_EXECUTEOP); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }

  return lStdResult;
}

# if (DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FGetLength(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)

{
  Std_ReturnType lStdReturn = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext)), DCM_DIDMGR_OPTYPE_READLENGTH))
  {
    Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READLENGTH);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,&(pRepContext->DidInfoContext)
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,ErrorCode);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(lStdReturn == DCM_E_OK)
  {
    /* Delegate the job to the data reader */
    Dcm_RepeaterNextStep(DCM_SVC2F_PROGRESS_READDATA);
    lStdReturn = DCM_E_LOOP;
  } /* else DCM_E_PENDING or DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}
# endif

# if(DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FReadData(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType          lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize data context for asynchronous IO DIDs only initially (not in pending status) */
    Dcm_DiagInitDataContext(&Dcm_InstanceContext.Diag.Services.Svc2F.DataContext, Dcm_DiagGetResData(pMsgContext), pMsgContext->resMaxDataLen);      /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* Read DID  */
  Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READ);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  lStdResult = Dcm_DidMgrReadDid(opStatus
                                ,&Dcm_InstanceContext.Diag.Services.Svc2F.DataContext
                                ,&(pRepContext->DidInfoContext)
                                ,&(pRepContext->DidOpTypeContext)
                                ,ErrorCode);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    /* Commit data and go on with response */
    Dcm_DiagProvideResData(pMsgContext, pRepContext->DidInfoContext.DidLength);                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FExecuteOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FExecuteOp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_DidMgrIoControl(opStatus
                                  ,pMsgContext
                                  ,&(pRepContext->DidInfoContext)
                                  ,&(pRepContext->DidOpTypeContext)
                                  ,ErrorCode);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
    if(pRepContext->OpType == DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU)
    {
      /*
       * If CEMR is enabled, let session/security state change handler update active operation bit map, otherwise simply
       * clear bit map for requested DID
       */
#  if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_OFF)
      Dcm_Svc2FClrDidActive(Dcm_DidMgrOpInfoRedirector(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->OpRef                                /* SBSW_DCM_POINTER_WRITE_BITSET */
                                                      ,OpRefIoControl));
#  endif
    }
    else
    {
      /*
       * After sucessful execution of a control operation other than "ReturnControlToEcu", register the entire IODID for
       * automatic reset on a session/security transition (only if "ReturnControlToEcu" is supported by that IODID)
       */
      if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext)),
                                     DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU))                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        /* Must have a valid index! */
        Dcm_DebugAssert(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->OpRef < DCM_NUM_IODIDS,
                        DCM_SID_INTERNAL,
                        DCM_E_INVALID_CONFIG)                                                                                                        /* COV_DCM_RTM_DEV_DEBUG XF */ /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_Svc2FSetDidActive(Dcm_DidMgrOpInfoRedirector(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->OpRef,                             /* SBSW_DCM_POINTER_WRITE_BITSET */
                                                         OpRefIoControl));
        Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = TRUE;
      }
    }
# endif
# if(DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON)
    /* Decide whether any response data has to be sent back to the client */
    if( (Dcm_DidMgrIsOpSupported(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext)), DCM_DIDMGR_OP_READ))
      &&(Dcm_CfgDidMgrSignalOpClassInfo[pRepContext->DidOpTypeContext.Base.SignalOpClassInfoRef].FuncClass
         != DCM_DIDMGR_OPCLS_IO_WRAPPER) )
    {
      Dcm_DidMgrInitOpInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OP_READ);                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_RepeaterNextStep(DCM_SVC2F_PROGRESS_GETLENGTH);
      lStdResult = DCM_E_LOOP;
    } /* Otherwise, IO DID does not support reading operation - continue with an empty positive response */
# endif
  } /* DCM_E_PENDING | DCM_E_NOT_OK */

  return lStdResult;
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc31Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc31Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc31RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  uint8          lRoutineOp;

  /* Search for the RID in the database */
  lStdResult = Dcm_RidMgrRidLookUp(opStatus
                                  ,Dcm_DiagGetReqDataAsU16Rel(pMsgContext, 1u)
                                  ,&(pRepContext->RidInfoIdx));                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  /* If RID found: */
  if(lStdResult == DCM_E_OK)
  {
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &lRoutineOp); /* Extract SF */                                                                           /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_DiagConsumeReqData(pMsgContext, 2u); /* Skip RID in request (already used for the look up) */                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResData(pMsgContext, 3u); /* Commit SF and RID in response */                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_RidMgrStateCheckRid(Dcm_CfgRidMgrRidInfoExecCondRef(pRepContext->RidInfoIdx), ErrorCode);                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* If the preconditions for the requested RID are fulfilled: */
    if(lStdResult == DCM_E_OK)
    {
      lStdResult = Dcm_RidMgrGetOpInfo(pRepContext->RidInfoIdx
                                      ,Dcm_RidMgrConvOpOfSubFunc(lRoutineOp)
                                      ,&(pRepContext->RidOpInfoIdx));                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      /* If the requested sub-function is supported: */
      if(lStdResult == DCM_E_OK)
      {
        /* If the length of the request is valid: */
        if( (pMsgContext->reqDataLen >= Dcm_CfgRidMgrOpInfoReqMinLength(pRepContext->RidOpInfoIdx))
          &&(pMsgContext->reqDataLen <= Dcm_CfgRidMgrOpInfoReqMaxLength(pRepContext->RidOpInfoIdx)) )
        {
          Dcm_RepeaterNextStep(DCM_SVC31_PROGRESS_EXECUTEOP);
          lStdResult = DCM_E_LOOP;
        }
        else
        {
          *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
      else
      {
        *ErrorCode = DCM_E_SUBFUNCTIONNOTSUPPORTED;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }/* else DCM_E_NOT_OK - ErrorCode already assigned */
  }
  /* Otherwise, if RID look-up needs more time: */
  else if (lStdResult == DCM_E_PENDING)
  {
    /* lStdResult is already set */
  }
  /* Otherwise i.e. RID not found, return NRC 0x31 */
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc3DHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc3DRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  uint8          lAlfid;
  uint8          lBlockLength;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* dispatcher guarantees for minimum length of 4 bytes (ALFID + MEM + SIZE + DATA) available */
  lStdResult = Dcm_MemMgrValidateAndGetAlfid(pMsgContext, &lAlfid, &lBlockLength, ErrorCode);                                                        /* SBSW_DCM_COMB_PTR_FORWARD */ /* SBSW_DCM_POINTER_FORWARD_STACK */
  if (lStdResult == DCM_E_OK)
  {
    /* check for exact length match */
    Dcm_DiagProvideResData(pMsgContext, (lBlockLength + 1u)); /* (1 byte ALFID + MEM + SIZE) */                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_MemMgrParseMemStream(lAlfid, pMsgContext, &pRepContext->MemBlock);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(pRepContext->MemBlock.Length == pMsgContext->reqDataLen)
    {
      lStdResult = Dcm_MemMgrCheckMemBlock(&pRepContext->MemBlock, DCM_MEMMGR_OP_WRITE, ErrorCode);                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      if (lStdResult == DCM_E_OK)
      {
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
        Dcm_RepeaterNextStep(DCM_SVC3D_PROGRESS_CHECKACCESS);
# else
        Dcm_RepeaterNextStep(DCM_SVC3D_PROGRESS_WRITEMEMORY);
# endif
        lStdResult = DCM_E_LOOP;/* speed up processing */
      }/* else DCM_E_NOT_OK (ErrorCode already set) */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }/* else DCM_E_NOT_OK (ErrorCode already set) */

  return lStdResult;
}

# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc3DCheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DCheckAccess(Dcm_OpStatusType opStatus
                                                                ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_Svc3DRepeaterProxyContextConstPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_InstanceContext.MemMgr.LockedByClient != DCM_MEMMGR_ACCESS_NONE)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
  {
    Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_REQ_EXT;
    Dcm_RepeaterNextStep(DCM_SVC3D_PROGRESS_WRITEMEMORY); /* delegate job */
    lStdResult = DCM_E_LOOP; /* speed up processing */
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc3DWriteMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DWriteMemory(Dcm_OpStatusType opStatus
                                                                ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc3DRepeaterProxyContextConstPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_MemMgrWriteMemory(opStatus
                                    ,&(pRepContext->MemBlock)
                                    ,Dcm_DiagGetReqData(pMsgContext)
                                    ,ErrorCode);                                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

  return lStdResult;
}
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc85SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc85SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc85SubFuncInfoGetEntryOrNull(
                                                                                Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc85SubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC85SUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC85SUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc85SubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc85Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc85RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc85SubFuncLookUpTable
                                                   ,Dcm_CfgSvc85SubFuncExecPrecondTable
                                                   ,Dcm_Svc85ReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef   = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ReqMode     = Dcm_CfgSvc85SubFuncInfo[pRepContext->SubSvcRef].Mode;                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());                                                            /* SBSW_DCM_GLOBAL_PTR_WRITE */

# if (DCM_DEM_API_430_ENABLED == STD_ON)
    if (pMsgContext->reqDataLen == 3)
    {
      Dcm_DiagConsumeReqDataAsU24(pMsgContext, &pRepContext->DTCGroup);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      if (pRepContext->DTCGroup != DEM_DTC_GROUP_ALL_DTCS)
      {
        lStdResult = E_NOT_OK;
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      /* else: everything fine -> proceed with service processing */
    }
    else if (pMsgContext->reqDataLen != 0)
    {
      lStdResult = E_NOT_OK;
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* length = 0 -> nothing to extract */
    }
# else
    /* DEM API prior to 4.3.0 */
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
    Dcm_DiagConsumeReqDataAsU24(pMsgContext, &pRepContext->DTCGroup);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
    pRepContext->DTCGroup = DEM_DTC_GROUP_ALL_DTCS;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
#  endif
# endif

# if (DCM_DEM_API_430_ENABLED == STD_ON)
    if (lStdResult == DCM_E_OK)
# endif
    {
      Dcm_RepeaterSetUser(DCM_REPEATER_USER_DEM); /* set user for central repeater handling */
      Dcm_RepeaterNextStep(DCM_SVC85_PROGRESS_REPEATERPROXY);
      lStdResult = DCM_E_LOOP;/* speed up processing */
    }
  }

  return lStdResult;
}
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc86SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc86SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc86SubFuncInfoGetEntryOrNull(
                                                                                Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc86SubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC86SUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC86SUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc86SubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc86Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc86RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                              ,Dcm_CfgSvc86SubFuncLookUpTable
                                              ,Dcm_CfgSvc86SubFuncExecPrecondTable
                                              ,Dcm_Svc86ReqLengthGetter
                                              ,Dcm_DiagNoSequenceChecker
                                              ,&lSubSvcRef
                                              ,ErrorCode);                                                                                           /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_RepeaterNextStep(DCM_SVC86_PROGRESS_SUBFUNCTION); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc86SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86SubFuncHandler(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc86RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_CfgSvc86SubFuncInfoPtrType pSubFuncInfo;

  pSubFuncInfo = Dcm_CfgSvc86SubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(opStatus, pMsgContext, ErrorCode);                                                                         /* SBSW_DCM_CALL_FUNCPTR_SVC86SUBFUNC */
  }

  return lStdResult;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Module internal function implementations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrCheckMemBlock()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrCheckMemBlock(Dcm_MemMgrMemBlockConstPtrType pMemBlock
                                                                ,Dcm_MemMgrMemoryOpType memOp
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_CfgMemMgrMemIdInfoType lMemMapDescriptor;
  Std_ReturnType lStdResult;

  lStdResult = Dcm_MemMgrGetMemMap(pMemBlock, &lMemMapDescriptor, ErrorCode);                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    lStdResult = Dcm_MemMgrCheckMemoryRange(pMemBlock, memOp, &lMemMapDescriptor, ErrorCode);                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
  }
  /* Otherwise - invalid memory area (MID) */
  return lStdResult;
}

# if (DCM_MEMMGR_MEMOP_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrReadMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrReadMemory(Dcm_OpStatusType opStatus
                                                             ,Dcm_MemMgrMemBlockConstPtrType pMemBlock
                                                             ,Dcm_DiagDataContextPtrType pDataContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType         lResult;
  Dcm_MemMgrOpResultType memOpResult;

  *ErrorCode = DCM_E_POSITIVERESPONSE;                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pDataContext->AvailLen < pMemBlock->Length)
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else /* The data to be read fits into the available buffer */
#  endif
  {
    memOpResult = Dcm_ReadMemory(opStatus
#  if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
      ,pMemBlock->Mid
#  else
      ,0u
#  endif
      ,pMemBlock->Address
      ,pMemBlock->Length
      ,Dcm_DiagGetDataContextBuffer(pDataContext)                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
      ,ErrorCode
#  endif
    );                                                                                                                                               /* SBSW_DCM_CALL_READMEMORY */

    if (memOpResult == DCM_E_OK)
    {
      Dcm_DiagCommitData(pDataContext, pMemBlock->Length);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    lResult = Dcm_MemMgrConvMemOpResult(memOpResult, opStatus, ErrorCode, DCM_E_GENERALREJECT);  /* RFC 57196 - return NRC 0x10 */                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  return lResult;
}
# endif

# if (DCM_MEMMGR_MEMOP_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrWriteMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrWriteMemory(Dcm_OpStatusType opStatus
                                                              ,Dcm_MemMgrMemBlockConstPtrType pMemBlock
                                                              ,Dcm_MsgType data
                                                              ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_MemMgrOpResultType memOpResult;

  *ErrorCode = DCM_E_POSITIVERESPONSE;                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

  memOpResult = Dcm_WriteMemory(opStatus
#  if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
      ,pMemBlock->Mid
#  else
      ,0u
#  endif
      ,pMemBlock->Address
      ,pMemBlock->Length
      ,data
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
      ,ErrorCode
#  endif
      );                                                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

  return Dcm_MemMgrConvMemOpResult(memOpResult, opStatus, ErrorCode, DCM_E_GENERALPROGRAMMINGFAILURE);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
/**********************************************************************************************************************
 *  Dcm_MemMgrValidateAndGetAlfid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrValidateAndGetAlfid(Dcm_MsgContextPtrType   pMsgContext
                                                                      ,Dcm_Uint8VarDataPtrType pAlfid
                                                                      ,Dcm_Uint8VarDataPtrType pBlockLength
                                                                      ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  uint8 addrSize;
  uint8 lenSize;

  /* else - at least one byte for ALFID is available */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, pAlfid);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  addrSize = Dcm_MemMgrGetMemBlockAddrSize(*pAlfid);
  lenSize = Dcm_MemMgrGetMemBlockLenSize(*pAlfid);
  *pBlockLength = (uint8)(addrSize + lenSize); /* (memory address + memory size) */                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

  if(Dcm_UtiLookUpUint8(Dcm_CfgMemMgrAlfidLookUpTable, *pAlfid) < 0)                                                                                 /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else if(*pBlockLength <= pMsgContext->reqDataLen)
  {
    lStdResult = DCM_E_OK;
  }
  else
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_MemMgrParseMemStream()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_MemMgrParseMemStream(uint8 alfid
                                                       ,Dcm_MsgContextPtrType pMsgContext
                                                       ,Dcm_MemMgrMemBlockPtrType pMemBlock)
{
  uint8_least lAddressLength;

  lAddressLength = Dcm_MemMgrGetMemBlockAddrSize(alfid);

# if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
  --lAddressLength; /* skip mid */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &(pMemBlock->Mid));                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
# endif

  /* extract address */
  pMemBlock->Address = (Dcm_CfgMemMgrReqAddrType)Dcm_MemMgrDwordExtract(pMsgContext, lAddressLength);                                                /* SBSW_DCM_PARAM_PTR_WRITE */ /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* extract size  */
  pMemBlock->Length = (Dcm_CfgMemMgrReqSizeType)Dcm_MemMgrDwordExtract(pMsgContext, Dcm_MemMgrGetMemBlockLenSize(alfid));                            /* SBSW_DCM_PARAM_PTR_WRITE */ /* SBSW_DCM_PARAM_PTR_FORWARD */
}
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_22_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_SVC_31_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrIsIdEnabled()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_ObdIdMgrIsIdEnabled(uint8 obdId
                                              ,P2CONST(Dcm_ObdIdMgrMaskValueTableType, AUTOMATIC, DCM_CONST) pMaskData)
{
  boolean lResult;

  if (obdId == 0x00u)
  {
    lResult = (boolean)(pMaskData[0] != 0); /* ID 0x00 is only available if any other IDs are supported too */
  }
  else
  {
    lResult = (boolean)Dcm_ObdIdMgrIsIdSupported(pMaskData[Dcm_ObdIdMgrGetAvailabilityIdIdx(obdId - 1)], obdId); /* else - another ID (i.e. [0x01-0xFF]) is requested */
  }

  return lResult;
}
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrIdLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrIdLookUp(uint8 id
                                                             ,Dcm_ObdIdMgrDescPtrType pParserDesc)
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  sint16_least   lLookUpResult;

  lLookUpResult = Dcm_VarMgrLookUpFilter(Dcm_UtiLookUpUint8(pParserDesc->LookUpTable, id), pParserDesc->LookUpFilterTable);                          /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lLookUpResult >= 0)
  {
# if (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
    if(Dcm_ObdIdMgrIsIdEnabled(id, pParserDesc->MaskData) == TRUE)                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
# endif
    {
      pParserDesc->Handle = (Dcm_ObdIdMgrHandleMemType)(lLookUpResult - Dcm_ObdIdMgrGetAvailabilityIdIdx(id) - 1);                                   /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_OK;
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(uint32, DCM_CODE) Dcm_ObdIdMgrGetAvailabilityMask(uint8 id
                                                                ,Dcm_ObdIdMgrDescPtrType pParserDesc)
{
  uint32       lResultMask;
  sint16_least lLookUpIter;

  lResultMask = 0;
  lLookUpIter = (sint16_least)Dcm_UtiLookUpUint8(pParserDesc->LookUpTable, id);                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Skip the availability Id */
  ++lLookUpIter;

  /* Iterate within the range of the given AID or end of table and calculate bit mask  */
  for(; lLookUpIter < (sint16_least)pParserDesc->LookUpTable[0]; ++lLookUpIter)
  {
    uint8 lId = pParserDesc->LookUpTable[lLookUpIter+1]; /* Consider the leading-size-byte offset in the lookup table */

    if(Dcm_ObdIdMgrIdLookUp(lId, pParserDesc) == DCM_E_OK)                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    {
      Dcm_UtiBitOpSet(uint32, lResultMask, Dcm_ObdIdMgrGetObdIdMaskBit(lId));
    }

    /* Iterate until the next AID is reached. This AID shall be reported in bit0 of the mask too, therefore use post-condition-check */
    if(Dcm_ObdIdMgrIsAvailabilityId(lId))
    {
      break;
    }
  }

  return lResultMask;
}

# if (DCM_OBDIDMGR_REQ_PARSER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrProcessSupportedIdRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrProcessSupportedIdRequest(Dcm_MsgContextPtrType pMsgContext
                                                                              ,Dcm_ObdIdMgrDescPtrType pParserDesc
                                                                              ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult   = DCM_E_OK;
  uint8_least    lNumberOfIds = (uint8_least)pMsgContext->reqDataLen;

  /* If maximal 6 OBD availability IDs are requested: */
  if(lNumberOfIds <= DCM_OBDIDMGR_MAX_NUMBER_OF_IDS)
  {
    uint8        lIdList[DCM_OBDIDMGR_MAX_NUMBER_OF_IDS];
    uint8_least  lIdIter;

    /* Copy all requested IDs to local list. This allows to write into response buffer during parsing. */
    Dcm_DiagConsumeReqDataAsUN(pMsgContext, lIdList, DCM_OBDIDMGR_MAX_NUMBER_OF_IDS, pMsgContext->reqDataLen);                                       /* SBSW_DCM_COMB_PTR_FORWARD */

    /* If any ID in request is not an availability ID (0x00, 0x20, 0x40...): */
    for(lIdIter = 0; lIdIter < lNumberOfIds; lIdIter++)
    {
      if(!Dcm_ObdIdMgrIsAvailabilityId(lIdList[lIdIter]))
      {
        /* Mix of Data and Availability IDs is not allowed */
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        break;
      }
    }

    if(lStdResult == DCM_E_OK)
    {
      for(lIdIter = 0; lIdIter < lNumberOfIds; lIdIter++)
      {
        uint8 lId = lIdList[lIdIter];

        /* If the given OBD identifier is supported: */
        if(Dcm_ObdIdMgrIdLookUp(lId, pParserDesc) == DCM_E_OK)                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
        {
          Dcm_DiagProvideResDataAsU8(pMsgContext, lId);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
          Dcm_DiagProvideResDataAsU32(pMsgContext, Dcm_ObdIdMgrGetAvailabilityMask(lId, pParserDesc));                                               /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }

      /* If no requested ID was supported: */
      if (pMsgContext->resDataLen == 0)
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_UTI_LOOKUP_U16_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_UtiLookUpUint16()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpUint16(P2CONST(uint16, AUTOMATIC, DCM_CONST) lookUpTable
                                                          ,uint16 value)
{
  sint16_least  lResult;
  uint16_least  loIdx;
  uint16_least  hiIdx;
  uint16_least  lPosition;

  /* #10 Initialize look-up: assume nothing will be found */
  lResult = -1;
  loIdx= 1;
  hiIdx= lookUpTable[0];

  /* #20 If any sub-array exists: */
  while (loIdx <= hiIdx)
  {
    /* #30 Calculate entry position for comparison */
    lPosition = (uint16_least)(loIdx + ((hiIdx - loIdx) / 2)); /* avoids overflows on value addition */

    /* #40 If item found: */
    if(lookUpTable[lPosition] == value)
    {
      /* #50 Return valid entry position (compensate offset) */
      lResult = (sint16_least)(lPosition-1);
      break;
    }
    /* #60 Otherwise - continue searching */

    /* #70 Determine which sub-array shall be taken as a next */
    if (value < lookUpTable[lPosition])
    {
      /* not needed lPosition zero value check, since loIdx >=1 */
      hiIdx = (uint16_least)(lPosition - 1);
    }
    else
    {
      /* Use upper half of interval */
      loIdx = (uint16_least)(lPosition + 1);
    }
  }
  /* #80 Otherwise - report nothing found */

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_UtiGetBitPosition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(uint8, DCM_CODE) Dcm_UtiGetBitPosition(uint32 bitSet)
{
  uint8 bitCtr;

  /* This API shall be called with a single bit set in the bit-mask */
  Dcm_DebugAssert(Dcm_UtiIsPowerOfTwo(uint32, bitSet), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                /* COV_DCM_RTM_DEV_DEBUG XF */

  /* #10 Initialize result counter with 0 (in case no bit or only bit0 is set) */
  bitCtr = 0;

  /* #20 The result is zero based -> skip the first bit in the bit-set */
  bitSet >>= 1;

  /* #30 Count zero bits in the set until the set bit is reached */
  while(bitSet != 0)
  {
    bitSet >>= 1;
    ++bitCtr;
  }

  /* #40 Return bit position */
  return bitCtr;
}

#if (DCM_UTI_NVM_READ_ENABLED  == STD_ON) || \
    (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_UtiNvMGetErrorStatus()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMGetErrorStatus(uint16 blockId)
{
  Std_ReturnType lStdResult;
  NvM_RequestResultType nvmStatus;

  /* #10 Get current NvM job status */
  lStdResult = Dcm_UtiArEnvNvMGetErrorStatus(blockId, &nvmStatus);                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */

  /* #20 If status report successful: */
  if(lStdResult == E_OK)
  {
    /* #30 If NvM operation succeeded: */
    if (nvmStatus == NVM_REQ_OK )
    {
      /* #40 Return the result to the callee */
      /* result is already E_OK */
    }
    /* #50 If the NvM needs more time: */
    else if (nvmStatus == NVM_REQ_PENDING)
    {
      /* #60 Notify callee to retry later */
      lStdResult = DCM_E_PENDING;
    }
    else
    {
      /* #70 Otherwise: NvM operation failed for other reason; report back to callee */
      lStdResult = E_NOT_OK;
    }
  }
  else
  {
    /* #80 Otherwise: Gathering NvM job status failed; report back to callee */
    lStdResult = E_NOT_OK;
  }

  /* #90 Return final result */
  return lStdResult;
}
#endif
#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTaskTaMonitor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTaMonitor(Dcm_TskTaskEvOptType ev
                                                   ,Dcm_TskTaskEvPtrType pPostEv)                                                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_CfgNetTObjHandleOptType lTObjCntr;

  /* #10 Check whether any request which has to be canceled is in progress */
  if(((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE | DCM_DIAG_QUEUE_FLAG_IS_WAITING) & Dcm_InstanceContext.Diag.QueuedSet.Flags) != 0)
  {

    /* #20 Enter critical section (Reason: the transport object may not be modified from outside) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/

    /* #30 If a request is in progress */
    if((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE & Dcm_InstanceContext.Diag.QueuedSet.Flags) != 0)
    {
      Dcm_TskTaskEvOptType tObjEv = Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, Dcm_DiagGetTranspObj()->Handle);

      /* #40 If the ongoing request is from the same tester as the new request with the foreign N_TA */
      if(Dcm_TskIsLocalEventSet(ev, tObjEv))
      {
        /* #50 Cancel the request processing */
        Dcm_DiagCancelProcessing();
      }/* else - post processing or idle are to be handled in a normal way */
    }

    /* #60 If a waiting new request is in the queue */
    if((DCM_DIAG_QUEUE_FLAG_IS_WAITING & Dcm_InstanceContext.Diag.QueuedSet.Flags) != 0)
    {
       Dcm_TskTaskEvOptType tObjEv = Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, Dcm_DiagGetQueuedTranspObj()->Handle);

       /* #70 If the queued request is from the same tester as the new request with the foreign N_TA */
       if(Dcm_TskIsLocalEventSet(ev, tObjEv))
       {
         /* #80 Cancel the queued request in the next task cycle */
         *pPostEv = tObjEv;/* retry later */                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
       }
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* #90 Leave critical section */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

  /* #100 Scan all affected transport objects */
  lTObjCntr = 0u;
  DCM_TSK_EVENT_SCAN_LOOP(ev)
  {
    if(Dcm_TskIsLocalEventSet(ev, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTransportObject(lTObjCntr);

      /* #110 If a received but not yet processed request was interrupted by another request with a foreign N_TA */
      if( ( pTranspObj->State == DCM_NET_TOBJ_STATE_RX_END)
        &&((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_OBSOLETE) != 0 ) ) /* This is still the original transport object marked to be canceled in the Dcm_OnRequestIndication */
      {
        Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

        /* #120 Prevent the processing of the received but not yet processed request */
        Dcm_TskClrEvent(DCM_TSK_ID_NET_RX, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));

        /* #130 Deallocate the transport object and free the connection */
        Dcm_NetUnRegisterComMActivity(pTranspObj->ConnId); /* Deallocate transport object */
        Dcm_NetBufferRelease(pBufferContext); /* The buffer is free now */                                                                           /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
        Dcm_NetUnRegisterActiveConnection(pTranspObj); /* No further processing needed */                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      } /* #140 Otherwise, connection is not obsolete or will be canceled during service processing (already in state
         * DCM_NET_TOBJ_STATE_READY) */
    }
    ++lTObjCntr;
  }
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#endif

#if (DCM_NET_TASK_RX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTaskRx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskRx(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv)                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
# if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
  /* If multi protocol is enabled, start request prioritization */
  Dcm_NetRxPrioritisation(ev, pPostEv);                                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
# elif (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)                                                                                              /* COV_DCM_SUPPORT_ALWAYS TX */
  /*
   * In case that multi protocol is disabled and interruption on a request with foreign N_TA is enabled:
   * When a new request is received instead of calling Dcm_DiagRxIndication directly the new request has to be
   * delegated by this task. This is necessary to be able to cancel already received but not yet processed requests
   * when another request with a foreign N_TA is received. That cancellation would be done by the Dcm_NetTaskTaMonitor.
   */
  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Only one transport object can be processed */
  Dcm_DebugAssert(Dcm_UtiIsPowerOfTwo(Dcm_TskTaskEvOptType, ev), DCM_SID_INTERNAL, DCM_E_PARAM)                                                      /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Otherwise, delegate the received request to the task */
  Dcm_DiagRxIndication(Dcm_NetGetTransportObject(Dcm_UtiGetBitPosition(ev)));                                                                        /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
# else
#  error "Invalid configuration!"
# endif
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetTaskTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTx(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv)                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if (Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_NET_TX_SEND_USDT))
  {
    {
      Dcm_CfgNetTObjHandleOptType lTObjIter;

      /* find candidate for NRC 0x21 or final response */
      for (lTObjIter = 0; lTObjIter < Dcm_PbCfgNetNumTransportObjects; ++lTObjIter)
      {
        Dcm_NetTransportObjectPtrType pTranspObj;
        pTranspObj = Dcm_NetGetTransportObject(lTObjIter);

#if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
        if ((pTranspObj->State == DCM_NET_TOBJ_STATE_RX_END) /* Completely received ... */
          && ((DCM_NET_TOBJ_FLAG_BUSY & pTranspObj->Flags) != 0))/* ... a parallel request */
        {
          /* Send NRC 0x21 response */
          Dcm_NetComposeAddNegResponse(pTranspObj, DCM_NET_TOBJ_RESTYPE_SIMPLE, DCM_E_BUSYREPEATREQUEST);                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
#endif

        if (pTranspObj->State == DCM_NET_TOBJ_STATE_PREPTX)
        {
          Dcm_NetTransmitUsdtResponse(pTranspObj);                                                                                                   /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
      }
    }
  }

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  if (Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_NET_TX_SEND_UUDT))
  {
    Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;

    for (lPerTxObjIter = 0; lPerTxObjIter < Dcm_NetPeriodicMsgGetNextMsgHdl(); lPerTxObjIter++)
    {
      if (Dcm_NetGetPeriodicTxObject(lPerTxObjIter)->State == DCM_NET_PERIODIC_TX_STATE_QUEUED)
      {
        Dcm_NetPeriodicMsgTransmitTxObj(lPerTxObjIter);
      }
    }
  }
#endif
}

/**********************************************************************************************************************
 *  Dcm_NetRegisterComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetRegisterComMActivity(Dcm_NetTransportObjectPtrType pTranspObj)                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
#if(DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0)/* internal requests do not manage the ComM activity */
#endif
  {
    Dcm_CfgNetNetIdRefMemType lNetHandle;
    Dcm_NetComMContextPtrType pComMContext;

    lNetHandle   = Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnId].NetworkIdRef;
    pComMContext = Dcm_NetGetComMContext(lNetHandle);

    Dcm_DebugAssert((pComMContext->RegisteredNetworks != Dcm_UtiMaxValueOfUintType(Dcm_NetConnRefMemType)), DCM_SID_INTERNAL, DCM_E_PARAM)           /* COV_DCM_RTM_DEV_DEBUG XF */

    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    if(pComMContext->RegisteredNetworks == 0u)
    {
      /* activate only if default session is active, otherwise already active */
      if(   Dcm_StateIsDefaultSessionActive()
        && (Dcm_SingletonContext.Network.ActiveDiagnostic == DCM_NET_COMM_ACTIVE)
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
        && (Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
        )
      {
        /* Register one connection */
        Dcm_NetArEnvComMActiveDiag(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandle]]);
      }
    }

    /* Register one connection */
    ++pComMContext->RegisteredNetworks;                                                                                                              /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterComMActivity(Dcm_NetConnRefMemType connId)
{
  Dcm_CfgNetNetIdRefMemType lNetHandle;
  Dcm_NetComMContextPtrType pComMContext;

  lNetHandle   = Dcm_PbCfgNetConnectionInfo[connId].NetworkIdRef;
  pComMContext = Dcm_NetGetComMContext(lNetHandle);

  Dcm_DebugAssert((pComMContext->RegisteredNetworks != 0u), DCM_SID_INTERNAL, DCM_E_PARAM)                                                           /* COV_DCM_RTM_DEV_DEBUG XF */

  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Unregister one connection */
  --pComMContext->RegisteredNetworks;                                                                                                                /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */

  if(pComMContext->RegisteredNetworks == 0u)
  {
    /* return only if default session is active */
    if (Dcm_StateIsDefaultSessionActive()
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
       &&(Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
       )
    {
      Dcm_NetArEnvComMInactiveDiag(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandle]]);
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterAllComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterAllComMActivity(void)
{
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  {
    Dcm_CfgNetNetIdRefOptType lNetHandleIter;
    for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
    {
      /* unregister only if no connection is ongoing */
      if(Dcm_PbRamNetComMContext[lNetHandleIter].RegisteredNetworks == 0u)
      {
        Dcm_NetArEnvComMInactiveDiag(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandleIter]]);
      }
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterActiveConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterActiveConnection(Dcm_NetTransportObjectPtrType pTranspObj)
{
#if(DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0)
#endif
  {
    Dcm_DebugAssert((Dcm_SingletonContext.Network.NumActiveConnections != 0u), DCM_SID_INTERNAL, DCM_E_PARAM)                                        /* COV_DCM_RTM_DEV_DEBUG XF */

    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
     BEGIN CRITICAL SECTION
     *=================================*/
    /* If this was not a functional request from different tester with 0x3E 0x80 or a denied parallel tester request */
    if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_IGNORE) == 0)
    {
      /* The timers shall be restarted later with the original timer values (when the last connection goes inactive) */
      Dcm_TmrSetTimer(DCM_TMR_ID_S3, DCM_DIAG_TIME_S3);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
      Dcm_TmrSetTimer(DCM_TMR_ID_KEEP_ALIVE, DCM_NET_KEEP_ALIVE_TIME);
#endif
    }

    /* Un-register an active connection */
    --Dcm_SingletonContext.Network.NumActiveConnections;

    if(Dcm_SingletonContext.Network.NumActiveConnections == 0u)
    {
      /* Start or resume the S3 timer and keep-alive timer with the last set values */
      Dcm_TmrResumeTimer(DCM_TMR_ID_S3);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
      Dcm_TmrResumeTimer(DCM_TMR_ID_KEEP_ALIVE);
#endif
    }

    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
  Dcm_NetTranspObjRelease(pTranspObj);                                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
}

/**********************************************************************************************************************
 *  Dcm_NetAllocateOrGetTranspObjectOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetAllocateOrGetTranspObjectOrNull(Dcm_NetConnRefOptType connId)
{
  Dcm_NetTransportObjectPtrType pTranspObj = NULL_PTR; /* No free transport object found */

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(connId >= Dcm_PbCfgNetNumConnections)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETALLOCATEORGETTRANSPOBJECT);
  }
  else
#endif
  {
    if(Dcm_PbRamNetConnId2TObjMap[connId] >= DCM_NET_INVALID_TOBJID)/* check if already assigned */
    {
      Dcm_CfgNetTObjHandleOptType lTObjIter;

      for(lTObjIter = 0; lTObjIter < Dcm_PbCfgNetNumTransportObjects; ++lTObjIter)
      {
        if(Dcm_PbRamNetTransportObject[lTObjIter].State == DCM_NET_TOBJ_STATE_FREE)
        {
          Dcm_NetPutToConn2TObjMap(connId, (Dcm_CfgNetTObjHandleMemType)lTObjIter); /* Assign ownership information */
          pTranspObj = Dcm_NetGetTransportObject(lTObjIter);
          break;
        }/* Transport Object is in use - check next one */
      }
    }
    else
    {
      pTranspObj = Dcm_NetGetTransportObject(Dcm_PbRamNetConnId2TObjMap[connId]);
    }
  }
  return pTranspObj;
}

/**********************************************************************************************************************
 *  Dcm_NetGetTranspObjOfConnectionOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetConnRefOptType connId)
{
  Dcm_NetTransportObjectPtrType pTranspObj = NULL_PTR;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(connId >= Dcm_PbCfgNetNumConnections)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETGETTRANSPOBJOFCONNECTION);
  }
  else
#endif
  {
    if(Dcm_PbRamNetConnId2TObjMap[connId] < DCM_NET_INVALID_TOBJID)
    {
      pTranspObj = Dcm_NetGetTransportObject(Dcm_PbRamNetConnId2TObjMap[connId]);
    }
  }

  return pTranspObj;
}

/**********************************************************************************************************************
 *  Dcm_NetTranspObjRelease()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTranspObjRelease(Dcm_NetTransportObjectPtrType pTranspObj)
{
  /* #10 If the transport object is still in use: */
  if(pTranspObj->State != DCM_NET_TOBJ_STATE_FREE) /* assure the object has validly initialized fields */
  {
    /* #20 Its states are valid and can be used if needed */
    /* #30 Reset only the relevant states of the transport object */
    Dcm_NetPutToConn2TObjMap(pTranspObj->ConnId, DCM_NET_INVALID_TOBJID); /* Clear the ownership information */
    pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_NONE;                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    pTranspObj->Flags   = DCM_NET_TOBJ_FLAG_NONE;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    /* #40 Reset the guard state (object in use) at last to avoid critical section usage */
    pTranspObj->State   = DCM_NET_TOBJ_STATE_FREE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  /* #50 Otherwise nothing to do */
}

/**********************************************************************************************************************
 *  Dcm_NetGetConnIdByTesterAddress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnIdByTesterAddress(uint16 testerAddress)
{
  Dcm_NetConnRefOptType lConnIter;
  Dcm_NetConnRefMemType lResult = DCM_NET_INVALID_CONNID;

  for(lConnIter = 0; lConnIter < Dcm_PbCfgNetNumConnections; ++lConnIter)
  {
    if (testerAddress == Dcm_PbCfgNetConnectionInfo[lConnIter].ClientSrcAddr)
    {
      lResult = (Dcm_NetConnRefMemType)lConnIter;
      break;
    }
  }
  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetUsdtTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUsdtTxConfirmation(Dcm_NetTransportObjectPtrType pTranspObj
                                                        ,Dcm_NetTransmissionResultType result)
{
#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0)
  {
    Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    /* ComM is already released in the DiagPostProcessing task */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
#endif
  {
#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON) || \
    (DCM_NET_PROTOCOL_SWITCH_NOTIFICATION_ENABLED == STD_ON)
    if(pTranspObj->ResType == DCM_NET_TOBJ_RESTYPE_SIMPLE)
    {
      Dcm_NetUnRegisterComMActivity(pTranspObj->ConnId);
      Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
#endif
    {
      Dcm_DiagOnTxFinished(pTranspObj, result);                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
}
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutPeriodicTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutPeriodicTx(void)
{
  Dcm_TmrTimerCntrMemType lReloadTick;
  boolean                 lDoReload;

  lDoReload = Dcm_OnTimeoutTxObjectHandler();
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  lDoReload |= Dcm_OnTimeoutDelayTimerHandler();
# endif

  lReloadTick = (Dcm_TmrTimerCntrMemType)((lDoReload == TRUE)?1u:0u);

  return lReloadTick;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_CfgNetPTxObjHandleMemType, DCM_CODE) Dcm_NetPeriodicMsgAllocate(uint16 Did)
{
  Dcm_CfgNetPTxObjHandleMemType perTxObjHandle = DCM_NET_INVALID_PTXOBJ_HANDLE;

  /* If all queued messages were sent, reset counters (continue with highest prio UUDT) */
  if(Dcm_NetPeriodicMsgGetNextMsgHdl() == Dcm_NetPeriodicMsgGetTxObjectSentCntr())
  {
    /* Note: No critical section needed to avoid interrupt by Dcm_NetPeriodicMsgRelease because at this point, all
     *       messages are already sent and so no more notification interrupt can occur */
    Dcm_NetPeriodicMsgResetNextMsgHdl();
    Dcm_NetPeriodicMsgResetTxObjectSentCntr();
  }

  /* If there is a message ID left that has a lower priority: */
  if(Dcm_NetPeriodicMsgGetNextMsgHdl() < Dcm_NetPeriodicMsgNumMsgsCurrConnection())
  {
    Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

    perTxObjHandle = (Dcm_CfgNetPTxObjHandleMemType)Dcm_NetPeriodicMsgGetNextMsgHdl();
    pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(perTxObjHandle);
    pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_RESERVED; /* Mark tx object as reserved */                                                     /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
    pPeriodicTxObj->Did = Did; /* Store the DID */                                                                                                   /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
    Dcm_NetPeriodicMsgIncNextMsgHdl(); /* Increment message handle for next message */                                                               /* PRQA S 3109, 3355, 3358 */ /* MD_Dcm_CfgDepend_3109, MD_Dcm_3355, MD_Dcm_3358 */
  }

  return perTxObjHandle;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgRelease()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgRelease(Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj)
{
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  if (pPeriodicTxObj->State == DCM_NET_PERIODIC_TX_STATE_ONTX)
  {
    Dcm_NetPTxDelayTimerStart(); /* start delay timer */
  }
# endif

  Dcm_NetPTxObjTimerStop(pPeriodicTxObj);                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_FREE;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */

  Dcm_NetPeriodicMsgIncTxObjectSentCntr(); /* Update sent message statistics */
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmit(Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
                                                         ,PduLengthType length)
{
  PduLengthType lLength = length;
  Dcm_DebugAssert((Dcm_NetPeriodicMsgGetConnection() < DCM_NET_INVALID_CONNID), DCM_SID_INTERNAL, DCM_E_PARAM)                                       /* COV_DCM_RTM_DEV_DEBUG XF */

# if (DCM_NET_PERIODIC_MSG_PADDING_ENABLED == STD_ON)
#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(Dcm_PbCfgNetConnectionInfo[Dcm_NetPeriodicMsgGetConnection()].UudtFrameSize > DCM_NET_PERIODIC_BUFFER_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETPERIODICMSGTRANSMIT);
  }
  else
#  endif
  {
    for(; lLength < Dcm_PbCfgNetConnectionInfo[Dcm_NetPeriodicMsgGetConnection()].UudtFrameSize; lLength++)
    {
      pPeriodicTxObj->TxBuffer[lLength] = DCM_NET_PERIODIC_MSG_PADDING_PATTERN;                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
# endif
  pPeriodicTxObj->TxPduInfo.SduLength = lLength;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_QUEUED;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_UUDT);
}
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetProvideRxBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetProvideRxBuffer(PduIdType DcmRxPduId
                                                              ,PduLengthType TpSduLength
                                                              ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) *PduInfoPtr
                                                              ,Dcm_NetTransportObjectFlagType addTObjFlags)
{
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK;
  Dcm_NetConnRefMemType lConnId = Dcm_NetGetConnIdOfRxPduId(DcmRxPduId);

  /* #10 If the communication state allows any diagnostic request reception (at least SilentCommunicationMode): */
  if( ((DCM_NET_COMM_STATE_FLAG_RX_EN & Dcm_NetGetComStateByConnection(lConnId)) != 0)
# if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
      && (Dcm_SingletonContext.Network.RxAllowed == TRUE)
# endif
      )
  {
    Dcm_NetTransportObjectPtrType pTranspObj;

    /* #20 Enter critical section (Reason: Needed only on multi-channel DCM configurations to guarantee the correct
     * transport object allocation and initialization) */
    Dcm_NetMultiChannelEnterCS();                                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    /* #30 Allocate new or get existing, already associated with this DcmRxPduId transport object */
    pTranspObj = Dcm_NetAllocateOrGetTranspObjectOrNull(lConnId);

    /* #40 If allocation or getter succeeded: */
    if(pTranspObj != NULL_PTR)
    {
      /* #50 If the transport object is allocated as a new one: */
      if(pTranspObj->State == DCM_NET_TOBJ_STATE_FREE)
      {
        Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

        pTranspObj->BufferHdl = Dcm_NetGetProtObjOfConnection(lConnId)->RxTxBufferRef;                                                               /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

        /* #60 If the request message length fits the Rx-buffer associated with the DcmRxPduId: */
        if(TpSduLength <= lBufferInfo->Size)
        {
          Dcm_NetBufferContextPtrType pBufferContext;

          /* #70 Prepare for positive result or NRC 0x21 response: */
          pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

          /* Store relevant information for later use */
          pTranspObj->RxPduId = DcmRxPduId;                                                                                                          /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->ConnId  = (Dcm_NetConnRefMemType)lConnId;                                                                                      /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->BuffPos = 0u;                                       /* start writing from the buffer begin */                                  /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->State   = DCM_NET_TOBJ_STATE_ONRX;                                                                                             /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

          /* #80 If the new request can be received - that is: */
          if( Dcm_NetBufferIsFree(pBufferContext) /* Buffer is free */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
            &&( ((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) != 0) /* a default session is/will be active */
              || (Dcm_NetGetSessionConnection() == lConnId) /* the owner of the (non-default) session */
#  if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
              || (Dcm_NetGetProtObjOfConnection(lConnId)->Priority
                < Dcm_NetGetProtObjOfConnection(Dcm_NetGetSessionConnection())->Priority ) /* higher priority -> let it through */
#  endif
              )
# endif
            )
          {
            /* #90 Lock the buffer and allow further request reception */
            Dcm_NetBufferLock(pBufferContext); /* the buffer is in use now */                                                                        /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
            /* Report available buffer */
            pTranspObj->BuffInfo.SduDataPtr = lBufferInfo->BufferPtr;                                                                                /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            pTranspObj->BuffInfo.SduLength  = lBufferInfo->Size;                                                                                     /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            pTranspObj->Flags = addTObjFlags;                                                                                                        /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            lResult = BUFREQ_OK;
          }
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
          else
          {
            /* #100 Otherwise, prepare for pseudo request reception (only SID and sub-function will be copied)
             * (if multiple client environment enabled) */
            /* offset=1, so SID and SUBSID are written to the correct position */
            pTranspObj->BuffInfo.SduDataPtr = &(pTranspObj->AddBuffer[1]);                                                                           /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            pTranspObj->BuffInfo.SduLength  = 7u;                                                                                                    /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            /* no free "real buffer" object - ignore or simulate reception for NRC 0x21 */
            pTranspObj->Flags = (Dcm_NetTransportObjectFlagType)(addTObjFlags | DCM_NET_TOBJ_FLAG_BUSY | DCM_NET_TOBJ_FLAG_IGNORE);                  /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            lResult = BUFREQ_OK;
          }
# endif
        }
        else
        {
          /* #110 Otherwise, reject the message reception with the result "message too long" */
          lResult = BUFREQ_E_OVFL;
        }

        /* #120 If the message reception is to be continued, register the client connection as active  */
        if(lResult == BUFREQ_OK)
        {
          pTranspObj->RxData   = pTranspObj->BuffInfo.SduDataPtr;                                                                                    /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          /* safe cast, since tpSduLength <= bufferSize = value fits Dcm_CfgNetBufferSizeMemType */
          pTranspObj->RxLength = (Dcm_CfgNetBufferSizeMemType)TpSduLength;                                                                           /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          *PduInfoPtr = &pTranspObj->BuffInfo;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_NetRegisterActiveConnection(pTranspObj);                                                                                               /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        }
        else
        {
          /* #130 Otherwise, release the allocated transport object */
          Dcm_NetTranspObjRelease(pTranspObj);/* no further processing needed */                                                                     /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        }
      }
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      else
      {
        /* #150 If parallel reception is in progress, continue to use temporary buffer */
        if ( (pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX) &&
             (pTranspObj->RxPduId == DcmRxPduId) &&
             ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) != 0) )
        {
          /* offset=3, so received SID is left in byte[1], SubSID in byte[2]; received data will be discarded anyway */
          pTranspObj->BuffInfo.SduDataPtr = &(pTranspObj->AddBuffer[3]);                                                                             /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->BuffInfo.SduLength  = 7u;                                                                                                      /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          lResult = BUFREQ_OK;
        } /* #160 Otherwise, reception is neither real nor simulated - ignore reception */
      }
# endif
    }/* #170 Otherwise, no free transport object found (more clients than transport objects configured, legal use case
      * to save resources) - reject the message reception */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* #180 Leave critical section */
    Dcm_NetMultiChannelLeaveCS();                                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
  } /* #190 Otherwise, reject the message reception */
  return lResult;
} /* Dcm_NetProvideRxBuffer */                                                                                                                       /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetSetComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetSetComModeEntered(NetworkHandleType networkId
                                                       ,Dcm_NetComMStateType newComState)
{
  /* used to always verify for valid parameter */
  sint16_least lDcmComMHandle = Dcm_UtiLookUpUint8(Dcm_PbCfgNetNetworkHdlLookUp, networkId);                                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  if(lDcmComMHandle >= 0) /* consider only DCM relevant channels */
  {
    Dcm_NetComMContextPtrType pComMContext;

    pComMContext = Dcm_NetGetComMContext((Dcm_CfgNetNetIdRefOptType)lDcmComMHandle);

    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pComMContext->ComState = newComState;                                                                                                            /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }/* else - not a DCM channel -> ignore */
}

/**********************************************************************************************************************
 *  Dcm_NetStartOfReception()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetStartOfReception(PduIdType rxPduId
                                                           ,PduLengthType tpSduLength
                                                           ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
                                                           ,Dcm_NetTransportObjectFlagType addTObjFlags)
{
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK;
  Dcm_NetConnRefMemType lConnId = Dcm_NetGetConnIdOfRxPduId(rxPduId);

  /* #10 If the communication state allows any diagnostic request reception (at least SilentCommunicationMode): */
  if( ((DCM_NET_COMM_STATE_FLAG_RX_EN & Dcm_NetGetComStateByConnection(lConnId)) != 0)
# if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
    &&(Dcm_SingletonContext.Network.RxAllowed == TRUE)
# endif
    )
  {
    Dcm_NetTransportObjectPtrType pTranspObj;

    /* #20 Enter critical section (Reason: Needed only on multi-channel DCM configurations to guarantee the correct
     * transport object allocation and initialization) */
    Dcm_NetMultiChannelEnterCS();                                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    /* #30 Allocate new or get existing, already associated with this DcmRxPduId transport object */
    pTranspObj = Dcm_NetAllocateOrGetTranspObjectOrNull(lConnId);

    /* #40 If allocation or getter succeeded: */
    if(pTranspObj != NULL_PTR)
    {
      /* #50 If the transport object is allocated as a new one: */
      if(pTranspObj->State == DCM_NET_TOBJ_STATE_FREE)
      {
        Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

        pTranspObj->BufferHdl = Dcm_NetGetProtObjOfConnection(lConnId)->RxTxBufferRef;                                                               /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

        /* #60 If the request message length fits the Rx-buffer associated with the DcmRxPduId: */
        if(tpSduLength <= lBufferInfo->Size)
        {
          Dcm_NetBufferContextPtrType pBufferContext;

          /* #70 Prepare for positive result or NRC 0x21 response: */
          pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
          /* Prepare result to be reported for the available Rx-buffer size */
          *bufferSizePtr = lBufferInfo->Size;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */

          /* Initialize the transport object */
          pTranspObj->RxPduId  = rxPduId;                                                                                                            /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->ConnId   = (Dcm_NetConnRefMemType)lConnId;                                                                                     /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

          /* Set up Rx message context */
          pTranspObj->RxLength = (Dcm_CfgNetBufferSizeMemType)tpSduLength;/* safe cast, since tpSduLength <= bufferSize = value fits Dcm_CfgNetBufferSizeMemType */ /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->BuffPos  = 0u; /* start writing from the buffer begin */                                                                       /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->State    = DCM_NET_TOBJ_STATE_ONRX;                                                                                            /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->Flags    = addTObjFlags;                                                                                                       /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

          /* #80 If the new request can be received - that is: */
          if( Dcm_NetBufferIsFree(pBufferContext) /* Is the buffer free? */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
            &&( ((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) != 0) /* a default session is/will be active */
              || (Dcm_NetGetSessionConnection() == lConnId) /* the owner of the (non-default) session */
#  if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
              || (Dcm_NetGetProtObjOfConnection(lConnId)->Priority
                < Dcm_NetGetProtObjOfConnection(Dcm_NetGetSessionConnection())->Priority ) /* higher priority -> let it through */
#  endif
              )
# endif
            )
          {
            /* #90 Lock the buffer and allow further request reception */
            pTranspObj->RxData = lBufferInfo->BufferPtr;                                                                                             /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            Dcm_NetBufferLock(pBufferContext); /* the buffer is in use now */                                                                        /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
            lResult = BUFREQ_OK;
          }
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
          else
          {
            /* #100 Otherwise, prepare for pseudo request reception (only SID and sub-function will be copied) (if multiple client environment enabled) */
            pTranspObj->RxData = &pTranspObj->AddBuffer[1];                                                                                          /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            /* no free "real buffer" object - ignore or simulate reception for NRC 0x21 */
            pTranspObj->Flags |= (Dcm_NetTransportObjectFlagType)(DCM_NET_TOBJ_FLAG_BUSY | DCM_NET_TOBJ_FLAG_COPYHEAD | DCM_NET_TOBJ_FLAG_IGNORE);   /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            lResult = BUFREQ_OK;
          }
# endif
        }
        else
        {
          /* #110 Otherwise, reject the message reception with the result "message too long" */
          lResult = BUFREQ_E_OVFL;
        }

        /* #120 If the message reception is to be continued, register the client connection as active  */
        if(lResult == BUFREQ_OK)
        {
          Dcm_NetRegisterActiveConnection(pTranspObj);                                                                                               /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        }
        else
        {
          /* #130 Otherwise, release the allocated transport object */
          Dcm_NetTranspObjRelease(pTranspObj);/* no further processing needed */                                                                     /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        }
      }/* #140 Otherwise, the transport object is already in use (i.e. parallel request from the same tester):
        *   - reject the message reception */
    }/* #150 Otherwise, no free transport object found (more clients than transport objects configured, legal use case
      * to save resources) - reject the message reception */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* #160 Leave critical section */
    Dcm_NetMultiChannelLeaveCS();                                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
  } /* #170 Otherwise, reject the message reception */
  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferExecute()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferExecute(Dcm_DiagDataContextPtrType      pDataContext
                                                               ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  DCM_UTI_LOOP_FOR_EVER
  {
    Dcm_DiagSvcUpdateFuncType pUpdateFunc;

    pUpdateFunc = Dcm_DiagGetUpdateFunc(Dcm_InstanceContext.PagedBuffer.UpdateFuncRef);

    /* Delegate to the page writer */
    lStdResult = pUpdateFunc(Dcm_InstanceContext.PagedBuffer.OpStatus
                            ,pDataContext
                            ,ErrorCode);                                                                                                             /* SBSW_DCM_CALL_FUNCPTR_SVCUPDATERS */

    if(lStdResult != DCM_E_LOOP)
    {
      break;
    }/* else - just loop again */

    Dcm_InstanceContext.PagedBuffer.OpStatus = DCM_INITIAL;

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING_LIMITER) /* signal retry */                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  return lStdResult;
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferCancel(Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lResult = DCM_E_OK;
  Dcm_DiagDataContextType       lDataContext;
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

  /* If page buffer is currently activated: */
  if(Dcm_InstanceContext.PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE)
  {
    /* If not all data was written by the application: */
    if(Dcm_InstanceContext.PagedBuffer.UpdateFinished == FALSE)
    {
      /* Notify the application about the cancellation */
      Dcm_DiagSvcCancelFuncType lCancelFunc = Dcm_DiagGetCancelFunc(Dcm_InstanceContext.PagedBuffer.CancelFuncRef);

      /* Initialize the data context */
      lBufferInfo = Dcm_NetGetBufferInfo(Dcm_InstanceContext.PagedBuffer.BufferHdl);
      Dcm_DiagInitDataContext(&lDataContext, lBufferInfo->BufferPtr, lBufferInfo->Size);                                                             /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

      lCancelFunc(&lDataContext);                                                                                                                    /* SBSW_DCM_CALL_FUNCPTR_SVCCANCELLERS */ /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
    }

    /* If no transmission was started yet: */
    if(Dcm_InstanceContext.PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)                                                                     /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
    {
      /* Send the appropriate NRC by using the linear buffer if needed */
      *ErrorCode = DCM_DIAG_CANCEL_OP_NRC;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = DCM_E_NOT_OK;
    }

    /* Reset page buffer state */
    Dcm_PagedBufferInit();
    /* Clear any pending events in the Dcm_PagedBufferTask() to avoid any further processing */
    Dcm_TskClrEvent(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_ALL_EVENTS);
  }

  return lResult;
}
#endif /* (DCM_PAGED_BUFFER_ENABLED == STD_ON) */

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferTask(Dcm_TskTaskEvOptType ev
                                                  ,Dcm_TskTaskEvPtrType pPostEv)
{
  Std_ReturnType               lStdResult;
  Dcm_NetBufferContextPtrType  pBufferContext;
  Dcm_NegativeResponseCodeType lNrc;

  DCM_IGNORE_UNREF_PARAM(ev);                                                                                                                        /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* currently no other events are possible to be set for this task -> no need to check any flags */
# if (DCM_TSK_EV_PGDBUF_MSB != 0x01u)
#  error "New events have been added Dcm_PagedBufferTask! Make set event check here!"
# endif

  pBufferContext = Dcm_NetGetBufferContext(Dcm_InstanceContext.PagedBuffer.BufferHdl);

  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* If any diagnostic job is open: */
  if( ((Dcm_InstanceContext.Diag.State & (DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX)) != 0)
    && (!Dcm_NetBufferIsFree(pBufferContext)) )                                                                                                      /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX tx tx */
  {
    /* Avoid buffer releasing on asynchronous TxConfirmation with failed status */
    Dcm_NetBufferUsageEnter(pBufferContext);                                                                                                         /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* Update paged data */
    lStdResult = Dcm_PagedBufferUpdatePage(&lNrc);                                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */

    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_NetBufferUsageLeave(pBufferContext);                                                                                                         /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */

    /* If the application needs more time: */
    if(lStdResult == DCM_E_PENDING)
    {
      /* If the paged-buffer was not the last user, try getting data again */
      if(!Dcm_NetBufferIsFree(pBufferContext))                                                                                                       /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
      {
        Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_PGDBUF_UPDATE_PAGE);                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
      }/* else - buffer is free - no more data is to be expected */
    }/* else - that is all */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if (lStdResult == DCM_E_NOT_OK)
    {
      Dcm_SetNegResponse(lNrc);
      Dcm_ProcessingDone();
    }
  }
  else
  {
   /*=================================*
    END CRITICAL SECTION
    *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferStart(Dcm_MsgLenType resDataLen)
{
  /* Once multiple multi frame response started, can not be started again */
  Dcm_DebugAssert((Dcm_InstanceContext.PagedBuffer.State == DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                  /* COV_DCM_RTM_DEV_DEBUG XF */
  /* No multiple multi frame response if a NRC has been already registered */
  Dcm_DebugAssert((Dcm_InstanceContext.Diag.ErrorRegister == DCM_E_OK), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                       /* COV_DCM_RTM_DEV_DEBUG XF */

  /*  Initialize paged-buffer response transmission */
  Dcm_InstanceContext.PagedBuffer.UpdateFuncRef  = Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].UpdateFuncRef;
  Dcm_InstanceContext.PagedBuffer.CancelFuncRef  = Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].CancelFuncRef;
  Dcm_InstanceContext.PagedBuffer.BufferHdl      = Dcm_DiagGetTranspObj()->BufferHdl;
  Dcm_InstanceContext.PagedBuffer.WriteIndex     = (Dcm_CfgNetBufferSizeMemType)(Dcm_InstanceContext.Diag.MsgContext.resDataLen
                                                                               + Dcm_InstanceContext.Diag.MsgContext.resProtHeadLen); /* Write behind SID and the prepared data */
  Dcm_InstanceContext.PagedBuffer.ReadIndex      = 0u;
  Dcm_InstanceContext.PagedBuffer.RemainingLen   = resDataLen; /* Keep track of response data to be copied */
  Dcm_InstanceContext.PagedBuffer.State          = DCM_PAGEDBUFFER_STATE_ACTIVATED;
  Dcm_InstanceContext.PagedBuffer.UpdateFinished = FALSE;
  Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState = DCM_PAGEDBUFFER_WAIT_FOR_DATA;
  Dcm_InstanceContext.PagedBuffer.OpStatus       = DCM_INITIAL;

  /*  Calculate total response length, considering any already linearly written data */
  Dcm_InstanceContext.Diag.MsgContext.resDataLen += (Dcm_MsgLenType)resDataLen;

  /*  Initiate paged-data reader */
  Dcm_TskSetEvent(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE);
}
#endif
/**********************************************************************************************************************
 *  Dcm_RepeaterExecute()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_RepeaterExecute(Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

#if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  /* make a backup in case the processor uses the Dcm_RepeaterSetCallee API */
  Dcm_OpStatusType opStatusBckp = Dcm_InstanceContext.Repeater.Contexts.OpStatus;
#endif

  DCM_UTIRTLMTR_CTR_INIT
  DCM_UTI_LOOP_FOR_EVER
  {
    Dcm_CfgDiagServiceInfoPtrType pServiceInfo;

    pServiceInfo = Dcm_CfgDiagServiceInfoGetEntryOrNull(Dcm_InstanceContext.Repeater.CalleeIdx);

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    if (pServiceInfo == NULL_PTR)                                                                                                                    /* COV_DCM_RTM_RUNTIME_CHECK XF */
    {
      *ErrorCode = DCM_E_PANIC_NRC;/* always return the panic NRC! */                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;/* enforce finalization  (allows post-handling and thus resource release event */
    }
    else
#endif
    {
#if (DCM_DIAG_SERVICE_DISPATCHER_ENABLED == STD_ON)
      if(Dcm_InstanceContext.Diag.ProcessServiceExtern == TRUE)
      {
        lStdResult = pServiceInfo->AltProcFunc(Dcm_InstanceContext.Repeater.Contexts.OpStatus
                                              ,&Dcm_InstanceContext.Diag.MsgContext
                                              ,ErrorCode);                                                                                           /* SBSW_DCM_CALL_FUNCPTR_SERVICEINFO */
      }
      else
#endif
      {
        lStdResult = pServiceInfo->ProcFunc(Dcm_InstanceContext.Repeater.Contexts.OpStatus
                                           ,&Dcm_InstanceContext.Diag.MsgContext
                                           ,ErrorCode);                                                                                              /* SBSW_DCM_CALL_FUNCPTR_SERVICEINFO */
      }
    }
#if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatusBckp == DCM_CANCEL)
    {
# if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
      if(Dcm_InstanceContext.Repeater.Contexts.User == DCM_REPEATER_USER_DEM)
      {
        Dcm_DemAPI_CancelOperation();/* signal to DEM not to expect any further calls */
      }
# endif
# if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
      Dcm_DidMgrCancelOperation();
# endif
      *ErrorCode = DCM_DIAG_CANCEL_OP_NRC;/* always return the cancellation NRC! */                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;/* enforce finalization */
    }
#endif
    if(lStdResult != DCM_E_LOOP)
    {
      break;
    }/* else - just loop again */

    Dcm_RepeaterResetOpStatus();

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING_LIMITER) /* signal retry */                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  return lStdResult;
}
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODEMGR_MONITORING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeTaskMonitor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeTaskMonitor(Dcm_TskTaskEvOptType ev
                                                  ,Dcm_TskTaskEvPtrType pPostEv)
{
#  if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
  /* If activated, monitor DTCsetting related mode-rule fulfillment */
  if( Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_MODE_MON_SVC85) )
  {
    Dcm_ModeMonitorControlDtcSetting(pPostEv);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#  endif

#  if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
  /* If activated, monitor CommunicationControl related mode-rule fulfillment */
  if( Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_MODE_MON_SVC28) )
  {
    Dcm_ModeMonitorCommunicationControl(pPostEv);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#  endif
}
# endif

# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchDtcSetting(Rte_ModeType_DcmControlDtcSetting newMode
                                                       ,uint32                            DTCGroup
                                                       ,uint8                             DemClientId)
{
  Std_ReturnType lStdResult;

  /* execute transition */
  lStdResult = Rte_Switch_DcmControlDtcSetting_DcmControlDtcSetting(newMode);

  DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(DTCGroup);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(DemClientId);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

  /* Update local states */
  Dcm_ModeSetControlDtcSettingGroup(DTCGroup);
  Dcm_ModeSetControlDtcSettingMode(newMode);

#  if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
  if(newMode == RTE_MODE_DcmControlDtcSetting_DISABLEDTCSETTING)
  {
#   if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
    Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID = DemClientId;
#   endif
    Dcm_TskSetEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC85);
  }
  else
  {
    Dcm_TskClrEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC85);
  }
#  endif
}
# endif

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchCommControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchCommControl(Dcm_CfgNetNetIdRefOptType networkRef
                                                        ,Dcm_CommunicationModeType newMode)
{
  NetworkHandleType lNetwork = Dcm_PbCfgNetAllComMChannelMap[networkRef];

  Dcm_ModeArEnvBswMComControlModeChange(lNetwork, newMode);/* notify BswM */
  Dcm_ModeOnComControlModeChange(lNetwork, Dcm_ModeComCtrlModeMap[newMode]); /* notify the application */

  Dcm_ModeSetCommControlState(networkRef, newMode);

#  if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
  if((newMode & DCM_SVC_28_CTRL_OP_MASK) != 0)/* operation is with any disabling */
  {
    Dcm_TskSetEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC28);
  }
  else
  {
    Dcm_TskClrEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC28);
  }
#  endif
}
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_StateCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_StateCheck(Dcm_CfgStateRefOptType stateRef
                                                       ,Dcm_DiagCheckLvlType chkLevel
                                                       ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdReturn;

  /* Get the precondition package for the related diagnostic entity */
  CONSTP2CONST(Dcm_CfgStateDiagStateInfoType, AUTOMATIC, DCM_CONST) pStatePreconditions = &Dcm_StateGetPreconditionStates(stateRef);

  /* First verify the diagnostic session pre-condition (UDS verification order) */
  if(!Dcm_StateIsSupportedInSession(*pStatePreconditions))                                                                                           /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
  {
    /* If not met, return appropriate to UDS NRC for the evaluated diagnostic entity (i.e. NRC 0x7F for services, 0x7E for sub-functions etc.) */
    *ErrorCode = Dcm_StateSessionNrcs[chkLevel];                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  /* Otherwise, if supported, verify the security access level pre-condition (UDS verification order) */
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(!Dcm_StateIsSupportedInSecurityLevel(*pStatePreconditions))
  {
    /* If not met, do return NRC 0x33 (UDS) */
    *ErrorCode = DCM_E_SECURITYACCESSDENIED;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
#endif
  {
#if(DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
    /* Otherwise, if supported, get the the mode-related pre-condition expression(s) result */
    lStdReturn = Dcm_ModeCheck(Dcm_CfgStatePreconditions[stateRef].ModeRuleRef, ErrorCode);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
#else
    /* Otherwise, everything fine - return positive response code */
    lStdReturn = DCM_E_OK;
#endif
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_StateSetSession()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSession(Dcm_StateIndexOptType stateRef)
{
  Std_ReturnType lStdResult;

#if (DCM_SVC_86_RST_ON_DSC_ENABLED == STD_ON) || \
    (DCM_STATE_SESSION_NOTIFICATION_ENABLED == STD_ON)
  Dcm_CfgStateGroupOptType oldSession;

  oldSession = Dcm_SingletonContext.StateMgr.Preconditions.Session;
#endif

  /* #10 Commit the new diagnostic session */
  Dcm_SplitTaskEnterCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_SingletonContext.StateMgr.Preconditions.Session = Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, stateRef);
  Dcm_StateSyncPendingSession();
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* #20 Notify application for a diagnostic session transition (also for self-transitions e.g. Default->Default): */
  lStdResult = Rte_Switch_DcmDiagnosticSessionControl_DcmDiagnosticSessionControl(Dcm_CfgStateSessionInfo[stateRef].Mode);

  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK),DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

#if (DCM_STATE_SESSION_NOTIFICATION_ENABLED == STD_ON)
  Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateSessionNotificationInfo, Dcm_StateGetSessionValue(Dcm_UtiGetBitPosition(oldSession)), Dcm_StateGetSessionValue(stateRef)); /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
#endif

  /* #30 If the new session is the default one, reset all related internally handled diagnostic jobs (order irrelevant): */
  if(Dcm_StateIsDefaultSessionActive())
  {
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
    if(Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
    {
      Dcm_NetUnRegisterAllComMActivity();
    }

#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
    /* fire and forget */
    (void)Dcm_Svc85EnableDtcSetting(Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID);
#endif
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc28EnableCommunication();
#endif
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc2ASchdStopAll();
#endif
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc2FReturnControlToEcu();
#endif
  }

  /* #40 On any diagnostic session transition (order irrelevant): */
#if (DCM_SVC_86_RST_ON_DSC_ENABLED == STD_ON)
  /* Notify the diagnostic service 0x86 processor (if diagnostic service 0x86 is handled by DCM) */
  Dcm_ExtSvc86OnChangeSession(oldSession, Dcm_SingletonContext.StateMgr.Preconditions.Session);
#endif

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  /* Reset the security access level back to "locked" (if diagnostic service 0x27 is supported by the ECU configuration) */
  Dcm_StateSetSecurity(0);
#else
  /* Notify all service processors that are interested in a state change */
  Dcm_StateNotifyServiceProcessors();
#endif
  DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateSetSecurity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSecurity(Dcm_StateIndexOptType stateRef)
{
# if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON) || \
     (DCM_STATE_SECURITY_NOTIFICATION_ENABLED == STD_ON)
  Dcm_CfgStateGroupOptType oldLevel;
# endif

# if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON) || \
     (DCM_STATE_SECURITY_NOTIFICATION_ENABLED == STD_ON)
  oldLevel = Dcm_SingletonContext.StateMgr.Preconditions.Security;
# endif
  /* #10 Commit the new security access level */
  Dcm_SingletonContext.StateMgr.Preconditions.Security = Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, stateRef);

  /* #20 Notify application for a security access level transition (only for non-self-transitions e.g. Locked->Level1): */
# if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON) || \
     (DCM_STATE_SECURITY_NOTIFICATION_ENABLED == STD_ON)
  if((oldLevel & Dcm_SingletonContext.StateMgr.Preconditions.Security) == 0) /* consider only non-self transitions (i.e. Locked->Locked) */
  {
#  if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON)
    Std_ReturnType                 lStdResult;
    Rte_ModeType_DcmSecurityAccess newMode;

    newMode = (Rte_ModeType_DcmSecurityAccess)((stateRef == 0)?RTE_MODE_DcmSecurityAccess_LockedLevel
                                                              :Dcm_CfgStateSecurityInfo[stateRef - 1].Mode);

    /* Notify application */
    lStdResult = Rte_Switch_DcmSecurityAccess_DcmSecurityAccess(newMode);

    DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */
    Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
#  endif

#  if (DCM_STATE_SECURITY_NOTIFICATION_ENABLED == STD_ON)
    {
      Dcm_SecLevelType secLev = Dcm_UtiGetBitPosition(oldLevel); /* Local variable needed to avoid warnings for side-effects on macro Dcm_StateGetSecurityValue() */
      Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateSecurityNotificationInfo, Dcm_StateGetSecurityValue(secLev), Dcm_StateGetSecurityValue(stateRef));  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    }
#  endif
  }
# endif
  /* Notify all service processors that are interested in a state change */
  Dcm_StateNotifyServiceProcessors();
}
#endif
/**********************************************************************************************************************
 *  Dcm_TskScheduler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TskScheduler(Dcm_TskTaskPrioMemType tskPrio)
{
  Dcm_TskSchedulerContextPtrType pSchedulerContext;

  pSchedulerContext = Dcm_TskGetSchedulerContextOrNull(tskPrio);

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSchedulerContext != NULL_PTR)                                                                                                                 /* COV_DCM_RTM_RUNTIME_CHECK TX */
#endif
  {
    if(pSchedulerContext->SchdIsActive == TRUE)
    {
      Dcm_TskTaskIdOptType taskIter;
      Dcm_TskTaskEvOptType ev;

      /*
       * No interrupt protection needed since:
       * If a SetEvent is called and interrupts this assignment, then it sets this flag to true. Two scenarios are possible:
       * - The TRUE signal may be gone - it does not matter since the scheduler is already activated.
       * - The TRUE signal remains - in the worst case the scheduler will be executed once more later but will not have any active tasks.
       */
      pSchedulerContext->SchdIsActive = FALSE; /* per default - no active tasks any more. If any SetEvent executed during the task execution -> the flag will be set again */ /* SBSW_DCM_POINTER_WRITE_SCHEDULERCONTEXT */

      for(taskIter = 0; taskIter < DCM_TSK_NUM_TASKS; ++taskIter)
      {
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
        if(tskPrio == Dcm_TskTaskInfo[taskIter].TskPrio)
#endif
        {
          ev = Dcm_TskGetEvent(taskIter);
          if(ev != DCM_TSK_EV_NONE)
          {
            Dcm_TskExecuteActiveTask(taskIter, ev);
          }
        }
      }
    }
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
/**********************************************************************************************************************
 *  Dcm_TmrTaskTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TmrTaskTimer(Dcm_TskTaskEvOptType ev
                                               ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TmrMaskOptType    expiredTimers = 0u;
  Dcm_TmrTimerIdOptType timerIter;

#if (DCM_TSK_EV_TIMER_MSB != 0x01u)
# error "New events have been added for Dcm_TmrTaskTimer! Make set event check here!"
#endif
  /* the only event here is the DCM_TSK_EV_TIMER_ACTIVE. If not set, this task will not be called -> no additional event check is necessary */
  DCM_IGNORE_UNREF_PARAM(ev);                                                                                                                        /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Iterate over all system timers: */
  for(timerIter = 0; timerIter < DCM_TMR_NUM_TIMERS_CASTED; ++timerIter)
  {
    expiredTimers <<=1; /* next timer */
    /* If a timer is active (not yet expired or stopped), update its counter (decrement by one) */
    if(Dcm_TmrIsTimerRunning(timerIter))
    {
      Dcm_TmrSetTimer(timerIter, (Dcm_TmrTimerCntrMemType)(Dcm_TmrGetTimer(timerIter) - 1u));
      if(Dcm_TmrGetTimer(timerIter) == 0u)
      {
        /* If the concrete timer did expire with the above step, register the timerId for later processing */
        expiredTimers |= 0x01u;
        Dcm_TmrSetTimerStopped(timerIter);                                                                                                           /* PRQA S 0290 */ /* MD_Dcm_BitNegation_0290 */
      }
      else
      {
        /* Otherwise, signal reactivation of this task again at next main-function cycle, since at least one timer still active */
        *pPostEv |= DCM_TSK_EV_TIMER_ACTIVE;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  /* Leave critical section */
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* Iterate over all expired timers only: */
  DCM_UTI_LOOP_BIT_SCAN(expiredTimers)
  {
    --timerIter; /* pre-decrement since the iterator equals at first DCM_TMR_NUM_TIMERS_CASTED */
    if(Dcm_UtiBitOpTest(Dcm_TmrMaskOptType, expiredTimers, 0x01u))
    {
      Dcm_TmrTimerInfoPtrType lTimerInfo;

      lTimerInfo = Dcm_TmrGetTimerInfoOrNull(timerIter);

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if(lTimerInfo != NULL_PTR)                                                                                                                     /* COV_DCM_RTM_RUNTIME_CHECK TX */
#endif
      {
        /* Invoke the associated with the timer "Dcm_OnTimeout*" handler function */
        Dcm_TmrTimerCntrMemType reloadTicks = lTimerInfo->ToFunc();                                                                                  /* SBSW_DCM_CALL_FUNCPTR_TIMERINFO */
        if(reloadTicks != 0)                                                                                                                         /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
        {
          /* If the handler requires an immediate reload of the timer, activate the timer immediately */
          Dcm_TmrStartTimer(timerIter, reloadTicks);
        }
      }
    }
  }
}
#if (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_RETVAL_TO_NRC_MAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiGetNrcForDemRetValue()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DemApiGetNrcForDemRetValue(uint8 demResult, Dcm_Uint8ConstDataPtrType demResult2NrcMap)
{
  Dcm_NegativeResponseCodeType lNrcResult = DCM_E_PANIC_NRC;

  /* Iterate over the "DEM result to NRC" using increment by two to visit each <key,value> pair */
  while(demResult2NrcMap[0] != E_OK) /*lint !e661 !e662 The EOM (EndOfMap) is marked by E_OK, since only negative results shall be used for mapping to NRC */
  {
    /* If a match is found, return the associated NRC */
    if(demResult2NrcMap[0] == demResult)
    {
      lNrcResult = demResult2NrcMap[1]; /*lint !e661 while-do loop prevents from out-of-bounds access */
      break;
    }
    /* Otherwise return the panic NRC */

    /* Increment by two for next map entry */
    demResult2NrcMap = &demResult2NrcMap[2]; /*lint !e662 while-do loop prevents from out-of-bounds access */
  }

#  if(DCM_DEV_ERROR_REPORT == STD_ON)
  /* Check if the DEM has returned an unexpected value (i.e. default case in a switch-case dispatcher) */
  if(demResult2NrcMap[0] == E_OK) /*lint !e661 !e662 The EOM (EndOfMap) is marked by E_OK, since only negative results shall be used for mapping to NRC */
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
  }
#  endif

  /* Return final result (concrete or panic NRC) */
  return lNrcResult;
}
# endif

# if (DCM_DEMAPI_GETNEXTFILTEREDITEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiConvDemRsltGetNextFilteredItem()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DemApiConvDemRsltGetNextFilteredItem(
                                                                         Dcm_DemReturnGetNextFilteredItemType demResult
                                                                        ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lDcmResult;
  switch(demResult)
  {
  case DCM_DEM_RET_FILTERED_NO_ITEMS:
    /* If no more items to be reported, signal data ready with eventual data padding */
    lDcmResult = DCM_E_DATA_READY_PADDING; /* signal end of list */
    break;
  case DCM_DEM_RET_FILTERED_PENDING:
    /* If Dem cannot provide next filtered item immediately, signal a retry */
    lDcmResult = DCM_E_PENDING;/* signal end of list */
    break;
#  if defined(DCM_DEM_RET_FILTERED_BUFFER_TOO_SMALL)                                                                                                 /* COV_DCM_SUPPORT_RESTRICTED TX */
  case DCM_DEM_RET_FILTERED_BUFFER_TOO_SMALL:
    /* If Dem cannot provide the data due to a too low buffer allocation, signal buffer overrun */
    lDcmResult = DCM_E_BUFFERTOOLOW;
    break;
#  endif
  default:
    /* Any other Dem result is treated as an error, thus signal job closing with panic NRC */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);

    lDcmResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  }
  return lDcmResult;
}
# endif
#endif /* (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DIDMGR_DYNDID_DEEP_CHECK_ON_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDynDidStateCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDynDidStateCheck(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_DidMgrStaticDidStateCheck(Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext)->ExecCondRef, ErrorCode);                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)
  {
    if(Dcm_DidMgrIsOpSupported(Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)
                              ,DCM_DIDMGR_OP_DEFINE)) /* for DynDID check source states */
    {
      lStdResult = Dcm_Svc2CStateCheckSrcItems(Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)->OpRef, ErrorCode);                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }/* else - ErrorCode already set */

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *   Dcm_DidMgrDidHasLock()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_DidMgrDidHasLock(Dcm_DidMgrDidLockOwnerType owner)
{
  boolean     lResult = FALSE;
  uint8_least lIter;

  for(lIter = 0; lIter < DCM_DIDMGR_DID_LOCK_LIST_SIZE; ++lIter)
  {
    if(Dcm_InstanceContext.DidMgr.DidLockList[lIter].Owner == owner)
    {
      lResult = TRUE;
      break;
    }
  }

  return lResult;
}

/**********************************************************************************************************************
 *   Dcm_DidMgrDidIsFree()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_DidMgrDidIsFree(uint16 did)
{
  boolean      lResult = TRUE;
  uint8_least  lIter;

  for(lIter = 0; lIter < DCM_DIDMGR_DID_LOCK_LIST_SIZE; ++lIter)
  {
    if(Dcm_InstanceContext.DidMgr.DidLockList[lIter].Did == did)
    {
      lResult = FALSE;
      break;
    }
  }

  return lResult;
}

/**********************************************************************************************************************
 *   Dcm_DidMgrDidLock()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDidLock(uint16 did, Dcm_DidMgrDidLockOwnerType owner)
{
  Std_ReturnType lStdResult = DCM_E_PENDING;
  uint8_least    lIter;

  Dcm_DebugAssert((Dcm_DidMgrDidHasLock(owner) == FALSE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                     /* COV_DCM_RTM_DEV_DEBUG XF */

  if(Dcm_DidMgrDidIsFree(did) == TRUE)
  {
    for(lIter = 0; lIter < DCM_DIDMGR_DID_LOCK_LIST_SIZE; ++lIter)
    {
      if(Dcm_InstanceContext.DidMgr.DidLockList[lIter].Owner == DCM_DIDMGR_DIDLOCK_OWNER_NONE)
      {
        Dcm_InstanceContext.DidMgr.DidLockList[lIter].Did   = did;                                                                                   /* SBSW_DCM_POINTER_WRITE_DIDLOCKLIST */
        Dcm_InstanceContext.DidMgr.DidLockList[lIter].Owner = owner;                                                                                 /* SBSW_DCM_POINTER_WRITE_DIDLOCKLIST */

        lStdResult = DCM_E_OK;
        break;
      }
    }

    /* Assert that DidLockList is large enough */
    Dcm_DebugAssert((lStdResult == DCM_E_OK), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                 /* COV_DCM_RTM_DEV_DEBUG XF */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *   Dcm_DidMgrDidRelease()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrDidRelease(Dcm_DidMgrDidLockOwnerType owner)
{
  uint8_least lIter;

  for(lIter = 0; lIter < DCM_DIDMGR_DID_LOCK_LIST_SIZE; ++lIter)
  {
    if(Dcm_InstanceContext.DidMgr.DidLockList[lIter].Owner == owner)
    {
      Dcm_InstanceContext.DidMgr.DidLockList[lIter].Did   = 0u;                                                                                      /* SBSW_DCM_POINTER_WRITE_DIDLOCKLIST */
      Dcm_InstanceContext.DidMgr.DidLockList[lIter].Owner = DCM_DIDMGR_DIDLOCK_OWNER_NONE;                                                           /* SBSW_DCM_POINTER_WRITE_DIDLOCKLIST */
      break;
    }
  }
}

# if (DCM_DIDMGR_CANCEL_OP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrCancelOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrCancelOperation(void)
{
  Dcm_DidMgrDidRelease(DCM_DIDMGR_DIDLOCK_OWNER_READONCE);
  Dcm_DidMgrDidRelease(DCM_DIDMGR_DIDLOCK_OWNER_WRITE);
  Dcm_DidMgrDidRelease(DCM_DIDMGR_DIDLOCK_OWNER_IO);
  /* readPeriodic and readDynamic have own cancellation mechanisms */
}
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrInitOpInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrInitOpInfo(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                   ,Dcm_DidMgrOpOptType             didOp)
{
  Dcm_DidMgrOpOptType lDidOp = didOp;

  pDidInfoContext->Descriptor.DidOpInfoIdx = Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)->OpBaseIdx;                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  /* 0x01 ->0x00 -> already found
   * 0x02 ->0x01 -> iterate once
   * .Etc */
  --lDidOp; /* there is always at least one operation configured */

  /* clear all flags above this operation index (not relevant) */
  lDidOp &= Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)->Operations;

  while(lDidOp != 0)
  {
    pDidInfoContext->Descriptor.DidOpInfoIdx++;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    lDidOp &= (Dcm_DidMgrOpOptType)(lDidOp - 1); /* clear the least significant bit set */
  }
}

/**********************************************************************************************************************
 *  Dcm_DidMgrInitOpClassInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrInitOpClassInfo(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                        ,Dcm_DidMgrOpCallOptType         opType)
{
  pDidInfoContext->Descriptor.DidOpClassInfoIdx = Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext)->OpTypeBaseIdx;                                         /* SBSW_DCM_PARAM_PTR_WRITE */

  /* 0x01 ->0x00 -> already found
   * 0x02 ->0x01 -> iterate once
   * .Etc */
  --opType; /* there is always at least one operation configured */

  /* clear all flags above this operation index (not relevant) */
  opType &= Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext)->CallTypes;

  while(opType != 0)
  {
    pDidInfoContext->Descriptor.DidOpClassInfoIdx++;                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    opType &= (Dcm_DidMgrOpOptType)(opType - 1); /* clear the least significant bit set */
  }
}

/**********************************************************************************************************************
 *  Dcm_DidMgrInitOpTypeHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrInitOpTypeHandler(Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                          ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)
{
  /* Number of operations to be iterated (number signals) */
  pDidOpTypeContext->Base.NumSignals = (Dcm_CfgDidMgrSignalIterMemType)
                                       ( Dcm_CfgDidMgrDidOpClassInfoGetEntry(pDidInfoContext->Descriptor.DidOpClassInfoIdx + 1)->OpClassRef
                                       - Dcm_CfgDidMgrDidOpClassInfoGetEntry(pDidInfoContext->Descriptor.DidOpClassInfoIdx + 0)->OpClassRef);        /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Start position of the operations to be called */
  pDidOpTypeContext->Base.SignalOpClassInfoRef = Dcm_CfgDidMgrGetDidOpClassInfo(pDidInfoContext)->OpClassRef;                                        /* SBSW_DCM_PARAM_PTR_WRITE */
}

/**********************************************************************************************************************
 *  Dcm_DidMgrReadLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLength(Dcm_OpStatusType                  opStatus
                                                             ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                             ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                             ,Dcm_NegativeResponseCodePtrType   ErrorCode)                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType          lStdResult;
  Dcm_DidMgrDidLengthType lSignalLength;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdResult = Dcm_DidMgrReadLengthSignal(opStatus
                                         ,pDidInfoContext
                                         ,pDidOpTypeContext
                                         ,&lSignalLength
                                         ,ErrorCode);                                                                                                /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    /* Set DID length to concrete DID length */
    pDidInfoContext->DidLength = (uint16)(Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)->MinLength + lSignalLength);                                      /* SBSW_DCM_PARAM_PTR_WRITE */

    /* If no additional buffer space has to be reserved for that DID: */
    if(Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)->ReservedLength == 0u)
    {
      /* Set required buffer space to concrete DID length */
      pDidInfoContext->ReservedLength = pDidInfoContext->DidLength;                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCond()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCond(Dcm_OpStatusType                  opStatus
                                                                ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  DCM_UTI_LOOP_FOR_EVER
  {
    lStdResult = Dcm_DidMgrReadCheckCondSignal(opStatus
                                              ,pDidInfoContext
                                              ,pDidOpTypeContext
                                              ,ErrorCode);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    if(lStdResult != DCM_E_OK)
    {
      /* on pending or not OK -> just leave */
      break;/* try later */
    }

    pDidOpTypeContext->Base.NumSignals--;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    if(pDidOpTypeContext->Base.NumSignals == 0u)
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }
    /* next signal */
    pDidOpTypeContext->Base.SignalOpClassInfoRef++;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    opStatus = DCM_INITIAL;/* reset op status */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_DidMgrReadDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadDid(Dcm_OpStatusType                  opStatus
                                                          ,Dcm_DiagDataContextPtrType        pDataContext
                                                          ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                          ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                          ,Dcm_NegativeResponseCodePtrType   ErrorCode)
{
  Std_ReturnType lResult;

  /* #10 If any read operation has to be canceled: */
  if(opStatus == DCM_CANCEL)
  {
    lResult = DCM_E_NOT_OK;
    /* #20 If DID signal already in processing: */
    if(pDidOpTypeContext->OpType.Read.OpStatus != DCM_INITIAL)
    {
      /* #30 Notify application about cancellation */
      (void)Dcm_DidMgrReadSignal(opStatus
                                ,pDataContext
                                ,pDidInfoContext
                                ,pDidOpTypeContext
                                ,ErrorCode);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    } /* #40 Otherwise no cancellation shall be notified */
  }
  else
  {
    if(opStatus == DCM_INITIAL)
    {
      /* #60 Otherwise, initialize DID handler */
      Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

      pDidOpTypeContext->OpType.Read.OpStatus = DCM_INITIAL;                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
      pDidOpTypeContext->OpType.Read.Progress = 0u;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    /* #70 Read all signals */
    lResult = Dcm_DidMgrReadMultiSignal(pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  return lResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_Dcm_Design_6060 */
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(Dcm_DiagDataContextPtrType pDataContext
                                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                          ,Dcm_ObdDtcManagerContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  uint32                                lDtc;
  uint8                                 dtcStatus;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if (pDataContext->AvailLen >= 2u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTC)(
# if (DCM_DEM_API_430_ENABLED == STD_ON)
                                               pRepContext->DemClientId,
# endif
                                               &lDtc, &dtcStatus);                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */

    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_DiagProvideDataAsU8(pDataContext, Dcm_UtiGetHiLoByte(lDtc));                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, Dcm_UtiGetLoHiByte(lDtc));                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP;
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
  else
  {
    lStdResult = DCM_E_BUFFERTOOLOW;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemSetDTCFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemSetDTCFilter(uint8 StatusMask
                                                                 ,Dem_DTCOriginType Origin
                                                                 ,Dcm_MsgContextPtrType pMsgContext                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;
  Dcm_DemReturnSetFilterType resultSetDtcFilter;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  resultSetDtcFilter = Dcm_DemAPI(SetDTCFilter)(
# if (DCM_DEM_API_430_ENABLED == STD_ON)
                                                pRepContext->DemClientId,
# endif
                                                StatusMask
# if (DCM_DEM_API_430_ENABLED == STD_OFF)
                                               ,DEM_DTC_KIND_EMISSION_REL_DTCS
# endif
                                               ,DEM_DTC_FORMAT_OBD
                                               ,Origin
                                               ,DCM_DEM_FILTER_WITH_SEVERITY_NO
                                               ,DEM_SEVERITY_NO_SEVERITY
                                               ,DCM_DEM_FILTER_FOR_FDC_NO);

  if(resultSetDtcFilter == DCM_DEM_RET_FILTER_ACCEPTED)
  {
    Dcm_ObdDtcMgrSetNextStep(DCM_OBDDTCMGR_PROGRESS_GETNUMFLTRDDTC, pRepContext);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdReturn = DCM_E_LOOP;
  }
  else
  {/* else - set NRC */
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(resultSetDtcFilter, Dcm_DemApiNrcMapSetDTCFilter);                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrReadDtcByStatusMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE)Dcm_ObdDtcMgrReadDtcByStatusMask(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  switch (Dcm_ObdDtcMgrGetNextStep(pRepContext))                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
  case DCM_OBDDTCMGR_PROGRESS_GETNUMFLTRDDTC:
    lStdResult = Dcm_ObdDtcMgrDemGetNumFltrdDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
  case DCM_OBDDTCMGR_PROGRESS_COPYLINEARDATA:
    lStdResult = Dcm_ObdDtcMgrCopyLinearData(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_TSK_NUM_DIAG_GARB_COL > 0)
/**********************************************************************************************************************
 *  Dcm_DiagTaskGarbageCollector()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskGarbageCollector(Dcm_TskTaskEvOptType ev
                                                           ,Dcm_TskTaskEvPtrType pPostEv)                                                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_CfgNetTObjHandleOptType lTObjCntr;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Cleanup or reject all transport objects that never succeeded and are now canceled */
  lTObjCntr = 0;
  DCM_TSK_EVENT_SCAN_LOOP(ev)
  {
    /* Check who shall be removed */
    if(Dcm_TskIsLocalEventSet(ev, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj;

      pTranspObj = Dcm_NetGetTransportObject(lTObjCntr);
      /* Always unregister ComM activity here, since CANCELED flag will not clean it up!
       * If no RCR-RP on transmission: everything has to be cleaned up here!
       */
      Dcm_NetUnRegisterComMActivity(pTranspObj->ConnId);

      /* If just requested, then only this TObject could be the trigger for P2 timer - avoid any RCR-RP transmission */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ) != 0)
      {
        Dcm_TskClrEvent(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_RCRRP);
      }

      Dcm_UtiArEnvEnterCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /*=================================*
       BEGIN CRITICAL SECTION
       *=================================*/
      /* Check if any RCR-RP for this object is on Tx (DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ is excluded since the high-prio
       * Dcm_DiagTaskTx() shall already have switched to ON_TX!) */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_RCRRP_ON_TX) != 0)
      {
        pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED; /* isolate this connection */                                                               /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

        /* Try cancel any ongoing response. The return value does not matter:
         * OK -> there will be a confirmation for this cancellation
         * N_OK -> request rejected, but there will be a confirmation due to the ongoing transmission
         */
        (void)Dcm_NetArEnvPduRCancelTransmit(Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnId].TxPduIdMain);
        /* Any RCR-RP will just end with releasing the connection assigned to the tObject!
         * No confirmation post-processing will be performed! */
      }
      else
      {
        Dcm_NetBufferContextPtrType pBufferContext;

        pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
        Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                           /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
        Dcm_NetUnRegisterActiveConnection(pTranspObj); /* no further processing needed */                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }
      /*=================================*
       END CRITICAL SECTION
       *=================================*/
      Dcm_UtiArEnvLeaveCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }
    ++lTObjCntr;
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

/**********************************************************************************************************************
 *  Dcm_DiagRcrRpTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRcrRpTxFinished(Dcm_NetTransportObjectPtrType pTranspObj                                                      /* COV_DCM_RTM_NO_RCR_RP_TX */ /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                      ,Dcm_NetTransmissionResultType txStatus)
{
  Dcm_InstanceContext.Diag.TxStatus   = txStatus;/* store current Tx state */

  pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_NONE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_ON_TX);                                                 /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */ /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_UtiBitOpSet(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_SENT);/* mark RCR-RP at least once sent state */        /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->State   = DCM_NET_TOBJ_STATE_READY;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */

  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_RCRRP);  /* Notify for sent RCR_RP */
}

/**********************************************************************************************************************
 *  Dcm_DiagSetP2Timings()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagSetP2Timings(Dcm_StateIndexMemType sesStateIdx,
                                                    Dcm_NetProtRefMemType protocolIdx)
{
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/

  /* Calculate the current P2 timings considering the protocol related adjust timings */
  Dcm_InstanceContext.Diag.P2Timings.P2 = Dcm_DiagGetP2Time(sesStateIdx)
                                        - Dcm_NetGetP2AdjTime(protocolIdx);

  Dcm_InstanceContext.Diag.P2Timings.P2Star = Dcm_DiagGetP2StarTime(sesStateIdx)
                                            - Dcm_NetGetP2StarAdjTime(protocolIdx);

  /*=================================*
   END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagCancelProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagCancelProcessing(void)
{
  Dcm_TmrStopTimer(DCM_TMR_ID_P2);
  Dcm_TskKillAllTasks();
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_KILL_JOBS);
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRxIndication(Dcm_NetTransportObjectPtrType pTranspObj)                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

#if (DCM_DIAG_RST2DEF_ON_FUNC_OBD_REQ_ENABLED == STD_ON)
  /* #10 Handle OBD requests (SID [0x00-0x0F]) when only one diagnostic client is used */
  if ( (pTranspObj->RxData[0] < 0x10u)
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
     &&(Dcm_PbCfgNetNumConnections == 1u)
# endif
     &&((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) == 0)
     &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE)
     )
  {
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);
    Dcm_DiagSetP2Timings(0, 0);
  }
#endif

#if (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)
  /* #20 Update diagnostic kernel queue flags: */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_InstanceContext.Diag.QueuedSet.Flags |= DCM_DIAG_QUEUE_FLAG_IS_WAITING;
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
#endif

  /* #30 Prepare for new diagnostic request processing by setting all relevant for the real-time task properties: */
  Dcm_DiagSetQueuedTranspObj(pTranspObj);                                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_TmrStartTimer(DCM_TMR_ID_P2, Dcm_InstanceContext.Diag.P2Timings.P2);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.KeepAlive = TRUE;
#endif

  /* #40 Signal the Dcm_DiagTaskWorker that the request is now ready for processing */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_NEW_REQ);
}

/**********************************************************************************************************************
 *  Dcm_DiagTxFinalization()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTxFinalization(Dcm_NetTransportObjectPtrType pTranspObj                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                     ,Dcm_NetTransmissionResultType txStatus)
{
  Dcm_InstanceContext.Diag.TxStatus = txStatus;
  Dcm_InstanceContext.Diag.State    = DCM_DIAG_STATE_POST_PROCESS;

#if (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)
  Dcm_SplitTaskEnterCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_UtiBitOpClr(Dcm_DiagProcessorFlagType, Dcm_InstanceContext.Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_ACTIVE);                               /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
#endif

#if (DCM_DIAG_FAST_POST_PROCESSING_ENABLED == STD_ON)                                                                                                /* COV_DCM_SUPPORT_ALWAYS TX */
  if(((DCM_DIAG_APPL_NOTIFICATION_FASTPOSTPROCESSOR)& Dcm_InstanceContext.Diag.ApplNotification) != 0)
  {
    Dcm_DiagSvcConfirmationFuncType lFastConfFunc;
    Dcm_ConfirmationStatusType      lConfStatus;

    lFastConfFunc = Dcm_DiagGetPostProcessorFunc(Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].FastConfFuncRef);
    lConfStatus   = Dcm_DiagGetPostProcessResult();

    /* Execute any internal service processors fast-post-handlers */
    lFastConfFunc(lConfStatus);                                                                                                                      /* SBSW_DCM_CALL_FUNCPTR_SVCPOSTPROCESSORS */
  }
#endif
  /* release the connection */
#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
  if((DCM_NET_TOBJ_FLAG_CANCELED & pTranspObj->Flags) == 0) /* let the connection expire with the Tx confirmation (after CancelTransmit) */
#endif
  {
    Dcm_NetBufferContextPtrType pBufferContext;

    pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* Start the S3 timer if needed here to have maximum real-time accuracy (from communication bus point of view) */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL);
}

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagOnFblResTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagOnFblResTxFinished(Dcm_NetTransportObjectPtrType pTranspObj                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                         ,Dcm_NetTransmissionResultType txStatus)
{
  Dcm_NetBufferContextPtrType pBufferContext;

  pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

  Dcm_NetBufferRelease(pBufferContext);                                                                                                              /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
  Dcm_NetUnRegisterActiveConnection(pTranspObj);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

  Dcm_InstanceContext.Diag.StartUpFbl.TxStatus = txStatus;
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_TXCONF);
}
#endif

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutFblRes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutFblRes(void)
{
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_CANCEL);
  return 0u;
}
#endif

/**********************************************************************************************************************
 *  Dcm_OnTimeoutP2()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutP2(void)                                                                              /* COV_DCM_RTM_NO_RCR_RP_TX */
{
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_TMR_P2_TO);
  return 0u;
}

/**********************************************************************************************************************
 *  Dcm_OnTimeoutS3()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutS3(void)
{
  if(!Dcm_StateIsDefaultSessionActive())
  {
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);
    Dcm_DiagSetP2Timings(0, Dcm_NetGetProtIdOfActiveProtocol());
  }
  return 0u;
}

#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutKeepAlive()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutKeepAlive(void)
{
  if(Dcm_StateIsDefaultSessionActive())                                                                                                              /* COV_DCM_RTM_DEPENDS_ON_CFG */
  {
    Dcm_NetUnRegisterAllComMActivity();
  } /* else - ComM activity will be unregistered by S3 timeout */

  Dcm_SingletonContext.Network.KeepAlive = FALSE;

  return 0u; /* No reload */
}
#endif

#if(DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagExecIndicationFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagExecIndicationFunc(Dcm_MsgItemType sid
                                                                   ,Dcm_DiagApplNotificationType notificationType
                                                                   ,Dcm_CfgDiagNotificationInfoPtrType notifList
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode)                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lResult = DCM_E_OK; /* positive case */
  uint16_least   lIter;

  Dcm_InstanceContext.Diag.ApplNotification |= notificationType; /* mark application has been notified */

  /* Prepare for post processing later */
  Dcm_InstanceContext.Diag.PostProcessorContext.Sid     = sid;
  Dcm_InstanceContext.Diag.PostProcessorContext.SrcAddr = Dcm_PbCfgNetConnectionInfo[Dcm_NetGetConnIdOfRxPduId(Dcm_InstanceContext.Diag.MsgContext.rxPduId)].ClientSrcAddr;
  Dcm_InstanceContext.Diag.PostProcessorContext.ReqType = (uint8)Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.reqType;

  *ErrorCode = DCM_E_POSITIVERESPONSE;                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

  for(lIter = 0u; notifList[lIter].IndFunc != NULL_PTR; ++lIter)
  {
    Std_ReturnType               lStdResult;
    Dcm_NegativeResponseCodeType lNrc = DCM_E_POSITIVERESPONSE; /* Initialize out parameter */

    lStdResult = notifList[lIter].IndFunc(sid
                                         ,Dcm_InstanceContext.Diag.MsgContext.reqData
                                         ,(uint16)Dcm_InstanceContext.Diag.MsgContext.reqDataLen
                                         ,(uint8)Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.reqType
                                         ,Dcm_InstanceContext.Diag.PostProcessorContext.SrcAddr
                                         ,&lNrc);                                                                                                    /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */

    if(lStdResult != DCM_E_OK)
    {
      lResult = DCM_E_NOT_OK; /* Mark error, but let other checks to be performed - check for higher priority NOT_ACCEPTED result */

      switch(lStdResult)
      {
      case DCM_E_NOT_OK:
        Dcm_DiagHandleApplNrc(lStdResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);                                                                        /* SBSW_DCM_POINTER_FORWARD_STACK */
        break;
      case DCM_E_REQUEST_NOT_ACCEPTED:
        lNrc = DCM_E_CONDITIONSNOTCORRECT; /* In DCM_E_REQUEST_NOT_ACCEPTED case no positive response shall be sent! */
        Dcm_InstanceContext.Diag.DoSuppressResponse = TRUE; /* Try to suppress, but if an RCR-RP has been already sent - send the registered NRC */
        break;
      default:
        /* Unexpected return value */
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
        lNrc = DCM_E_PANIC_NRC;
        break;
      }

      /* Try to register NRC if no other has been set! */
      if (*ErrorCode == DCM_E_POSITIVERESPONSE)
      {
        *ErrorCode = lNrc;                                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
  }

  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

/**********************************************************************************************************************
 *  Dcm_ProcessingDone()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ProcessingDone(void)
{
  /* If positive response to be sent: */
  if(Dcm_InstanceContext.Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
  {
    /* If SPRMIB == TRUE (suppression of positive response): */
    if(Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.suppressPosResponse != 0u)
    {
      /* Mark no response to be sent */
      Dcm_InstanceContext.Diag.DoSuppressResponse = TRUE;
    }/* Otherwise - proceed with positive response transmission */
  }
  else /* Otherwise (negative response): */
  {
    /* If functionally requested diagnostic job: */
    if(Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.reqType != 0)
    {
      switch(Dcm_InstanceContext.Diag.ErrorRegister)
      {
        case DCM_E_SERVICENOTSUPPORTED:
        case DCM_E_SUBFUNCTIONNOTSUPPORTED:
        case DCM_E_REQUESTOUTOFRANGE:
#if (DCM_DIAG_SUPPRESS_NRC_7F_7E_ENABLED == STD_ON)
        case DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION:
        case DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION:
#endif
          /* Suppress negative response for certain NRCs only */
          Dcm_InstanceContext.Diag.DoSuppressResponse = TRUE;
          break;
        default:
          /* Otherwise - proceed with negative response transmission */
          break;
      }
    }/* Otherwise - proceed with negative response transmission */
  }
  /* Update diagnostic sub-component activity state */
  Dcm_InstanceContext.Diag.State = DCM_DIAG_STATE_ON_TX;

  /* Notify the transmission task for linear data response transmission/suppression */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_LINEAR);
}

/**********************************************************************************************************************
 *  Dcm_SetNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_SetNegResponse(Dcm_NegativeResponseCodeType nrc)
{
  if(Dcm_InstanceContext.Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
  {
    Dcm_InstanceContext.Diag.ErrorRegister = nrc;
  }
}
/**********************************************************************************************************************
 *  Dcm_DiagTaskRx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRx(Dcm_TskTaskEvOptType ev
                                             ,Dcm_TskTaskEvPtrType pPostEv)                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_NetTransportObjectPtrType pQueuedTObj;

  pQueuedTObj = Dcm_DiagGetQueuedTranspObj();

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If new request received: */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RX_NEW_REQ))
  {
    /* Initialize related objects */
    pQueuedTObj->State = DCM_NET_TOBJ_STATE_READY;                                                                                                   /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
    Dcm_DiagResetRcrRpLimiter();
    /* Synchronize with diagnostic job processing task */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_NEW_REQ);
  }

  /* If P2 timeout detected: */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RX_TMR_P2_TO))
  {
    /* Pre-processing a P2 timeout in oder to cancel the working thread in time (on non-split task configuration) */
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
    /* If RCR-RP limit reached: */
    if(Dcm_DiagGetRcrRpLimiter() == 0)
    {
      /* Reset any RCR-RP related states and notify worker task to initiate job cancellation */
      Dcm_DiagRcrRpTxFinished(pQueuedTObj, DCM_E_NOT_OK);                                                                                            /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */

      /*
       * Signal cancellation to the worker. If worker gets interrupted by this hi priority task,
       * while already called "processing done", the cancellation signal will be lost and
       * the final response will be sent at next worker task call.
       */
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_CANCEL_OP);

      /*
       * Do not send RCR-RP and restart the P2 timer again since the limit has been reached and the worker will
       * finalize the job, once the cancel signal is received.
       */
    }
    else
#endif
    {
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
      /* Otherwise - update RCR-RP limiter */
      Dcm_DiagDecrementRcrRpLimiter();
#endif
      /* Notify diagnostic transmission task to initiate RCR-RP transmission */
      pQueuedTObj->Flags |= DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ;                                                                                          /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_RCRRP);
    }
  }
}

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagTaskFblRes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskFblRes(Dcm_TskTaskEvOptType ev
                                                 ,Dcm_TskTaskEvPtrType pPostEv)
{
  /* #10 Check for eventual FBL final response request */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_FBLRES_SEND))
  {
    ev = Dcm_DiagFblResDoGetProgCond(ev, pPostEv);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* #20 If final response required, wait for ComM before sending the response */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM))
  {
    ev = Dcm_DiagFblResDoWaitTxComm(ev, pPostEv);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* #30 Once final FBL response request processed, reset all flags to prevent from a new response at next power-on/reset */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS))
  {
    ev = Dcm_DiagFblResDoResetFlags(ev, pPostEv);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* #40 If any FBL final response confirmation received, do the designated job (e.g. session transition) */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_FBLRES_TXCONF))
  {
    (void)Dcm_DiagFblResDoProcessTxConfirmation(ev, pPostEv);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTaskWorker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskWorker(Dcm_TskTaskEvOptType ev
                                                 ,Dcm_TskTaskEvPtrType pPostEv)
{
#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
  /* Important: this event is a synchronization event between high- and low-priority tasks.
   * Never move this event processing into another task than the one that initiates the new request processing (DCM_TSK_EV_DIAG_WORK_NEW_REQ).
   * Otherwise the clean-up jobs from DCM_TSK_EV_DIAG_WORK_KILL_JOBS event may be performed AFTER the new request processing has been started.
   * This will lead to out of sync of services post- and main-processing!
  */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_KILL_JOBS))
  {
    Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_WORK_KILL_JOBS); /* Already processed - avoid re-execution of this event if kill-job is nested */       /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    ev = Dcm_DiagWorkerDoCancelProcessing(ev, pPostEv);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL))
  {
    Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL); /* Already processed - avoid re-execution of this event if kill-job is nested */    /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    Dcm_DiagWorkerDoPostProcessing();
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF))
  {
    Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF); /* Already processed - avoid re-execution of this event if kill-job is nested */     /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    ev = Dcm_DiagWorkerSetDefSessionExtern(ev, pPostEv);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF))
  {
    Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF); /* Already processed - avoid re-execution of this event if kill-job is nested */     /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    Dcm_StateSetSession(0);
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_NEW_REQ))
  {
    ev = Dcm_DiagWorkerProcessNewRequest(ev, pPostEv);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_TX_END_RCRRP))
  {
    ev = Dcm_DiagWorkerProcessRcrRpTxEnd(ev, pPostEv);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON) && \
    (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_CANCEL_OP))
  {
    ev = Dcm_DiagWorkerCancelOperation(ev, pPostEv);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_REPEAT))
  {
    (void)Dcm_DiagWorkerDoRepeat(ev, pPostEv);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}                                                                                                                                                    /* PRQA S 6010, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_DiagTaskTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskTx(Dcm_TskTaskEvOptType ev
                                             ,Dcm_TskTaskEvPtrType pPostEv)
{
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_TX_SEND_PAGED))
  {
    ev = Dcm_DiagTxPostponeFinalPagedResponse(ev, pPostEv);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

  if(Dcm_TskIsLocalEventSet(ev, (DCM_TSK_EV_DIAG_TX_SEND_PAGED | DCM_TSK_EV_DIAG_TX_SEND_LINEAR)))
  {
    ev = Dcm_DiagTxStartFinalResponse(ev, pPostEv);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_TX_SEND_RCRRP))
  {
    Dcm_DiagTxStartRcrRpResponse();
  }
}

#if (DCM_TSK_NUM_DIAG_RECOVERY > 0)                                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagTaskRecovery()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRecovery(Dcm_TskTaskEvOptType ev
                                                   ,Dcm_TskTaskEvPtrType pPostEv)
{
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE))
  {
    Std_ReturnType lResult;

    /* Retrieve the recovery information from the application */
    lResult = Dcm_GetRecoveryStates(&Dcm_InstanceContext.Repeater.Contexts.Context.Recovery.RecoveryInfo);                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

    switch(lResult)
    {
    case DCM_E_OK:
      Dcm_TskSetLocalEvent(ev, DCM_TSK_EV_DIAG_RECOVERY_PROCESS);
      Dcm_InstanceContext.Repeater.Contexts.Context.Recovery.OpStatus = DCM_INITIAL;
      break;
    case DCM_E_PENDING:
      /* Retry next time */
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE);                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
      break;
    default:
      Dcm_DebugAssert((lResult == DCM_E_NOT_OK), DCM_SID_GETRECOVERYSTATES, DCM_E_INTERFACE_RETURN_VALUE)                                            /* COV_DCM_RTM_DEV_DEBUG XF */
      /* Abort recovering */
      Dcm_TskSetLocalEvent(ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);
      break;
    }
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RECOVERY_PROCESS))
  {
    Std_ReturnType   lResult;
    lResult = Dcm_DiagSafeProcessRecoveryInfo(&Dcm_InstanceContext.Repeater.Contexts.Context.Recovery.RecoveryInfo,
                                               Dcm_InstanceContext.Repeater.Contexts.Context.Recovery.OpStatus);                                     /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

    switch(lResult)
    {
    case DCM_E_OK:
      Dcm_TskSetLocalEvent(ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);
      break;
    case DCM_E_PENDING:
      /* Retry next time */
      Dcm_InstanceContext.Repeater.Contexts.Context.Recovery.OpStatus = DCM_PENDING;
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_RECOVERY_PROCESS);                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
      break;
    default: /* DCM_E_NOT_OK */
      /* Abort recovering */
      Dcm_TskSetLocalEvent(ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);
      break;
    }
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH))
  {
    Dcm_SingletonContext.Network.RxAllowed = TRUE;
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_DiagLookUpFilter(sint16_least lookUpResult
                                                           ,Dcm_VarRefMemPtrType lookUpFilterTable
                                                           ,Dcm_DiagCheckLvlType chkLevel
                                                           ,Dcm_NegativeResponseCodePtrType errorCode)
{
  sint16_least lLookUpResult;

  /* #10 Check if diagnostic object exists in current variant */
  lLookUpResult = Dcm_VarMgrLookUpFilter(lookUpResult, lookUpFilterTable);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* #20 If diagnostic object not supported in current variant at all: */
  if(lLookUpResult < 0)
  {
    /* #30 Set appropriate NRC depending on the diagnostic object type */
    *errorCode = Dcm_DiagObjNotFoundNrcs[chkLevel];                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  /* #40 Otherwise if diagnostic object not supported in current session: */
  else if (!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(lookUpFilterTable[lLookUpResult])))
  {
    /* #50 Invalidate lookup result and set appropriate NRC depending on the diagnostic object type */
    lLookUpResult = -1; /* override result */
    *errorCode = Dcm_StateSessionNrcs[chkLevel];                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* #60 Otherwise return positive result  */
  }

  /* #70 Return final result */
  return lLookUpResult;
}

#if (DCM_DIAG_SF_ONLY_SERVICE_ENABLED == STD_ON)                                                                                                     /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagSvcWithOnlySubFuncReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_DiagSvcWithOnlySubFuncReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return 1u;
}
#endif

#if (DCM_DIAG_ANY_SERVICE_WITH_SF_ENABLED == STD_ON)                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagNoSequenceChecker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagNoSequenceChecker(Dcm_DiagSubServiceRefOptType subSvcRef)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(subSvcRef);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  lStdResult = DCM_E_OK;

  return lStdResult;
}
#endif

#if (DCM_DIAG_ANY_SERVICE_WITH_SF_ENABLED == STD_ON)                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagSvcWithSubFuncStateCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSvcWithSubFuncStateCheck(
                                                        Dcm_CfgStateRefOptType                  stateRef
                                                       ,Dcm_DiagSubFuncSequenceCheckerFuncType  subFuncSequenceChecker
                                                       ,Dcm_DiagSubServiceRefOptType            subSvcRef
                                                       ,Dcm_NegativeResponseCodePtrType         ErrorCode)                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(stateRef);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(subFuncSequenceChecker);                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(subSvcRef);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If supported, verify the security access level pre-condition (UDS verification order) */
# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(!Dcm_StateIsSupportedInSecurityLevel(Dcm_StateGetPreconditionStates(stateRef)))
  {
    /* If not met, do return NRC 0x33 (UDS) */
    *ErrorCode = DCM_E_SECURITYACCESSDENIED;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
# if (DCM_DIAG_SF_SEQUENCE_CHECK_SUPPORT_ENABLED == STD_ON)
  if(subFuncSequenceChecker(subSvcRef) != DCM_E_OK)                                                                                                  /* SBSW_DCM_PARAM_FUNCPTR_CALL */
  {
    /* If SF sequence is not correct, send NRC 0x24 */
    *ErrorCode = DCM_E_REQUESTSEQUENCEERROR;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  {
# if(DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
    /* Otherwise, if supported, get the the mode-related pre-condition expression(s) result */
    lStdReturn = Dcm_ModeCheck(Dcm_CfgStatePreconditions[stateRef].ModeRuleRef, ErrorCode);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
# else
    /* Otherwise, everything fine - return positive response code */
    lStdReturn = DCM_E_OK;
# endif
  }

  return lStdReturn;
}
#endif

#if (DCM_DIAG_ANY_SERVICE_WITH_SF_ENABLED == STD_ON)                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagVerifyServiceWithSubFunction()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagVerifyServiceWithSubFunction(
                                                        Dcm_MsgContextPtrType                   pMsgContext
                                                       ,Dcm_Uint8ConstDataPtrType               lookUpTable
                                                       ,Dcm_VarRefMemPtrType                    lookUpFilterTable
                                                       ,Dcm_DiagServiceLengthGetterFuncType     svcLengthGetter
                                                       ,Dcm_DiagSubFuncSequenceCheckerFuncType  subFuncSequenceChecker
                                                       ,Dcm_DiagSubServiceRefOptPtrType         pSubSvcRef
                                                       ,Dcm_NegativeResponseCodePtrType         ErrorCode)
{
  Std_ReturnType lStdResult;
  sint16_least   lLookUpResult;
  uint8          sfID = Dcm_DiagGetReqDataAsU8(pMsgContext);

  *pSubSvcRef = 0;                                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Min Length already checked in DiagDispatcher and expected to be 1 !!! */
  Dcm_DebugAssert((pMsgContext->reqDataLen > 0), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                              /* COV_DCM_RTM_DEV_DEBUG XF */

  lLookUpResult = Dcm_DiagLookUpFilter(Dcm_UtiLookUpUint8(lookUpTable, sfID)
                                      ,lookUpFilterTable
                                      ,DCM_DIAG_CHK_LVL_SUBFUNC
                                      ,ErrorCode);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lLookUpResult >= 0)
  {
    /* Mark found position in any case if found */
    *pSubSvcRef = (Dcm_DiagSubServiceRefOptType)lLookUpResult;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

    lStdResult = Dcm_DiagSvcWithSubFuncStateCheck(lookUpFilterTable[lLookUpResult]
                                                 ,subFuncSequenceChecker
                                                 ,*pSubSvcRef
                                                 ,ErrorCode);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)
    {
      Dcm_DiagSubServiceLengthType expectedLength;
      expectedLength = svcLengthGetter(*pSubSvcRef);                                                                                                 /* SBSW_DCM_PARAM_FUNCPTR_CALL */

      if( (expectedLength != 0) /* dynamic length */
        &&(expectedLength != pMsgContext->reqDataLen) ) /* SF + data */
      {
        *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
    /* Extract SF in any case if supported */
    Dcm_DiagConsumeReqData(pMsgContext, 1u);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU8(pMsgContext, sfID);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    Dcm_DiagSetNewReqBaseToCurProgress(pMsgContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagSetNewResBaseToCurProgress(pMsgContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    /* else - ErrorCode is already set */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050, 6060 */ /* MD_MSR_STCAL, MD_Dcm_Design_6060 */
#endif
#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrIsEnabledInActiveVariants()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgStateRefOptType cfgVariantRef)
{
  boolean lIsEnabled = FALSE;
  Dcm_CfgVarMgrDiagVariantIdOptType varRowIter = Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_CFG_VARIANTS);

  /* scan all variants (at least 8 way scan) for at least one match */
  while(varRowIter > 0)
  {
    --varRowIter;
    if((Dcm_PbCfgVarMgrDiagVariantFilter[cfgVariantRef][varRowIter] & Dcm_SingletonContext.VarMgr.ActiveCfgVariants[varRowIter]) != 0)
    {
      lIsEnabled = TRUE;/* at least one matched variant */
      break;
    }/* else - continue searching */
  }

  return lIsEnabled;
}
#endif

/**********************************************************************************************************************
 *  Dcm_VarMgrLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_VarMgrLookUpFilter(sint16_least lookUpResult
                                                             ,Dcm_VarRefMemPtrType lookUpFilterTable)
{
  DCM_IGNORE_UNREF_PARAM(lookUpFilterTable);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

#if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  if(lookUpResult >= 0)
  {
    if (Dcm_VarMgrIsEnabledInActiveVariants(lookUpFilterTable[lookUpResult]) == FALSE)
    {
      lookUpResult = -1; /* override result */
    }
  }
#endif

  return lookUpResult;
}
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessEcuReset(Dcm_ModeMgrArEnvModeEcuResetType mode
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lResult;

  /* Try performing mode switch on ECU reset */
  if(Dcm_ModeMgrArEnvSwitchReqEcuReset(mode) == DCM_E_OK)
  {
    /* If succeeded, go on with waiting for acknowledge */
    Dcm_RepeaterNextStep(DCM_SVC11_PROGRESS_ECURST_WAITFORACK);
    lResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    /* If this attempt fails, send back NRC 0x22 to notify diagnostic client */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  return lResult;
}
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessRapPwrDwn()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessRapPwrDwn(Dcm_ModeMgrArEnvModeRapidPowerShutDownType mode
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lResult;

  /* Try performing mode switch on ECU reset */
  if(Dcm_ModeMgrArEnvSwitchReqRapidPowerShutDown(mode) == DCM_E_OK)
  {
    /* If succeeded, go on with waiting for acknowledge */
    Dcm_RepeaterNextStep(DCM_SVC11_RAPPWRDWN_WAITFORACK);
    lResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    /* If this attempt fails, send back NRC 0x22 to notify diagnostic client */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }

  return lResult;
}
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc19ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc19SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainStart(
                                                   P2CONST(Dcm_RepeaterProgressType, AUTOMATIC, DCM_CONST) funcChain
                                                  ,Dcm_Svc19RepeaterProxyContextPtrType                    pRepContext)
{
  pRepContext->FuncChain = funcChain;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_RepeaterNextStep(*pRepContext->FuncChain);
  return DCM_E_LOOP;/* execute it immediately */
}
# endif

# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainNext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainNext(Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Dcm_UtiNextItemByPtr(pRepContext->FuncChain, 1u);                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_RepeaterNextStep(*pRepContext->FuncChain);
  return DCM_E_LOOP;/* take next item from list */
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcByStatusMaskData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcByStatusMaskData(
                                                                      Dcm_Svc19DemSetFilterClassType       dsfClass
                                                                     ,Dcm_Svc19DemSetFilterMaskUsageType   maskUsage
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  uint8 dtcStatusMask;
  uint8 dtcSAM;

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pRepContext->DemClientId
                                                       ,&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  if(lStdResult == E_OK)
  {
    lStdResult = DCM_E_NOT_OK;

    /* If a requested DTC status mask shall be considered: */
    if(maskUsage == DCM_SVC_19_USE_MASK_REQ)
    {
      Dcm_DiagConsumeReqDataAsU8(pMsgContext, &dtcStatusMask);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
      Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(&dtcStatusMask);                                                                                     /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_POINTER_FORWARD_STACK */
      dtcStatusMask &= dtcSAM;

      if(dtcStatusMask == 0u)
      {
        /* If no supported (relevant) status bit remains, omit DEM SetFilter API invokation
         * (i.e. send final positive response only with SAM)
         */
        lStdResult = DCM_E_OK;
      }
      /* Otherwise, prepare a DEM filter to consider relevant DTC status bits */
    }
    else
    {
      /* Otherwise, prepare a DEM filter to report all supported DTCs */
      dtcStatusMask = 0u;
    }

    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* If DEM filtering still required: */
    if(lStdResult != DCM_E_OK)
    {
      lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                              ,dsfClass
                                              ,dtcStatusMask
                                              ,0 /* parameter not used */
                                              ,DCM_DEM_FILTER_FOR_FDC_NO
                                              ,pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(lStdResult == DCM_E_OK)
      {
        lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainReadDtcByStatus, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
      }
      else
      {
        /* Already set by Dcm_Svc19UtiDemSetDTCFilter */
      }
    }/* Otherwise, send the final response with no additional data */
  }
  else
  {
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByStatusMaskData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByStatusMaskData(
                                                                     Dcm_Svc19DemSetFilterClassType       dsfClass
                                                                    ,uint8                                dtcStatusMask
                                                                    ,Dem_DTCSeverityType                  dtcSeverity
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType           lStdResult;
  uint8                    dtcSAM;

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pRepContext->DemClientId
                                                       ,&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  if (lStdResult == E_OK)
  {
    Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(&dtcStatusMask);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_PARAM_PTR_FORWARD */

    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
    Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_DemAPI(GetTranslationType)(pRepContext->DemClientId));                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
    Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_DemAPI(GetTranslationType)());                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif

    dtcStatusMask &= dtcSAM;
    if(dtcStatusMask != 0)
    {
      lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                              ,dsfClass
                                              ,dtcStatusMask
                                              ,dtcSeverity
                                              ,DCM_DEM_FILTER_FOR_FDC_NO
                                              ,pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(lStdResult == DCM_E_OK)
      {
        lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainDtcCount, pRepContext);                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
      }
      else
      {
        /* Already set by Dcm_Svc19UtiDemSetDTCFilter */
      }
    }
    else
    {
      Dcm_DiagProvideResDataAsU16(pMsgContext, 0); /*lint !e572 if a constant fits into uint8, then lint threats it as such and ignores any casts */ /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_OK;
    }
  }
  else
  {
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_Dcm_Design_6060 */
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportExtDataRecordByDtcNum()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportExtDataRecordByDtcNum(Dem_DTCOriginType         dtcOrigin
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  pRepContext->Origin = dtcOrigin;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

  Dcm_DiagConsumeReqDataAsU24(pMsgContext, &(pRepContext->Dtc));                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &(pRepContext->RecordNum));                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(pRepContext->RecordNum == DCM_SVC_19_RECNUM_ALL)
  {
    pRepContext->RecordNumList = Dcm_Svc19ExtDataRecords;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else if(pRepContext->RecordNum == DCM_SVC_19_RECNUM_OBD_ALL)
  {
#  if (DCM_SVC_19_OBD_EXT_RECORD_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
    pRepContext->RecordNumList = Dcm_Svc19ExtDataRecordsObd;                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
#  else
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* the ECU does not support any OBD extended data records - reject request */                              /* SBSW_DCM_PARAM_PTR_WRITE */
    return DCM_E_NOT_OK;
#  endif
  }
  else
  {
    /* Single record */
    pRepContext->RecordNumList = NULL_PTR;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  return Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainReadExtRecords, pRepContext);                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByOccurenceTime()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByOccurenceTime(Dem_DTCRequestType        dtcReqType
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  uint8 dtcSAM;

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pRepContext->DemClientId
                                                       ,&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  if (lStdResult == E_OK)
  {
    Dcm_DemReturnGetDTCByOccurrenceTimeType demResult;

    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    demResult = Dcm_DemAPI(GetDTCByOccurrenceTime)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
                                                   pRepContext->DemClientId,
#  endif
                                                   dtcReqType
                                                  ,&pRepContext->Dtc);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    switch(demResult)
    {
      case DCM_DEM_RET_OCCURR_OK:
        pRepContext->Origin = DEM_DTC_ORIGIN_PRIMARY_MEMORY;                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainGetDtcStatusEnd, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
        break;
      default:
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetDTCByOccurrenceTime);                                               /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
    }
  }
  else
  {
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcFFRByDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcFFRByDtc(Dem_DTCOriginType                    dtcOrigin
                                                                      ,Dcm_MsgContextPtrType                pMsgContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                      ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  pRepContext->Origin = dtcOrigin;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_DiagConsumeReqDataAsU24(pMsgContext, &(pRepContext->Dtc));                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &(pRepContext->RecordNum));                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(pRepContext->RecordNum == DCM_SVC_19_RECNUM_ALL)
  {
    pRepContext->RecordNumList = Dcm_Svc19FFDataRecords;                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* Single record */
    pRepContext->RecordNumList = NULL_PTR;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  return Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainReadFFRByDtc, pRepContext);                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# if (DCM_TSK_NUM_SVC27 > 0)
/**********************************************************************************************************************
 *  Dcm_Svc27Task()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27Task(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv)                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  /* #10 If the attempt counters should be restored: */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_READ))
  {
    /* #20 Process attempt counter reading */
    (void)Dcm_Svc27ReadAttemptCounter(ev, pPostEv);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* #30 If the attempt counters should be stored: */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_WRITE))
  {
    /* #40 Process attempt counter writing */
    (void)Dcm_Svc27WriteAttemptCounter(ev, pPostEv);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSecurityAccess_0()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSecurityAccess_0(void)
{
  Dcm_TmrTimerCntrMemType lReloadTick = 0u;
  uint8_least             lTmrIter;
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  uint32_least            lJustExpiredMask = 0u;
#  endif

  /* For each software timer: */
  for(lTmrIter = 0; lTmrIter < DCM_SVC_27_NUM_DELAY_TIMERS; ++lTmrIter)
  {
#  if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
    /* If delay time is set to infinity: */
    if(Dcm_Svc27ReloadReadFailedGet(lTmrIter) == TRUE)
    {
      /* Reload forever */
      lReloadTick = 1u;
    }
    else
#  endif
    {
      /* Otherwise, if the software timer is active: */
      if(Dcm_Svc27TimerActive(lTmrIter) == TRUE)
      {
        /* Decrement the timer value */
        Dcm_Svc27TimerSet(lTmrIter, (Dcm_Svc27TimerType)(Dcm_Svc27TimerGet(lTmrIter) - 1u));

        /* If the software timer is still active */
        if(Dcm_Svc27TimerActive(lTmrIter) == TRUE)
        {
          /* Reload the hardware timer */
          lReloadTick = 1u;
        }
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
        else
        {
          /* Otherwise, remember the index of the just expired timer */
          lJustExpiredMask |= Dcm_UtiGetBitFromIndex(uint32, lTmrIter);
        }
#  endif
      }
    }
  }

#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  {
    uint8_least lSecLvlIter;

    /* For each security level */
    for(lSecLvlIter = 0; lSecLvlIter < DCM_STATE_SECURITY_NUM_LEVELS; ++lSecLvlIter)
    {
      /* If the corresponding timer of the given security level is just expired */
      if(Dcm_Svc27TimerJustExpired(lJustExpiredMask, lSecLvlIter) == TRUE)
      {
        /*
         * Reset the corresponding attempt counter of the given security level (if only single counter used, it will
         * be overwritten multiple times)
         */
        Dcm_Svc27CounterReset(lSecLvlIter);
        Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask |= Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter);
      }
    }
  }

  /* If at least one attempt counter was reset */
  if(Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask != 0)
  {
    /* Notify the application about changed attempt counter values */
    Dcm_TskSetEvent(DCM_TSK_ID_SVC27, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_WRITE);
  }
#  endif

  return lReloadTick;
}
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiSetAttemptCntr()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27UtiSetAttemptCntr(Dcm_OpStatusType opStatus
                                                         ,P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask)
{
  uint8_least lSecLvlIter = 0u;
  uint32      lMask = *levelMask;

  /* For each security level: */
  DCM_UTI_LOOP_BIT_SCAN(lMask)
  {
    /* If the attempt counter for that specific security level is not already written: */
    if(Dcm_UtiBitOpTest(uint32, lMask, 0x01u))
    {
      Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;

      pSecLevelInfo = Dcm_CfgSvc27SecLevelInfoGetEntryOrNull(lSecLvlIter);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if (pSecLevelInfo == NULL_PTR)                                                                                                                 /* COV_DCM_RTM_RUNTIME_CHECK XF */
      {
        break;
      }
      else
#  endif
      {
        Std_ReturnType lResult;

        /* Notify the application about the new attempt counter value */
        lResult = pSecLevelInfo->SetAttemptCntrFunc(opStatus, Dcm_Svc27CounterGet(lSecLvlIter));                                                     /* SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL */

        if (lResult == DCM_E_PENDING)
        {
          /* Otherwise try it later */
        }
        else
        {
          Dcm_DebugApiCheckRte(((lResult == DCM_E_OK) || (lResult == DCM_E_NOT_OK)), DCM_SID_SETSECURITYATTEMPTCOUNTER, DCM_E_INTERFACE_RETURN_VALUE)
          /*
           * If the attempt counter was written successfully or an error occurred, don't try to write the attempt
           * counter again.
           */
          Dcm_SplitTaskEnterCS(); /* Avoid interrupt from Dcm_OnTimeoutSecurityAccess */                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
          /*=================================*
            BEGIN CRITICAL SECTION
           *=================================*/
          Dcm_UtiBitOpClr(uint32                                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
                         ,*levelMask
                         ,Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));
          /*=================================*
            END CRITICAL SECTION
           *=================================*/
          Dcm_SplitTaskLeaveCS();                                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
        }
      }
    }
    ++lSecLvlIter;
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc27ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc27SubFuncInfo[sfRef].ReqLength;
}

/**********************************************************************************************************************
 *  Dcm_Svc27SubFuncSequenceChecker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27SubFuncSequenceChecker(Dcm_DiagSubServiceRefOptType subSvcRef)
{
  Std_ReturnType lStdResult = DCM_E_OK;

  if( (Dcm_Svc27IsKeyRequest(subSvcRef) == TRUE)
    &&(Dcm_Svc27IsThisKeyRequestExpected(Dcm_Svc27GetSecLvlRef(subSvcRef)) == FALSE))
  {
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc28EnableCommunication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc28EnableCommunication(void)
{
  uint8_least channelIter = Dcm_PbCfgNetNumAllComMChannels;

  while(channelIter != 0) /* Use top-down counting to be consistent with the Dcm_Svc28ApplyCommControl all-channel calls */
  {
    --channelIter;
    if(Dcm_ModeGetCommControlState(channelIter) != DCM_ENABLE_RX_TX_NORM_NM)
    {
      Dcm_ModeSwitchCommControl(channelIter, DCM_ENABLE_RX_TX_NORM_NM);
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc28ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc28ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc28SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSvc2AScheduler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSvc2AScheduler(void)
{
  Dcm_TmrTimerCntrMemType lReturn = 0;

  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    boolean doActivateProcessorTask;

    doActivateProcessorTask = Dcm_Svc2ASchdUpdateTimers();

    if(doActivateProcessorTask == TRUE)
    {
      Dcm_TskSetEvent(DCM_TSK_ID_SVC2A_SCHEDULER, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);/* at least one job to do */
    }
    lReturn = 1u;/* immediate timeout in next slot */
  }/* else - a NOP activate - will be the last one */
  return lReturn;/* no reload */
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ATaskSchdProcess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ATaskSchdProcess(Dcm_TskTaskEvOptType ev
                                                       ,Dcm_TskTaskEvPtrType pPostEv)                                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(ev);                                                                                                                        /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
  /* scheduler timer update is done in a dedicated task to achieve maximum timing accuracy */
# else
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD))
  {
    boolean doActivateProcessorTask;

    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
    {
      doActivateProcessorTask = Dcm_Svc2ASchdUpdateTimers();
      if(doActivateProcessorTask == TRUE)
      {
        Dcm_TskSetLocalEvent(ev,  DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);/* let's check which did is in a timeout */
      }
      /* still something to do - keep timer updater alive */
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD);                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS))
# endif
  {
    Dcm_Svc2ASchdItemHandleOptType lSchdIter;

    /* loop over all scheduled items (maximum once per task activation) */
    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdEntryPtrType pSchedTableEntry =
        Dcm_Svc2ASchdGetEntry(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex);

      if( (pSchedTableEntry->Timer == 0u)
        &&( (pSchedTableEntry->Rate & DCM_SVC2A_RATE_TYPE_STOPPED) == 0) )
      {
        Std_ReturnType lStdReturn;

        lStdReturn = Dcm_Svc2ASchdProcessEntry(pSchedTableEntry);                                                                                    /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
        if(lStdReturn == DCM_E_PENDING)
        {
          Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
          break; /* leave the loop and the task */
        }
      }
      /* next entry to be processed */
      Dcm_Svc2ASchdNextEntryIdxInc();
    }
  }
}
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopAll()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopAll(void)
{
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    Dcm_Svc2ASchdItemHandleOptType lSchdIter;

    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdStopItemByHandle(lSchdIter);
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByHandle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByHandle(Dcm_Svc2ASchdItemHandleOptType schdHandle)
{
  if( (Dcm_DidMgrDidHasLock(DCM_DIDMGR_DIDLOCK_OWNER_READPERIODIC) == TRUE)
    &&(schdHandle == Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex) )
  {
    Dcm_NegativeResponseCodeType lNrc;/* not evaluated after the API call */
    Dcm_DiagDataContextType      lDataContext;

    Dcm_DiagInitDataContext(&lDataContext
                       ,&Dcm_NetPeriodicMsgGetTxBuffer(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle)[1]
                       ,(Dcm_MsgLenType)(DCM_NET_PERIODIC_BUFFER_SIZE - 1u));                                                                        /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

    /* cancel ongoing operation immediately  */
    (void)Dcm_DidMgrReadDid(DCM_CANCEL
                           ,&lDataContext
                           ,&(Dcm_Svc2ASchdGetEntry(schdHandle)->DidContext)
                           ,&(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidOpTypeContext)
                           ,&lNrc);                                                                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Finish scheduled job */
    Dcm_Svc2ASchdFinishEntryProcessing(FALSE);
  }/* else - nothing to do */
}

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByDid(uint16 did)
{
  Dcm_Svc2ASchdItemHandleOptType lSchdHandle;

  if(Dcm_Svc2ASchdGetItemByDid(did, &lSchdHandle) == TRUE)                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    Dcm_Svc2ASchdCancelReadByHandle(lSchdHandle);
  }
}
# endif

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AGetConnectionOfDID()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_Svc2AGetConnectionOfDID(uint16 did)
{
  Dcm_NetConnRefMemType connectionId = DCM_NET_INVALID_CONNID;
  Dcm_Svc2ASchdItemHandleOptType lSchdHandle;

  if(Dcm_Svc2ASchdGetItemByDid(did, &lSchdHandle) == TRUE)                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdHandle);
    if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED)
    {
      connectionId = Dcm_NetPeriodicMsgGetConnection();
    }
  }
  return connectionId;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByHandle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByHandle(Dcm_Svc2ASchdItemHandleOptType schdHandle)
{
  Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(schdHandle);
  if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED)
  {
    pSchdEntry->Rate = DCM_SVC2A_RATE_TYPE_STOPPED;                                                                                                  /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
    /* must have at least one element (this one) */
    Dcm_DebugAssert((Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries > 0)
                   ,DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                           /* COV_DCM_RTM_DEV_DEBUG XF */
    --Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries; /* update statistic */

    Dcm_Svc2ASchdCancelReadByHandle(schdHandle);

    Dcm_NetPeriodicMsgStopDid(pSchdEntry->DidContext.Did);
    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries == 0u)/* scheduler is empty */
    {
      Dcm_NetPeriodicMsgResetConnection(); /* allow other tester to use service 0x2A */
      Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex = 0u;
# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
      Dcm_TmrStopTimer(DCM_TMR_ID_SVC2A_SCHEDULER);/* stop timer updater */
# else
      /* no need to deactivate the task - if the event was set, the task will deactivate itself after a single short
       * execution time activation */
# endif
    }
  }/* else - this item is not scheduled at all */
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByDid(uint16 did)
{
  Dcm_Svc2ASchdItemHandleOptType lSchdHandle;

  if(Dcm_Svc2ASchdGetItemByDid(did, &lSchdHandle) == TRUE)                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    Dcm_Svc2ASchdStopItemByHandle(lSchdHandle);
  }
}
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdGetItemByDid(uint16 did
                                               ,P2VAR(Dcm_Svc2ASchdItemHandleOptType, AUTOMATIC, AUTOMATIC) schdHandle)
{
  boolean lItemFound = FALSE;
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;

  for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
  {
    Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);
    if(pSchdEntry->DidContext.Did == did)
    {
      *schdHandle = lSchdIter;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lItemFound = TRUE;
      break;
    }
  }
  return lItemFound;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFinishEntryProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdFinishEntryProcessing(boolean doSendResponse)
{
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

  pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle);

  if(doSendResponse == TRUE)
  {
    Dcm_Svc2ASchdEntryPtrType pSchdEntry =
      Dcm_Svc2ASchdGetEntry(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex);
    Dcm_NetPeriodicMsgTransmit(pPeriodicTxObj, (PduLengthType)(pSchdEntry->DidContext.DidLength + 1u));                                              /* SBSW_DCM_POINTER_FORWARD_STACK */
  }
  else
  {
    /* release resource if not used */
    Dcm_NetPeriodicMsgRelease(pPeriodicTxObj);                                                                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
  }

  /* free for next DID */
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle = DCM_NET_INVALID_PTXOBJ_HANDLE;

  Dcm_DidMgrDidRelease(DCM_DIDMGR_DIDLOCK_OWNER_READPERIODIC);
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ADidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidLookUp(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                           ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;
  boolean doProcessDid = TRUE;

  if(opStatus == DCM_INITIAL)
  {
    if(pMsgContext->reqDataLen != 0u)
    {
      uint8 perDidLoByte;
      Dcm_DiagConsumeReqDataAsU8(pMsgContext, &perDidLoByte);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

      pRepContext->DidInfoContext.Did = Dcm_Svc2AMakePeriodicDid(perDidLoByte);                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      doProcessDid = FALSE;
    }
  }

  if(doProcessDid == TRUE)
  {
    lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                     ,&(pRepContext->DidInfoContext)
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,DCM_DIDMGR_OP_READ);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    if(lStdReturn == DCM_E_OK)
    {
      pRepContext->HasAnySupportedDids = TRUE; /* register a supported DID */                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
      /* go on with the DID condition check - DCM_E_OK */
    }
    else if(lStdReturn == DCM_E_PENDING)
    {
      /* already set */
    }
    else
    {
      /* Just skip this DID - DCM_E_NOT_OK - request a new client loop */
      lStdReturn = DCM_E_LOOP;
    }
  }
  else
  {
    /* empty run loop ended without any DID to be processed (for this activation of the repeater proxy) */
    /* all DIDs processed */
    if (pRepContext->HasAnySupportedDids == FALSE)
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
    {
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }

  return lStdReturn;
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrClear()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrClear(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle)
{
  Dcm_Svc2CDynDidItemPtrType pItem;

#  if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
  {
    uint16 lDid = Dcm_DidMgrGetDynDidIdFromHandle(dynDidHandle);
    /* Try stopping any active periodic DID (can be still read at that time)! */
    Dcm_Svc2ASchdStopItemByDid(lDid);
  }
#  endif

  pItem = Dcm_Svc2CGetItem(dynDidHandle);
  pItem->Length = 0u;                                                                                                                                /* SBSW_DCM_POINTER_WRITE_2CITEM */
  pItem->Count  = 0u;                                                                                                                                /* SBSW_DCM_POINTER_WRITE_2CITEM */
}
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CCheckAndSetNumOfItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CCheckAndSetNumOfItems(uint8 numRequestedItems
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;
  if ((uint8)(Dcm_DidMgrGetDynDidSize(pRepContext->DynDidHandle) - pRepContext->DynDidItemCount) < numRequestedItems)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
    pRepContext->ReqNumOfItems = numRequestedItems;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_OK;
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CParseAndCheckDynDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CParseAndCheckDynDid(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
    Dcm_DiagConsumeReqDataAsU16(pMsgContext, &pRepContext->DynDidInfoContext.Did);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&pRepContext->DynDidInfoContext                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
                                   ,&pRepContext->DynDidOpTypeContext                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
                                   ,DCM_DIDMGR_OP_DEFINE);

  switch(lStdReturn)
  {
  case DCM_E_OK:
    lStdReturn = Dcm_StateCheck(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DynDidInfoContext))->ExecCondRef                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
                               ,DCM_DIAG_CHK_LVL_PARAMETER
                               ,ErrorCode);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    if (lStdReturn == DCM_E_OK)
    {
      Dcm_Svc2CDynDidItemPtrType pItem;

      Dcm_Svc2C_SetMaxAllowedDynDIDLength(pRepContext);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      pRepContext->DynDidHandle = (Dcm_CfgDidMgrDynDidHandleMemType)Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DynDidInfoContext))->OpRef;               /* SBSW_DCM_PARAM_PTR_WRITE */

      pItem = Dcm_Svc2CGetItem(pRepContext->DynDidHandle);
      pRepContext->DynDidLength = pItem->Length; /* set current length for updates during service processing */                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      pRepContext->SrcItemIndex = Dcm_Svc2CGetSrcItemIndex(pRepContext->DynDidHandle, pItem->Count);                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      pRepContext->DynDidItemCount = pItem->Count;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

      Dcm_DiagProvideResData(pMsgContext, 2u); /* positive response contains the DynDID (2Byte) */                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      /* lStdReturn = DCM_E_OK - already set */
    } /* else DCM_E_NOT_OK (ErrorCode already set) */
    break;
  case DCM_E_PENDING:
    break;
  default: /* DCM_E_NOT_OK */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_Svc2CReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc2CReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Return sub-function specific length (always zero -> dynamic since it depends on the complete request content) */
  return 0u;
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc85EnableDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85EnableDtcSetting(uint8 DemClientId)
{
  Std_ReturnType                     lStdResult;
  Dcm_DemReturnControlDTCSettingType lDemResult;

  if(Dcm_ModeGetControlDtcSettingMode() != RTE_MODE_DcmControlDtcSetting_ENABLEDTCSETTING)
  {
    /* Enable the DTC setting for all DTCs */
# if (DCM_DEM_API_430_ENABLED == STD_ON)
    lDemResult = Dcm_DemAPI(EnableDTCSetting)(DemClientId);
# else
    lDemResult = Dcm_DemAPI(EnableDTCSetting)(DEM_DTC_GROUP_ALL_DTCS, DEM_DTC_KIND_ALL_DTCS);
# endif

    switch (lDemResult)
    {
      case DCM_DEM_RET_CONTROL_DTC_SETTING_OK:
        lStdResult = DCM_E_OK;
        Dcm_ModeSwitchDtcSetting(RTE_MODE_DcmControlDtcSetting_ENABLEDTCSETTING, DEM_DTC_GROUP_ALL_DTCS, DemClientId);
        break;
# if defined (DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING)
      case DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING:
        lStdResult = DCM_E_PENDING;
        break;
# endif
      default:
        lStdResult = DCM_E_NOT_OK;
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
        break;
    }
  }
  else
  {
    lStdResult = DCM_E_OK;
  }
  return lStdResult;
}

# if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc85DisableDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85DisableDtcSetting(Dem_DTCGroupType DTCGroup
                                                                   ,uint8 DemClientId)
{
  Std_ReturnType                     lStdResult;
  Dcm_DemReturnControlDTCSettingType lDemResult;

  /* Disable the DTC setting for all DTCs */
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lDemResult = Dcm_DemAPI(DisableDTCSetting)(DemClientId);
#  else
  lDemResult = Dcm_DemAPI(DisableDTCSetting)(DTCGroup, DEM_DTC_KIND_ALL_DTCS);
#  endif

  switch (lDemResult)
  {
    case DCM_DEM_RET_CONTROL_DTC_SETTING_OK:
      lStdResult = DCM_E_OK;
      Dcm_ModeSwitchDtcSetting(RTE_MODE_DcmControlDtcSetting_DISABLEDTCSETTING, DTCGroup, DemClientId);
      break;
#  if defined (DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING)
    case DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING:
      lStdResult = DCM_E_PENDING;
      break;
#  endif
    default:
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
      break;
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc85ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc85ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Return sub-function specific length (always the same constant) */
  return DCM_SVC_85_REQ_LENGTH;
}

/**********************************************************************************************************************
 *  Dcm_Svc85_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85_XX_RepeaterProxy(Dcm_OpStatusType                     opStatus
                                                                   ,Dcm_MsgContextPtrType                pMsgContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_NegativeResponseCodePtrType      ErrorCode                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_Svc85RepeaterProxyContextPtrType pRepContext)                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType                     lStdResult;
  Dcm_DemReturnControlDTCSettingType lDemResult;
  Dcm_CfgSvc85SubFuncInfoPtrType     pSubFuncInfo;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pSubFuncInfo = Dcm_CfgSvc85SubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
# if (DCM_DEM_API_430_ENABLED == STD_ON)
    lDemResult = pSubFuncInfo->DemFunc(pRepContext->DemClientId);                                                                                    /* SBSW_DCM_CALL_FUNCPTR_SVC85SUBFUNC */
# else
    lDemResult = pSubFuncInfo->DemFunc(pRepContext->DTCGroup, DEM_DTC_KIND_ALL_DTCS);                                                                /* SBSW_DCM_CALL_FUNCPTR_SVC85SUBFUNC */
# endif
    switch(lDemResult)
    {
    case DCM_DEM_RET_CONTROL_DTC_SETTING_OK:
      /* success */
      lStdResult = DCM_E_OK;
      break;
# if defined (DCM_DEM_RET_CONTROL_DTC_SETTING_N_OK)
    case DCM_DEM_RET_CONTROL_DTC_SETTING_N_OK:
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      break;
# endif
# if defined (DCM_DEM_RET_CONTROL_DTC_WRONG_DTCGROUP)
    case DCM_DEM_RET_CONTROL_DTC_WRONG_DTCGROUP:
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      break;
# endif
# if defined (DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING)
    case DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING:
      lStdResult = DCM_E_PENDING;
      break;
# endif
    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      lStdResult = DCM_E_NOT_OK;
      break;
    }
  }

  return lStdResult;
}
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc86ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc86ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc86SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Module API function implementations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_VERSION_INFO_API == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetVersionInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_GetVersionInfo(P2VAR(Std_VersionInfoType, AUTOMATIC, DCM_APPL_DATA) versioninfo)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(versioninfo == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    versioninfo->vendorID = (uint16)DCM_VENDOR_ID;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->moduleID = (uint16)DCM_MODULE_ID;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
# if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
    versioninfo->instanceID = (uint16)0;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
# endif
    versioninfo->sw_major_version = (uint8)DCM_SW_MAJOR_VERSION;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->sw_minor_version = (uint8)DCM_SW_MINOR_VERSION;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->sw_patch_version = (uint8)DCM_SW_PATCH_VERSION;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETVERSIONINFO, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TriggerTransmit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_TriggerTransmit(PduIdType txPduId
                                                  ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) pTxPduInfo)
{
  Std_ReturnType lResult;
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsTxPduIdValid(txPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(pTxPduInfo == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(pTxPduInfo->SduDataPtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(Dcm_NetPeriodicMsgGetConnection() != Dcm_NetGetConnIdOfTxPduId(txPduId))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
# endif
  {
    Dcm_CfgNetPTxObjHandleMemType lPerTxObjHandle;

    lPerTxObjHandle = (Dcm_CfgNetPTxObjHandleMemType)Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId);
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    if(Dcm_NetPeriodicMsgNumMsgsCurrConnection() <= lPerTxObjHandle)
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
# endif
    {
      P2VAR(PduInfoType, AUTOMATIC, DCM_VAR_NOINIT) txPduInfoPtr = &(Dcm_NetGetPeriodicTxObject(lPerTxObjHandle)->TxPduInfo);

      Dcm_UtiMemCopySafe(txPduInfoPtr->SduDataPtr
                        ,pTxPduInfo->SduDataPtr
                        ,0u
                        ,pTxPduInfo->SduLength
                        ,txPduInfoPtr->SduLength);                                                                                                   /* SBSW_DCM_COMB_PTR_FORWARD */

      pTxPduInfo->SduLength = txPduInfoPtr->SduLength;                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = E_OK;
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TRIGGERTRANSMIT, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */

/**********************************************************************************************************************
 *  Dcm_GetActiveProtocol()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetActiveProtocol(P2VAR(Dcm_ProtocolType, AUTOMATIC, DCM_APPL_DATA) ActiveProtocol)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(ActiveProtocol == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#endif
  {
#if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
    if(Dcm_NetGetProtIdOfActiveProtocol() >= DCM_NET_INVALID_PROTID)
    {
      *ActiveProtocol = DCM_NO_ACTIVE_PROTOCOL;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
#endif
    {
      *ActiveProtocol = Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfActiveProtocol()].Id;                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETACTIVEPROTOCOL, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetTesterSourceAddress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetTesterSourceAddress(PduIdType DcmRxPduId
                                                         ,P2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) TesterSourceAddress)
{
  Std_ReturnType lResult;
  uint8          lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = DCM_E_NOT_OK;
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(DcmRxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(TesterSourceAddress == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#endif
  {
    lResult = DCM_E_OK;
    *TesterSourceAddress = Dcm_PbCfgNetConnectionInfo[Dcm_NetGetConnIdOfRxPduId(DcmRxPduId)].ClientSrcAddr;                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETTESTERSOURCEADDRESS, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  return lResult;
}

#if (DCM_DIAG_VIRTUAL_REQUEST_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ProcessVirtualRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ProcessVirtualRequest(PduIdType     RxPduId
                                                        ,Dcm_MsgType   Data
                                                        ,PduLengthType Length)
{
  Std_ReturnType lResult;
  uint8          lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = DCM_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(RxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Data == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  /* if (length > <BufferSize>)
  {
    This check is done through the Dcm_NetRxIndInternal API!
  }
  else */
# endif
  {
    lResult = Dcm_NetRxIndInternal(RxPduId, Data, Length);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_PROCESSVIRTUALREQUEST, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_SetActiveDiagnostic()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetActiveDiagnostic(boolean active)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ( (active != DCM_NET_COMM_ACTIVE)
          &&(active != DCM_NET_COMM_NOT_ACTIVE) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#endif
  {
    /* #30 Enter critical section (Reason: API is reentrant) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    /* #40 Apply new ComM management state */
    Dcm_SingletonContext.Network.ActiveDiagnostic = active;
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* #50 Leave critical section */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_SETACTIVEDIAGNOSTIC, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetRequestKind()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetRequestKind(uint16 TesterSourceAddress
                                                 ,P2VAR(Dcm_RequestKindType, AUTOMATIC, DCM_APPL_DATA) RequestKind)
{
  Std_ReturnType lResult = DCM_E_NOT_OK;
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (RequestKind == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#endif
  {
    Dcm_NetConnRefMemType connId;

    connId = Dcm_NetGetConnIdByTesterAddress(TesterSourceAddress);

    /* #30 Check if the tester source address is a valid one */
    if (connId < DCM_NET_INVALID_CONNID)
    {
      Dcm_NetTransportObjectPtrType pTranspObj;

      /* Assure that no interrupt will change the state of the conn2tobj map and the tobj state/flags */
      Dcm_UtiArEnvEnterCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
      pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(connId);

      if (pTranspObj == NULL_PTR)
      {
        *RequestKind = DCM_REQ_KIND_NONE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      else
      {
        /* #50 If for this tester any request is ongoing: */
        if (pTranspObj->State != DCM_NET_TOBJ_STATE_FREE)
        {
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
          /* #60 Determine the kind of the request */
          if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0)
          {
            *RequestKind = DCM_REQ_KIND_ROE;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
          }
          else
#endif
          {
            *RequestKind = DCM_REQ_KIND_EXTERNAL;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
          }
        }
        else
        {
          /* #70 Otherwise consider this tester idling */
          *RequestKind = DCM_REQ_KIND_NONE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
        }
      }
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
      Dcm_UtiArEnvLeaveCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

      lResult = DCM_E_OK;
    }/* else - result already set to NOT_OK */
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETREQUESTKIND, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  /* #200 Return the final result */
  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ComM_NoComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_NoComModeEntered(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetComMContextPtrType pComMContext = Dcm_NetGetComMContext(0);

    Dcm_UtiArEnvEnterCriticalSection(); /* Avoid concurrent access on registerNetworks from an interrupt  */                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pComMContext->ComState = DCM_NET_COMM_STATE_RX_DIS_TX_DIS;                                                                                       /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERNOCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ComM_SilentComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_SilentComModeEntered(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetComMContextPtrType pComMContext = Dcm_NetGetComMContext(0);

    Dcm_UtiArEnvEnterCriticalSection(); /* Avoid concurrent access on registerNetworks from an interrupt  */                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pComMContext->ComState = DCM_NET_COMM_STATE_RX_EN_TX_DIS;                                                                                        /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERSILENTCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ComM_FullComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_FullComModeEntered(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetComMContextPtrType pComMContext = Dcm_NetGetComMContext(0);

    Dcm_UtiArEnvEnterCriticalSection(); /* Avoid concurrent access on registerNetworks from an interrupt  */                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pComMContext->ComState = DCM_NET_COMM_STATE_RX_EN_TX_EN;                                                                                         /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERFULLCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ProvideRxBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_ProvideRxBuffer(PduIdType DcmRxPduId
                                                     ,PduLengthType TpSduLength
                                                     ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) *PduInfoPtr)
{
  BufReq_ReturnType lResult;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = BUFREQ_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(DcmRxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(PduInfoPtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    lResult = Dcm_NetProvideRxBuffer(DcmRxPduId, TpSduLength, PduInfoPtr, DCM_NET_TOBJ_FLAG_NONE);                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_PROVIDERXBUFFER, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_RxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_RxIndication(PduIdType DcmRxPduId
                                     ,Dcm_NetArEnvNotifResultType Result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(DcmRxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfRxPduId(DcmRxPduId));

    if(pTranspObj == NULL_PTR)
    {
      /* just ignore in case the DCM_E_NOT_OK from ProvideRxBuffer has led to the RxIndication
       * (AR does not specify what will happen after this) */
    }
    else
    {
      if(pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX)/* expected state for Rx indication? */
      {
        /* Consider also any nested request on different TP connection but from the same tester! */
        if(DcmRxPduId == pTranspObj->RxPduId)
        {
          if(Result != DCM_NET_ARENV_NTFRSLT_OK)
          {
            Dcm_NetTpRxIndicationNotOk(pTranspObj);                                                                                                  /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
          }
          else
          {
            Dcm_NetTpRxIndicationOk(pTranspObj);                                                                                                     /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
          }
        }/* else - indication of unexpected connection */
      }/* else- could be an unexpected API call but most probably it is due to a concurrent request
        * (StartOfReception returns DCM_E_NOT_OK) from the same tester */
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_RXINDICATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_ProvideTxBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_ProvideTxBuffer(PduIdType DcmTxPduId
                                                     ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) *PduInfoPtr
                                                     ,PduLengthType Length)
{
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsTxPduIdValid(DcmTxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(PduInfoPtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfTxPduId(DcmTxPduId));

    DCM_IGNORE_UNREF_PARAM(DcmTxPduId);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */

    if(pTranspObj == NULL_PTR)                                                                                                                       /* COV_DCM_RTM_UNREACHABLE XF */
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
      /* Always check for valid call state - if free or skip -> ignore call
       * This check is necessary in case Dcm_Init is called some time during ongoing transmission or
       * The ongoing transmission is set to "canceled" (pending TxCancelation)! */
      if( (pTranspObj->State == DCM_NET_TOBJ_STATE_ONTX)
# if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
        &&((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) == 0)
# endif
        )
      {
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
        if(pTranspObj->ResType == DCM_NET_TOBJ_RESTYPE_PAGED)
        {
          lResult = Dcm_PagedBufferCopyData(&pTranspObj->BuffInfo, Length);                                                                          /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
        }
        else
# endif
        {
          DCM_IGNORE_UNREF_PARAM(Length);                                                                                                            /* PRQA S 3112 */ /* MD_Dcm_3112 */
          /* Linear case */
          /* the current buffer is the only one */
          lResult = BUFREQ_OK;
        }

        /* set PduInfo, just in case this is the first call */
        *PduInfoPtr = &(pTranspObj->BuffInfo);                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_PROVIDETXBUFFER, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TxConfirmation(PduIdType DcmTxPduId
                                       ,NotifResultType Result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(DcmTxPduId);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsTxPduIdValid(DcmTxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
    /* check if TxPdu is main TxPdu (which is used for TP communication)  */
    /* Note: in ASR3, the TxPdu is identical to the TxConfPdu             */
    if (Dcm_PbCfgNetConnectionInfo[Dcm_NetGetConnIdOfTxPduId(DcmTxPduId)].TxPduIdMain != DcmTxPduId)
    {
      if(Dcm_NetPeriodicMsgGetConnection() != Dcm_NetGetConnIdOfTxPduId(DcmTxPduId))
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else if(Dcm_NetPeriodicMsgGetHandleFromTxPduId(DcmTxPduId) >= Dcm_NetPeriodicMsgNumMsgsCurrConnection())
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
      {
        /* confirmation of IF transmission */
        Dcm_NetPeriodicMsgRelease(Dcm_NetGetPeriodicTxObject(Dcm_NetPeriodicMsgGetHandleFromTxPduId(DcmTxPduId)));                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
      }
    }
    else
# endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */
    {
      /* confirmation of TP transmission */
      Dcm_NetTpTxConfirmation(DcmTxPduId, Result);
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TXCONFIRMATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ComM_NoComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_NoComModeEntered(NetworkHandleType networkId)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_DIS_TX_DIS);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERNOCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ComM_SilentComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_SilentComModeEntered(NetworkHandleType networkId)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_EN_TX_DIS);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERSILENTCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ComM_FullComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_FullComModeEntered(NetworkHandleType networkId)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_EN_TX_EN);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERFULLCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

# if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnRequestDetection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_OnRequestDetection(PduIdType canTpRxPduId
                                           ,uint8 tpAddrExtension)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#  if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  /* #10 Check initialization state */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
#  endif
  {
    /* #20 Check whether the CanTpPduId is between the upper and lower bound of DCM CanTpPduIds */
    if(
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
        (Dcm_PbCfgNetNumCanRxPduIds > 0) &&  /* Check for a non-empty map */
#  endif
        ( (canTpRxPduId >= Dcm_PbCfgNetCanTpRxPduIdMin)
        &&(canTpRxPduId <= Dcm_PbCfgNetCanTpRxPduIdMax) )
      )
    {
      PduIdType lDcmRxPduId;

      /* #30 Retrieve the DCM RxPduId from the CanTp PduId */
      lDcmRxPduId = Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpRxPduId);

      /* #40 Check for DCM connection on this SDU */
      if(lDcmRxPduId < Dcm_PbCfgNetNumRxPduIds)
      {
        Dcm_NetConnRefMemType lConnId = Dcm_NetGetConnIdOfRxPduId(lDcmRxPduId);

        /* #50 Compare the N_TA with the own ECU address. React only on external ECU requests */
        if(Dcm_NetGetNodeAddress(lConnId) != tpAddrExtension)
        {
          Dcm_NetOnRequestDetection(lConnId);
        }/* else - a DcmPduId and the same N_TA -> request will be ignored on task level */
      }/* else - not a DcmPduId or a functional DcmPduId -> ignore */
    }/* else - not a DcmPduId -> ignore */
  }

#  if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_ONREQUESTDETECTION, lErrorId);
  }
#  else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#  endif
}
# endif

/**********************************************************************************************************************
 *  Dcm_StartOfReception()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_StartOfReception(PduIdType rxPduId
# if (DCM_PDUR_API_412_ENABLED == STD_ON)
                                                      ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                             /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
# endif
                                                      ,PduLengthType tpSduLength
                                                      ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr)
{
  BufReq_ReturnType lResult;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = BUFREQ_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(bufferSizePtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#  if (DCM_PDUR_API_412_ENABLED == STD_ON)
  /* infoPool and meta-data not supported yet -> must always be NULL_PTR for DCM PDUs */
  if(info != NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#  endif
# endif
  {
# if (DCM_PDUR_API_412_ENABLED == STD_ON)
    DCM_IGNORE_UNREF_PARAM(info);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
    lResult = Dcm_NetStartOfReception(rxPduId, tpSduLength, bufferSizePtr, DCM_NET_TOBJ_FLAG_NONE);                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_STARTOFRECEPTION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_CopyRxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_CopyRxData(PduIdType rxPduId
                                                ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr)
{
  BufReq_ReturnType  lResult = BUFREQ_E_NOT_OK;
  uint8              lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_NetIsPduInfoValid(info) == FALSE)                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(bufferSizePtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfRxPduId(rxPduId));

    DCM_IGNORE_UNREF_PARAM(rxPduId);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

    /* Check always for valid call state - if free or ready -> ignore call
    * This check is necessary in case Dcm_Init is called some time during ongoing transmission
    */
    if(pTranspObj == NULL_PTR)
    {
      /* Check for valid call state */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
      Dcm_DebugAssert((rxPduId == pTranspObj->RxPduId), DCM_SID_COPYRXDATA, DCM_E_ILLEGAL_STATE)                                                     /* COV_DCM_RTM_DEV_DEBUG XF */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if(pTranspObj->State != DCM_NET_TOBJ_STATE_ONRX)/* expected state for copy Rx? */                                                              /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY XF */
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
# endif
      {
        lResult = Dcm_NetCopyRxData(pTranspObj, info, bufferSizePtr);                                                                                /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COPYRXDATA, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TpRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TpRxIndication(PduIdType rxPduId
                                       ,Dcm_NetArEnvNotifResultType result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    Dcm_NetTpRxIndication(rxPduId, result);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TPRXINDICATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_CopyTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_CopyTxData(PduIdType txPduId
                                                ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                ,P2VAR(RetryInfoType, AUTOMATIC, DCM_APPL_DATA) retry                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr)
{
  BufReq_ReturnType lResult  = BUFREQ_E_NOT_OK;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsTxPduIdValid(txPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_NetIsPduInfoValid(info) == FALSE)                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(availableDataPtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if( (retry != NULL_PTR) /* else - if(retry == NULL_PTR) -> not used => OK */
         &&(retry->TpDataState != TP_DATACONF) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfTxPduId(txPduId));

    DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(retry);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

    if(pTranspObj == NULL_PTR)
    {
      /* Check for valid call state */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if(pTranspObj->State != DCM_NET_TOBJ_STATE_ONTX)                                                                                               /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY XF */
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
# endif
      {
        lResult = Dcm_NetCopyTxData(pTranspObj, info, availableDataPtr);                                                                             /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COPYTXDATA, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TpTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TpTxConfirmation(PduIdType txPduId
                                         ,Dcm_NetArEnvNotifResultType result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsTxPduIdValid(txPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfTxPduId(txPduId));

    if(pTranspObj == NULL_PTR)
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if(pTranspObj->State != DCM_NET_TOBJ_STATE_ONTX)
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
# endif
      {
        Dcm_NetUsdtTxConfirmation(pTranspObj, Dcm_NetArEnvGetTransmResult(result));                                                                  /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TPTXCONFIRMATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TxConfirmation(PduIdType txPduId)
{
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  uint8 lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsTxPduIdValid(txPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_NetPeriodicMsgGetConnection() != Dcm_NetGetConnIdOfTxPduId(txPduId))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else if(Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId) >= Dcm_NetPeriodicMsgNumMsgsCurrConnection())
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
#  endif /* (DCM_DEV_ERROR_DETECT == STD_ON) */
  {
    Dcm_NetPeriodicMsgRelease(Dcm_NetGetPeriodicTxObject(Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId)));                                          /* SBSW_DCM_POINTER_FORWARD_STACK */
  }

#  if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TXCONFIRMATION, lErrorId);
  }
#  else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#  endif
# else
  /* Function is not used since 0x2A or periodic messages are not available.
   * Note: PduR may still need this API to be able to link in case periodic messages are available, but SID 0x2A shall
   * not be supported.
   */
  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */
}
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_ResetToDefaultSession()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ResetToDefaultSession(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
#endif
  {
    /* Just register an externally triggered request for changing back to default diagnostic session */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF);
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_RESET2DEFAULTSESSION, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif
  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetSesCtrlType()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSesCtrlType(P2VAR(Dcm_SesCtrlType, AUTOMATIC, DCM_APPL_DATA) SesCtrlType)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(SesCtrlType == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#endif
  {
    /* Return the diagnostic session ID of the currently (still) active (committed not pending) diagnostic session state */
    *SesCtrlType = Dcm_CfgStateSessionInfo[Dcm_UtiGetBitPosition(Dcm_SingletonContext.StateMgr.Preconditions.Session)].Value;                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETSESCTRLTYPE, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  return DCM_E_OK;
}

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetSecurityLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSecurityLevel(P2VAR(Dcm_SecLevelType, AUTOMATIC, DCM_APPL_DATA) SecLevel)
{
  uint8 lErrorId = DCM_E_NO_ERROR;
  uint8 stateIdx = Dcm_UtiGetBitPosition(Dcm_SingletonContext.StateMgr.Preconditions.Security);

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(SecLevel == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    /* Return the security access level ID of the currently active security access level state */
    *SecLevel = Dcm_StateGetSecurityValue(stateIdx);                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETSECLEVEL, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return DCM_E_OK;
}
#endif

#if (DCM_STATE_SECURITY_EXT_SETTER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_SetSecurityLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetSecurityLevel(Dcm_SecLevelType SecLevel)
{
  Std_ReturnType lResult;
  uint8          lErrorId = DCM_E_NO_ERROR;
  sint8_least    lStateIdx;

  /* #10 Convert security access level to internal zero based security access state handle */
  lStateIdx = Dcm_StateFindStateIndexFromSecLevel(SecLevel);/* Calling this API is safe since it does not depend on any internal DCM state (no initialization is needed!) */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = DCM_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (lStateIdx < 0)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    /* #50 Check for valid API call context */

    /* Protect against any ISR or higher priority tasks */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if(Dcm_TskTraceIsEmpty())
    {
      /* No task active: this API is called outside of any DCM main-function context! */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else if(Dcm_TskTraceGetCurrTskId() != DCM_TSK_ID_DIAG_WORK)
    {
      /* A task is active, but not the correct one: worker task with low priority! */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
      /* Needed by MISRA */
    }
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if(lErrorId == DCM_E_NO_ERROR)
# endif
    {
      Dcm_StateSetSecurity((Dcm_StateIndexOptType)lStateIdx);
      lResult = DCM_E_OK;
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_SETSECLEVEL, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSecurityLevelFixedBytes(Dcm_SecLevelType SecLevel
                                                             ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) FixedBytes
                                                             ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) BufferSize)
{
  Std_ReturnType  lResult;
  uint8           lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = DCM_E_NOT_OK;

  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ((FixedBytes == NULL_PTR) || (BufferSize == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    lResult = Dcm_StateGetSecurityLevelFixedBytes(SecLevel, FixedBytes, BufferSize);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETSECLEVELFIXEDBYTES, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif
/**********************************************************************************************************************
 *  Dcm_InitMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_InitMemory(void)
{
  /* Destroy default RAM content of all DCM variables (for uninitialized global variable revelation) */
  Dcm_UtiRamShredder(Dcm_SingletonContext, DCM_VAR_NOINIT);                                                                                          /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
  Dcm_UtiRamShredder(Dcm_InstanceContext,  DCM_VAR_NOINIT);                                                                                          /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */

  /* Initialize memory of sub-components */
  Dcm_DebugInitMemory(); /* Initialize first to start monitoring the module initialization */
}

/**********************************************************************************************************************
 *  Dcm_Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Init(Dcm_ConfigPtrType configPtr)
{
  DCM_IGNORE_UNREF_PARAM(configPtr);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
  if(Dcm_VarMgrInit(configPtr) == TRUE)                                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
#endif
  {
    /* Initialize run-time kernel sub-system */
    Dcm_TmrInit();
    Dcm_TskInit();

    /* Initialize communication sub-systems */
    Dcm_NetInit();
    Dcm_PagedBufferInit();

    /* Initialize diagnostic service helpers sub-systems */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
    Dcm_DidMgrInit();
#endif
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
    Dcm_MemMgrInit();
#endif

    /* Initialize diagnostic state management sub-systems */
    Dcm_ModeInit();
    Dcm_StateInit();

    /* Initialize diagnostic service processing kernel sub-system */
    Dcm_DiagInit();

    /* Initialize debug sub-component as last to mark DCM as completely initialized */
    Dcm_DebugInit();/* from now on the DCM is ready to work */
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MainFunctionTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_MainFunctionTimer(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_HIGH);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif

#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MainFunctionWorker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_MainFunctionWorker(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_LOW);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif

#if (DCM_SPLIT_TASKS_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_MainFunction()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_MainFunction(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_NONE);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif
#if(DCM_DIAG_EXTERN_SVC_HANDLING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OptimizedProcessingDone()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_OptimizedProcessingDone(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_ProcessingDone();
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_EXT_PROCESSINGDONE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif

#if(DCM_DIAG_EXTERN_SVC_HANDLING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OptimizedSetNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_OptimizedSetNegResponse(Dcm_NegativeResponseCodeType errorCode)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_SetNegResponse(errorCode);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_EXT_PROCESSINGDONE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ProvideRecoveryStates()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ProvideRecoveryStates(
                                                    P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo)
{
  Std_ReturnType  lResult;
  uint8           lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = DCM_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(RecoveryInfo == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    Dcm_DiagProvideRecoveryStates(RecoveryInfo);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
    lResult = DCM_E_OK;
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_PROVIDERECOVERYSTATES, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif
#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VsgSetSingle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgSetSingle(Dcm_VsgIdentifierType VsgId
                                               ,Dcm_VsgStateType State)
{
  /* ----- Local Variables ---------------------------------------------- */
  Std_ReturnType lStdResult;
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ------------------------------------- */
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lStdResult = DCM_E_NOT_OK;

  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ( (VsgId >= DCM_VARMGR_NUM_CFG_VARIANTS)
         || (VsgId == 0))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  /* ----- Implementation ----------------------------------------------- */
  {
    lStdResult = DCM_E_OK;

    Dcm_VarMgrVsgSetSingle(VsgId, State);
  }

  /* ----- Development Error Report --------------------------------------- */
# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_VSGSETSINGLE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lStdResult;
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VsgIsActive()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgIsActive(Dcm_VsgIdentifierType VsgId
                                              ,P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State)
{
  /* ----- Local Variables ---------------------------------------------- */
  Std_ReturnType lStdResult;
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ------------------------------------- */
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lStdResult = DCM_E_NOT_OK;

  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ( (VsgId >= DCM_VARMGR_NUM_CFG_VARIANTS)
         || (VsgId == 0))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if (State == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  /* ----- Implementation ----------------------------------------------- */
  {
    lStdResult = DCM_E_OK;

    Dcm_VarMgrVsgIsActive(VsgId, State);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* ----- Development Error Report --------------------------------------- */
# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_VSGISACTIVE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lStdResult;
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VsgSetMultiple()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgSetMultiple(P2CONST(Dcm_VsgIdentifierType, AUTOMATIC, DCM_APPL_DATA) VsgIdList
                                                 ,uint16 VsgListSize
                                                 ,Dcm_VsgStateType State)
{
  /* ----- Local Variables ---------------------------------------------- */
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ------------------------------------- */
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ( (VsgListSize > DCM_VARMGR_NUM_CFG_VARIANTS)
         || (VsgListSize == 0u) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else if (VsgIdList == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  /* ----- Implementation ----------------------------------------------- */
  {
    Dcm_VsgIdentifierType lVsgIter;

    /* Iterate over all passed VSGs */
    for (lVsgIter = 0; lVsgIter < VsgListSize; ++lVsgIter)
    {
      lStdResult = Dcm_VsgSetSingle(VsgIdList[lVsgIter], State);

      if(lStdResult == DCM_E_NOT_OK)
      {
        break;
      }
    }
  }

  /* ----- Development Error Report --------------------------------------- */
# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_VSGSETMULTIPLE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VsgIsActiveAnyOf()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgIsActiveAnyOf(P2CONST(Dcm_VsgIdentifierType, AUTOMATIC, DCM_APPL_DATA) VsgIdList
                                                 ,uint16 VsgListSize
                                                 ,P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State)
{
  /* ----- Local Variables ---------------------------------------------- */
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ------------------------------------- */
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ( (VsgListSize > DCM_VARMGR_NUM_CFG_VARIANTS)
         || (VsgListSize == 0u) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else if (State == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if (VsgIdList == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  /* ----- Implementation ----------------------------------------------- */
  {
    Dcm_VsgIdentifierType lVsgIter;

    /* Iterate over all passed VSGs */
    for (lVsgIter = 0; lVsgIter < VsgListSize; ++lVsgIter)
    {
      lStdResult = Dcm_VsgIsActive(VsgIdList[lVsgIter], State);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

      if( (lStdResult == DCM_E_NOT_OK)
        ||(*State == DCM_VSG_ENABLED) )
      {
        break;
      }
    }
  }

  /* ----- Development Error Report --------------------------------------- */
# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_VSGISACTIVEANY, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Module internal API function implementations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrReadUdsMid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrReadUdsMid(Dcm_ObdIdMgrHandleMemType handle
                                                     ,Dcm_OpStatusType opStatus
                                                     ,Dcm_DiagDataContextPtrType pDataContext)
{
  Std_ReturnType                 lStdResult = DCM_E_OK; /* if no data to be returned -> positive response */
  uint16                         lTestValue;
  uint16                         lMinLimit;
  uint16                         lMaxLimit;
  Dcm_DTRStatusType              lStatus;
  Dcm_CfgSvc06Mid2TidRefOptType  lHandle    = Dcm_CfgSvc06Mid2TidRefMap[handle];
  Dcm_CfgSvc06Mid2TidRefOptType  lMaxHandle = Dcm_CfgSvc06Mid2TidRefMap[handle + 1];
  Dcm_CfgSvc06MidTidInfoPtrType  pMidTidInfo;

  for(;lHandle<lMaxHandle; lHandle++)
  {
    pMidTidInfo = Dcm_CfgSvc06MidTidInfoGetEntryOrNull(lHandle);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    if(pMidTidInfo == NULL_PTR)                                                                                                                      /* PRQA S 3415 */ /* MD_Dcm_3415 */ /* COV_DCM_RTM_RUNTIME_CHECK TF xf xf */ /* SBSW_DCM_PARAM_PTR_FORWARD */
    {
      lStdResult = DCM_E_NOT_OK;
    }
    else
#  endif
    {
      lStdResult = pMidTidInfo->OpFunc(opStatus, &lTestValue, &lMinLimit, &lMaxLimit, &lStatus);                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */ /* SBSW_DCM_CALL_FUNCPTR_SVC06MIDTIDINFO */
      if (lStdResult == DCM_E_OK)
      {
        if(lStatus == DCM_DTRSTATUS_INVISIBLE)
        {
          lTestValue = 0;
          lMinLimit  = 0;
          lMaxLimit  = 0;
        }

        /* Copy data */
        Dcm_DiagProvideDataAsU8(pDataContext, pMidTidInfo->Tid);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagProvideDataAsU8(pDataContext, pMidTidInfo->Uasid);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagProvideDataAsU16(pDataContext, lTestValue);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagProvideDataAsU16(pDataContext, lMinLimit);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagProvideDataAsU16(pDataContext, lMaxLimit);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }

    if(lStdResult != DCM_E_OK)
    {
      break;
    }
  }

  return lStdResult;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_IsDidAvailable()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_IsDidAvailable(uint16 DID
                                                    ,Dcm_OpStatusType OpStatus
                                                    ,P2VAR(Dcm_DidSupportedType, AUTOMATIC, DCM_VAR_NOINIT) supported)
{
  uint8 lOBDMid = Dcm_UtiGetLoByte(DID);

  DCM_IGNORE_UNREF_PARAM(OpStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  *supported = DCM_DID_NOT_SUPPORTED;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */

  /* #10 Check kind of DID (Availability ID or Data ID) */
  if (Dcm_ObdIdMgrIsAvailabilityId(DID))
  {
    /* #20 If DID is a availability ID  */
    uint32 lObdMidAvailMask;

    /* #30 Request value of availabity ID from Dem */
    if (Dem_DcmGetAvailableOBDMIDs(lOBDMid, &lObdMidAvailMask) == E_OK)                                                                              /* SBSW_DCM_POINTER_FORWARD_STACK */
    {
      /* #40 If request ist successful */
      /* #50 Report to caller that DID is available */
      *supported = DCM_DID_SUPPORTED;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else
  {
    /* #60 If DID is Data ID */
    uint8 lNumOfTIDs;

    /* #70 Request number of TIDs for Data ID */
    if (Dem_DcmGetNumTIDsOfOBDMID(lOBDMid, &lNumOfTIDs) == E_OK)                                                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */
    {
      /* #80 If request is successful */
      /* #90 Report to caller that DID is available */
      *supported = DCM_DID_SUPPORTED;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  return DCM_E_OK;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidRangeDataLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidRangeDataLength(uint16 DID
                                                                       ,Dcm_OpStatusType OpStatus
                                                                       ,Dcm_DidMgrDidLengthPtrType DataLength)

{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(OpStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* #10 Check kind of DID (Availability ID or Data ID) */
  if (Dcm_ObdIdMgrIsAvailabilityId(DID))
  {
    /* #20 If DID is an availability ID  */
    /* #30 Set data length to 4 */
    *DataLength = 4u;                                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* #40 Otherwise DID is a Data ID */
    uint8 lObdMid = Dcm_UtiGetLoByte(DID);
    uint8 lNumOfTIDs;

    /* #50 Request number of TIDs for Data ID */
    if (Dem_DcmGetNumTIDsOfOBDMID(lObdMid, &lNumOfTIDs) == E_OK)                                                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */
    {
      /* #60 If request is successful calculate total response data length */
      *DataLength = lNumOfTIDs * 8;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* #70 Otherwise something went wrong - report back */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData(uint16 DID
                                                          ,Dcm_OpStatusType OpStatus
                                                          ,Dcm_DiagDataContextPtrType pDataContext)
{
  Std_ReturnType lStdResult;
  uint8 lObdMid = Dcm_UtiGetLoByte(DID);

  DCM_IGNORE_UNREF_PARAM(OpStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* #10 Check kind of DID (Availability ID or Data ID) */
  if (Dcm_ObdIdMgrIsAvailabilityId(DID))
  {
    /* #20 If DID is a availability ID */
    /* #30 Read value of availabiltity Id */
    lStdResult = Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId(lObdMid, pDataContext);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  /* #40 Otherwise */
  else
  {
    /* #50 Read Value of Data Id */
    lStdResult = Dcm_ObdIdMgr_F6XX_ReadDidData_DataId(lObdMid, pDataContext);                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  return lStdResult;
}
# endif

# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetDidAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(uint32, DCM_CODE) Dcm_ObdIdMgrGetDidAvailabilityMask(uint16 DidLookUpRefStart
                                                         ,uint16 DidLookUpRefEnd
                                                         ,Dcm_ObdIdMgrMaskValueTableType maskValue)
{
  uint32 lResultMask;
  uint16_least lLookUpIter;

  DCM_IGNORE_UNREF_PARAM(maskValue);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lResultMask = 0;

  /* #10 Iterate over all (WWH-)OBD DIDs related to the AID */
  for(lLookUpIter  = DidLookUpRefStart;
      lLookUpIter <= DidLookUpRefEnd;
      ++lLookUpIter)
  {
    Dcm_DidMgrDidInfoContextType lDidInfoContext;
    uint8 lDidLowByte;

    /* #20 Consider only the DID low-byte since the AID reports the availability mask only for a certain
     * DID range (e.g 0xF4XX).
     */
    lDidLowByte = Dcm_UtiGetLoByte(Dcm_CfgDidMgrDidLookUpTable[lLookUpIter]);

    lDidInfoContext.Descriptor.DidInfoIdx = (Dcm_CfgDidMgrDidInfoRefType)(lLookUpIter - 1);
    Dcm_DidMgrInitOpInfo(&lDidInfoContext, DCM_DIDMGR_OP_READ);                                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

    /* #30 If the DID is (still) supported: */
    if(Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgDidMgrGetDidOpInfo(&lDidInfoContext)->ExecCondRef) == TRUE)
    {
      /* #40 Set the corresponding bit in the availability bitmap */
      Dcm_UtiBitOpSet(uint32, lResultMask, Dcm_ObdIdMgrGetObdIdMaskBit(lDidLowByte));
    }
  }

#  if (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
  /* #50 Consider any DIDs additionally suppressed by calibration procedure */
  lResultMask &= maskValue;
#  endif

  /* #60 Return calculated availability ID bitmap */
  return lResultMask;
}
# endif

# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetRidAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(uint32, DCM_CODE) Dcm_ObdIdMgrGetRidAvailabilityMask(uint16 RidLookUpRefStart
                                                         ,uint16 RidLookUpRefEnd
                                                         ,Dcm_ObdIdMgrMaskValueTableType maskValue)
{
  uint32 lResultMask;
  uint16_least lLookUpIter;

  DCM_IGNORE_UNREF_PARAM(maskValue);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lResultMask = 0;
  /* #10 Iterate over all (WWH-)OBD RIDs related to the AID */
  for(lLookUpIter  = RidLookUpRefStart;
      lLookUpIter <= RidLookUpRefEnd;
      ++lLookUpIter)
  {
    uint8 lRidLowByte;
    /* #20 Consider only the RID low-byte since the AID reports the availability mask only for a certain
     * RID range (e.g 0xE0XX).
     */
    lRidLowByte = Dcm_UtiGetLoByte(Dcm_CfgRidMgrRidLookUpTable[lLookUpIter]);

    /* #30 If the RID is (still) supported: */
    if(Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgRidMgrRidInfo[lLookUpIter-1].ExecCondRef) == TRUE)
    {
      /* #40 Set the corresponding bit in the availability bitmap */
      Dcm_UtiBitOpSet(uint32, lResultMask, Dcm_ObdIdMgrGetObdIdMaskBit(lRidLowByte));
    }
  }

#  if (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
  /* #50 Consider any RIDs additionally suppressed by calibration procedure */
  lResultMask &= maskValue;
#  endif

  /* #60 Return calculated availability ID bitmap */
  return lResultMask;
}
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_UtiLookUpUint8()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpUint8(Dcm_Uint8ConstDataPtrType lookUpTable, uint8 value)
{
  sint16_least iter;
  sint16_least lResult = -1;

  for(iter = (sint16_least)lookUpTable[0]; iter>0; --iter)
  {
    if(lookUpTable[iter] == value)
    {
      lResult = (sint16_least)(iter-1);
      break;
    }
  }
  return lResult;
}

#if(DCM_UTI_NVM_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_UtiNvMRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMRead(Dcm_OpStatusType                opStatus
                                             ,Dcm_GenericDcmRamNoInitPtrType  data
                                             ,uint16                          blockId)
{
  Std_ReturnType lStdResult;

  lStdResult = E_OK;

  /* #10 If first call: */
  if(opStatus == DCM_INITIAL)
  {
    /* #20 Initiate NvM read operation */
    lStdResult = NvM_ReadBlock(blockId, data);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* #30 If NvM operation accepted: */
    if (lStdResult == E_OK)
    {
      /* #40 Try immediate get status */
    }
    else
    {
      /* #50 Otherwise: NvM request failed; close job */
      lStdResult = E_NOT_OK;
    }
  }
  else
# if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  /* #60 If service is canceled: */
  if (opStatus == DCM_CANCEL)
  {

    /* #70 Try to cancel NvM read; this is all we can do. Operation result is not from importance */
    (void)NvM_CancelJobs(blockId);

    /* #80 Finish the job with failed */
    lStdResult = E_NOT_OK;
  }
  else
# endif
  {
    /* Shall not be any other then DCM_PENDING (i.e. DCM_FORCE_RCRRP_OK or DCM_FORCE_RCRRP_NOT_OK) */
    Dcm_DebugAssert((opStatus == DCM_PENDING), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                /* COV_DCM_RTM_DEV_DEBUG XF */
  }

  /* #90 If no error found during NvM request or just next call of this function: */
  if(lStdResult == E_OK)
  {
    /* #100 Gather and return the NvM operation state */
    lStdResult = Dcm_UtiNvMGetErrorStatus(blockId);
  }/* else - result is already E_NOT_OK */

  /* #110 Return final result */
  return lStdResult;
}
#endif

#if(DCM_UTI_NVM_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_UtiNvMWrite()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMWrite(Dcm_OpStatusType                     opStatus
                                              ,Dcm_GenericDcmConstRamNoInitPtrType  data
                                              ,uint16                               blockId)
{
  Std_ReturnType lStdResult;

  lStdResult = E_OK;

  /* #10 If first call: */
  if(opStatus == DCM_INITIAL)
  {
    /* #20 Initiate NvM write operation */
    lStdResult = NvM_WriteBlock(blockId, data);                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    /* #30 If NvM operation accepted: */
    if (lStdResult == E_OK)
    {
      /* #40 Try immediate get status */
    }
    else
    {
      /* #50 Otherwise: NvM request failed; close job */
      lStdResult = E_NOT_OK;
    }
  }
  else
# if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  /* #60 If service is canceled: */
  if (opStatus == DCM_CANCEL)
  {
    /* #70 Try to cancel NvM write; this is all we can do. Operation result is not from importance */
    (void)NvM_CancelJobs(blockId);

    /* #80 Finish the job with failed */
    lStdResult = E_NOT_OK;
  }
  else
# endif
  {
    /* Shall not be any other then DCM_PENDING (i.e. DCM_FORCE_RCRRP_OK or DCM_FORCE_RCRRP_NOT_OK) */
    Dcm_DebugAssert((opStatus == DCM_PENDING), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                /* COV_DCM_RTM_DEV_DEBUG XF */
  }

  /* #90 If no error found during NvM request or just next call of this function: */
  if(lStdResult == E_OK)
  {
    /* #100 Gather and return the NvM operation state */
    lStdResult = Dcm_UtiNvMGetErrorStatus(blockId);
  }/* else - result is already E_NOT_OK */

  /* #110 Return final result */
  return lStdResult;
}
#endif

#if(DCM_UTI_NVM_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_UtiNvMSwcDataWrite()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMSwcDataWrite(Dcm_OpStatusType                     opStatus
                                                     ,Dcm_GenericDcmConstRamNoInitPtrType  data
                                                     ,uint16                               blockId)
{
  Std_ReturnType lStdResult;

  /* #10 If first call: */
  if(opStatus == DCM_INITIAL)
  {
    /* #20 Lock the access to the blockId for any other NvM client */
    NvM_SetBlockLockStatus(blockId, TRUE);
  }

  /* #30 Perform normal NvM write operation */
  lStdResult = Dcm_UtiNvMWrite(opStatus, data, blockId);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* #40 If NvM operation failed for any reason */
  if(lStdResult == DCM_E_NOT_OK)
  {
    /* #50 Unlock the access to the current blockId for other clients */
    NvM_SetBlockLockStatus(blockId, FALSE);
  }/* else - DCM_E_PENDING, DCM_E_OK */

  /* #60 Return operation result */
  return lStdResult;
}
#endif
#if(DCM_EXT_NEED_API_DEBUGISMODULEINITIALIZED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DebugIsModuleInitialized()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(boolean, DCM_CODE) Dcm_DebugIsModuleInitialized(void)
{
  return (boolean)Dcm_DebugOptIsModuleInitialized();
}
#endif

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_DebugCatchCriticalError()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_DebugCatchCriticalError(Dcm_ExtendedSidType extApiSid)
{
  DCM_IGNORE_UNREF_PARAM(extApiSid);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  Dcm_DebugDeInit();

  Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  Dcm_DebugAssertAlways(extApiSid, DCM_E_CRITICAL_ERROR)
}
#endif
#if (DCM_EXT_NEED_API_NETGETCOMSTATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetGetComState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Dcm_NetComMStateType, DCM_CODE) Dcm_NetGetComState(PduIdType rxPduId)
{
  Dcm_NetComMStateType lResult;
  uint8                lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(rxPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult  = DCM_NET_COMM_STATE_RX_DIS_TX_DIS;

  if(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    lResult = Dcm_NetGetComStateByRxPduId(rxPduId);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxIndInternal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_NetRxIndInternal(PduIdType     rxPduId
                                                   ,Dcm_MsgType   data                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                   ,PduLengthType length)
{
  Dcm_NetArEnvNotifResultType notifResult = DCM_NET_ARENV_NTFRSLT_NOT_OK;
  BufReq_ReturnType bufReq;
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) rxPduInfoPtr = NULL_PTR;

#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  Dcm_DebugAssert((Dcm_NetGetConnIdOfRxPduId(rxPduId) < Dcm_PbCfgNetNumConnections), DCM_SID_INTERNAL, DCM_E_PARAM)                                  /* COV_DCM_RTM_DEV_DEBUG XF */
#  endif

  /* start virtual request; */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Initiate reception for the required RxPduID. Mark this reception as an internal one in order to get correct
   * ComM management.
   */
  bufReq = Dcm_NetProvideRxBuffer(rxPduId, length, &rxPduInfoPtr, DCM_NET_TOBJ_FLAG_INTERNAL);                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if(bufReq == BUFREQ_OK)
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfRxPduId(rxPduId));

    if(pTranspObj == NULL_PTR)                                                                                                                       /* COV_DCM_RTM_UNREACHABLE XF */
    {
      /* Check for valid call state */
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                   /* COV_DCM_RTM_DEV_DEBUG XF */
    }
    else
    {
#  if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      /* If not a pseudo parallel request */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) == 0)
#  endif
      {
#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
        /* since buffer status is BUFREQ_OK and the TransportObj is not busy, the provided buffer must be valid and
        *  large enough!
        */
        if(rxPduInfoPtr == NULL_PTR)                                                                                                                 /* COV_DCM_RTM_UNREACHABLE XF */
        {
          Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETRXINDINTERNAL);
        }
        else
#  endif
        {
          /* Copy received data */
          Dcm_UtiMemCopySafe(data, rxPduInfoPtr->SduDataPtr, 0u, rxPduInfoPtr->SduLength, length);                                                   /* SBSW_DCM_POINTER_WRITE_RXPDUINFO */
          notifResult = DCM_NET_ARENV_NTFRSLT_OK;
        }
      } /* else - a pseudo parallel request will not be processed over an internal request */
    }

    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_RxIndication(rxPduId, notifResult);
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

  } /* else - no reception possible, exit with fail */

  return Dcm_NetArEnvGetTransmResult(notifResult);
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxIndInternal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_NetRxIndInternal(PduIdType     rxPduId
                                                   ,Dcm_MsgType   data                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                   ,PduLengthType length)
{
  Dcm_NetArEnvNotifResultType notifResult = DCM_NET_ARENV_NTFRSLT_NOT_OK;
  BufReq_ReturnType bufReq;
  PduLengthType     bufferSize;

#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  Dcm_DebugAssert((Dcm_NetGetConnIdOfRxPduId(rxPduId) < Dcm_PbCfgNetNumConnections), DCM_SID_INTERNAL, DCM_E_PARAM)                                  /* COV_DCM_RTM_DEV_DEBUG XF */
#  endif

  /* start virtual request; */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* #10 Initiate reception for the required RxPduID. Mark this reception as an internal one in order to get correct
   * ComM management.
   */
  bufReq = Dcm_NetStartOfReception(rxPduId, length, &bufferSize, DCM_NET_TOBJ_FLAG_INTERNAL);                                                        /* SBSW_DCM_POINTER_FORWARD_STACK */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* #20 If reception accepted: */
  if(bufReq == BUFREQ_OK)
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfRxPduId(rxPduId));

    if(pTranspObj == NULL_PTR)                                                                                                                       /* COV_DCM_RTM_UNREACHABLE XF */
    {
      /* Check for valid call state */
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                   /* COV_DCM_RTM_DEV_DEBUG XF */
    }
    else
    {
#  if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      /* #30 If not a pseudo parallel request */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) == 0)
#  endif
      {
        PduInfoType   pduInfo;

        pduInfo.SduDataPtr = data;
        pduInfo.SduLength = length;

        /* #40 Copy received data */
        bufReq = Dcm_CopyRxData(rxPduId, &pduInfo, &bufferSize);                                                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */
        /* #50 If data copy succeeded: */
        if(bufReq == BUFREQ_OK)                                                                                                                      /* COV_DCM_RTM_UNREACHABLE TX */
        {
          /* #60 Notify DCM about successful reception */
          notifResult = DCM_NET_ARENV_NTFRSLT_OK;
        }/* else - Dcm_CopyRxData failed -> exit with Dcm_TpRxIndication(failed) */
      }/* else - a pseudo parallel request will not be processed over an internal request */
    }
    /* #70 Notify DCM about reception accomplishment only in case the reception was accepted */
    Dcm_TpRxIndication(rxPduId, notifResult);
  }/* else - no reception possible exit with fail */
  /* #80 Return the operation result to the caller */
  return Dcm_NetArEnvGetTransmResult(notifResult);
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_RepeaterSetCallee()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_RepeaterSetCallee(uint8 serviceProcessorIdx)
{
  Dcm_InstanceContext.Repeater.CalleeIdx = serviceProcessorIdx;
  Dcm_RepeaterNextStep(DCM_REPEATER_PROGRESS_INITIAL);
}

#if (DCM_REPEATER_EXT_CONTEXT_GETTER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_RepeaterGetExtSvcContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Dcm_ExtSvc86RepeaterContextPtrType, DCM_CODE) Dcm_RepeaterGetExtSvcContext(void)
{
  Dcm_ExtSvc86RepeaterContextPtrType lResult;

  /*
   * Just return repeater context for service 0x86 (type safe).
   * If it will be necessary in future to return different types of repeater context, another approach has to be used.
   * But since DCM knows always which service processor is currently active, there is no need to pass a handle to
   * this function.
   */
  lResult = &(Dcm_InstanceContext.Repeater.Contexts.Context.Svc86.ExtSvc86RepeaterContext);

  return lResult;
}
#endif
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODE_ROE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchRoE()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ModeSwitchRoE(uint8 eventId, Rte_ModeType_DcmResponseOnEvent mode)
{
#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (eventId >= DCM_CFGMODEROEEVENTMODESWITCHINFOTABLE_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_MODESWITCHROE);
  }
  else
#  endif
  {
    (void)Dcm_CfgModeRoEEventModeSwitchInfoTable[eventId].OpFunc(mode);                                                                              /* SBSW_DCM_CALL_FUNCPTR_ROEMODESWITCH */
  }
}
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_TskSetEvent()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TskSetEvent(Dcm_TskTaskIdOptType taskId
                                    ,Dcm_TskTaskEvMemType ev)
{
  Dcm_TskSchedulerContextPtrType pSchedulerContext;
  Dcm_TskTaskContextPtrType      pTaskContext;

  /* No zero events are allowed! Possibly the Dcm_TskTaskEvMemType is too small to hold the value? */
  Dcm_DebugAssert((ev != DCM_TSK_EV_NONE), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                            /* COV_DCM_RTM_DEV_DEBUG XF */

  pSchedulerContext = Dcm_TskGetSchedulerContextOrNull(Dcm_TskTaskInfo[taskId].TskPrio);
  pTaskContext = Dcm_TskGetTaskContextOrNull(taskId);

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if ( (pSchedulerContext != NULL_PTR)
     &&(pTaskContext != NULL_PTR) )                                                                                                                  /* COV_DCM_RTM_RUNTIME_CHECK TX tx tx */
#endif
  {
    /* Enter critical section (Reason: a task event can be set during any ISR or higher priority task processing.) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
#if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)
    /* If the task is marked as suspended, do set only those new events that are non-killable */
    if(Dcm_TskIsFlagSet(pTaskContext, DCM_TSK_TASK_FLAG_KILLED))
    {
      /* mask all to be set events, except the non-killable ones! */
      ev &= Dcm_TskTaskInfo[taskId].NonKillEvents;
    }
#endif
    /* Add any masked/unmasked new events */
    Dcm_UtiBitOpSet(Dcm_TskTaskEvMemType, pTaskContext->TaskEvents, ev);                                                                             /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
    /* Activate the scheduler associated with the task */
    pSchedulerContext->SchdIsActive = TRUE;                                                                                                          /* SBSW_DCM_POINTER_WRITE_SCHEDULERCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}

/**********************************************************************************************************************
 *  Dcm_TskClrEvent()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TskClrEvent(Dcm_TskTaskIdOptType taskId
                                    ,Dcm_TskTaskEvMemType ev)
{
  Dcm_TskTaskContextPtrType pTaskContext;

  /* No zero events are allowed! Possibly the Dcm_TskTaskEvMemType is too small to hold the value? */
  Dcm_DebugAssert((ev != DCM_TSK_EV_NONE), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                            /* COV_DCM_RTM_DEV_DEBUG XF */

  pTaskContext = Dcm_TskGetTaskContextOrNull(taskId);

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pTaskContext != NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK TX */
#endif
  {
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, pTaskContext->TaskEvents, ev);                                                                             /* PRQA S 0291 */ /* MD_Dcm_BitNegation_0291 */ /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}
/**********************************************************************************************************************
 *  Dcm_TmrStartTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TmrStartTimer(Dcm_TmrTimerIdOptType timerId, Dcm_TmrTimerCntrMemType timeTicks)
{
  /* Timer Id out of range */
  Dcm_DebugAssert((timerId < DCM_TMR_NUM_TIMERS_CASTED), DCM_SID_INTERNAL, DCM_E_PARAM)                                                              /* COV_DCM_RTM_DEV_DEBUG XF */
  /* No zero times are allowed! Possibly the Dcm_TmrTimerCntrMemType is too small to hold the value? */
  Dcm_DebugAssert((timeTicks != 0u), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Update the corresponding timer counter */
  Dcm_TmrSetTimer(timerId, timeTicks);

  /* Mark timer as running */
  Dcm_TmrSetTimerRunning(timerId);
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /* Signal the Dcm_TmrTaskTimer() that at least one timer is active */
  Dcm_TskSetEvent(DCM_TSK_ID_TIMER, DCM_TSK_EV_TIMER_ACTIVE);
}

/**********************************************************************************************************************
 *  Dcm_TmrStopTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TmrStopTimer(Dcm_TmrTimerIdOptType timerId)
{
  /* Timer Id out of range */
  Dcm_DebugAssert((timerId < DCM_TMR_NUM_TIMERS_CASTED), DCM_SID_INTERNAL, DCM_E_PARAM)                                                              /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Mark timer as not running */
  Dcm_TmrSetTimerStopped(timerId);
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}

/**********************************************************************************************************************
 *  Dcm_TmrResumeTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TmrResumeTimer(Dcm_TmrTimerIdOptType timerId)
{
  /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  if(Dcm_TmrGetTimer(timerId) != 0)
  {
    /* Mark timer as running */
    Dcm_TmrSetTimerRunning(timerId);
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /* Signal the Dcm_TmrTaskTimer() that at least one timer is active */
  Dcm_TskSetEvent(DCM_TSK_ID_TIMER, DCM_TSK_EV_TIMER_ACTIVE);
}
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDidNoOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDidNoOp(void)
{
  return DCM_E_OK;
}

# if (DCM_DIDMGR_NVM_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadNvMSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrNvMReadSignal(Dcm_OpStatusType opStatus
                                                      ,Dcm_MsgType      data
                                                      ,uint16           blockId)
{
  return Dcm_UtiNvMRead(opStatus, data, blockId);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_DIDMGR_NVM_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteNvMSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrNvMWriteSignal(Dcm_ReadOnlyMsgType             data
                                                       ,Dcm_OpStatusType                opStatus
                                                       ,Dcm_NegativeResponseCodePtrType errorCode
                                                       ,uint16                          blockId)
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_UtiNvMSwcDataWrite(opStatus, data, blockId);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdResult == DCM_E_NOT_OK)
  {
    *errorCode = DCM_E_GENERALPROGRAMMINGFAILURE;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  return lStdResult;
}
# endif

# if (DCM_DIDMGR_SR_IO_CONTROL_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_DidMgrIoCtrlSRHandler_Control()
*********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoCtrlSRHandler_Control(Dcm_CfgDidMgrIoCtrlSRHandlersRefOptType srEntryIndex
                                                                ,uint8                                   ioOperation
                                                                ,Dcm_ReadOnlyMsgType                     reqData
                                                                ,Dcm_OpStatusType                        opStatus
                                                                ,uint32                                  cemr
                                                                ,Dcm_NegativeResponseCodePtrType         errorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  Dcm_IOOperationResponseType ioResponse;
  Dcm_DidMgrIoCtrlSRHandlersConstPtrType pIoControlSrHandlers = Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry(srEntryIndex);

  *errorCode = DCM_E_POSITIVERESPONSE;                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

  /* ignore parameter reqData if no IO Did supports ShortTermAdjustment */
  DCM_IGNORE_UNREF_PARAM(reqData);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if (opStatus == DCM_INITIAL)
  {
    /* Clear IsUpdated flag */
    lStdResult = pIoControlSrHandlers->IoCtrlResRead(&ioResponse);                                                                                   /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */ /* SBSW_DCM_POINTER_FORWARD_STACK */

#  if (DCM_DIDMGR_SR_IO_SHORT_TERM_ADJUSTMENT_ENABLED == STD_ON)
    if ( (ioOperation == 0x03u)
       &&(lStdResult == DCM_E_OK))
    {
      /* Transfer requested data */
      lStdResult = pIoControlSrHandlers->IoCtrlReqCtrlStateWrite(reqData);                                                                           /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
    }
#  endif

    if (lStdResult == DCM_E_OK)
    {
      /* Transfer new IO operation and new CEMR  */
      lStdResult = pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(ioOperation, cemr);                                                                   /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
    }
  }

  /* OpStatus == DCM_CANCEL has no negative effect -> leave it unhandled */

  /* Get acknowledge */
  if (lStdResult == DCM_E_OK)
  {
    if (pIoControlSrHandlers->IoCtrlResIsUpdated() == TRUE)                                                                                          /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
    {
      lStdResult = pIoControlSrHandlers->IoCtrlResRead(&ioResponse);                                                                                 /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */ /* SBSW_DCM_POINTER_FORWARD_STACK */
      if (lStdResult == DCM_E_OK)
      {
        switch (ioResponse)
        {
        case DCM_POSITIVE_RESPONSE:
        {
          uint32 underControl;
          lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlRead(&underControl);                                                               /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */ /* SBSW_DCM_POINTER_FORWARD_STACK */
          if (lStdResult == DCM_E_OK)
          {
            lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlWrite(underControl | cemr);                                                      /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
          }
          /* Set IO Operation to Idle (0xFF); return value is not evaulated due to final response of application */
          (void)pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(0xFFu, cemr);                                                                            /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
          break;
        }
        case DCM_RESPONSE_PENDING:
        case DCM_IDLE: /* still no result */
          lStdResult = DCM_E_PENDING;
          break;
        default: /* any NRC */
          /* Set IO Operation to Idle (0xFF); return value is not evaulated due to final response of application */
          (void)pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(0xFFu, cemr);                                                                            /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
          *errorCode = ioResponse;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          break;
        }
      }
    }
    else
    {
      lStdResult = DCM_E_PENDING;
    }
  }

  if ( (lStdResult == DCM_E_NOT_OK)
     &&(*errorCode == DCM_E_POSITIVERESPONSE))
  {
    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }/* else:RTE error codes are handled in DCM core */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6060, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_Dcm_Design_6060, MD_MSR_STMIF */
# endif

# if (DCM_DIDMGR_SR_IO_CONTROL_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_DidMgrIoCtrlSRHandler_Reset()
*********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoCtrlSRHandler_Reset(Dcm_CfgDidMgrIoCtrlSRHandlersRefOptType srEntryIndex
                                                              ,uint32                                  cemr
                                                              ,Dcm_NegativeResponseCodePtrType         errorCode)
{
  Std_ReturnType lStdResult;
  uint32         underControl;

  Dcm_DidMgrIoCtrlSRHandlersConstPtrType pIoControlSrHandlers = Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry(srEntryIndex);

  /* Update under control elements */
  lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlRead(&underControl);                                                                       /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */ /* SBSW_DCM_POINTER_FORWARD_STACK */

  if (lStdResult == DCM_E_OK)
  {
    lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlWrite(underControl & ~cemr);                                                             /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
  }

  if (lStdResult == DCM_E_OK)
  {
    /* Transfer new IO operation and new CEMR  */
    lStdResult = pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(0x00u, cemr);                                                                           /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
  }

  if (lStdResult == DCM_E_NOT_OK)
  {
    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }/* else:RTE error codes are handled in DCM core */

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrGetDidInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetDidInfo(Dcm_OpStatusType                  opStatus
                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                   ,Dcm_DidMgrOpOptType               didOp)
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DIDMGR_ASYNC_LOOKUP_ENABLED == STD_ON)
  lStdReturn = DCM_E_NOT_OK;

  /* #10 On the very first call: */
  if(opStatus == DCM_INITIAL)
  {
    /* #20 Determine the lookup engine to run first (DID range or concrete DID) */
#  if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
    pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_DIDRANGE;                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
#  else
    pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID;                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
#  endif
  }
  /* #25 Otherwise: proceed with next steps */
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
  /* #30 If current progress is to (still) lookup for a DID range: */
  if(pDidOpTypeContext->OpType.LookUp.State == DCM_DIDMGR_LOOKUP_STATE_DIDRANGE)
  {
    /* #40 Delegate search to the DID range lookup engine */
    lStdReturn = Dcm_DidMgrDidRangeLookUp(opStatus, pDidInfoContext, pDidOpTypeContext, didOp);                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* #50 Evaluate result: */
#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      /* #60 If the current call is a cancellation event: Terminate immediately any further processing */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
#  endif
    if(lStdReturn == DCM_E_NOT_OK)
    {
      /* #70 Otherwise: If no match found: Continue with concrete DID look up */
      pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID;                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
#  if (DCM_DIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
    if(lStdReturn == DCM_E_OK)
    {
      opStatus = DCM_INITIAL; /* Prepare for new asynchronous calling sequence */
      /* #80 Otherwise: If match found: Go on with optional DID look up result filtering */
      pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN;                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
#  endif
#  if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
    if(lStdReturn == DCM_E_LOOKUP_MATCH_FOUND)
    {
      /* #90 Otherwise: If range match found but it was a gap: Report DID as not supported */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
#  endif
    {
      /*
       * #100 Otherwise: Just return the final result: (DCM_E_PENDING | DCM_E_OK (if no extended look up) |
       * DCM_E_NOT_OK (if no gaps) )
       */
    }
  }
  /* #110 Otherwise - keep current result: DCM_E_NOT_OK */
# endif

# if (DCM_DIDMGR_ASYNC_LOOKUP_ENABLED == STD_ON)
  /* #120 If current progress is to lookup for a concrete DID: */
  if(pDidOpTypeContext->OpType.LookUp.State == DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID)
# endif
  {
    /* #130 Start concrete DID lookup engine */
    lStdReturn = Dcm_DidMgrConcreteDidLookUp(pDidInfoContext, didOp);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* #140 Evaluate result: */
# if (DCM_DIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
    if(lStdReturn == DCM_E_OK)
    {
      /* #150 If valid DID found: proceed with optional lookup result filtering */
      opStatus = DCM_INITIAL; /* Prepare for new asynchronous calling sequence */
      pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN;                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    }
# endif
  }
  /* #155 Otherwise - keep current result: DCM_E_OK, DCM_E_NOT_OK, DCM_E_PENDING */

# if (DCM_DIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
  /* #160 If any valid DID(range) found: */
  if(pDidOpTypeContext->OpType.LookUp.State == DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN)
  {
    /* #170 Proceed with optional lookup result filtering */
    lStdReturn = Dcm_FilterDidLookUpResult(opStatus, pDidInfoContext->Did, (Dcm_DidOpType)didOp);

    /* #180 Evaluate result: */
#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      /* #190 If the current call is a cancellation event: Terminate immediately any further processing */
      lStdReturn = DCM_E_NOT_OK;
    }
#  endif

#  if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    /* #200 If an valid/unexpected return value: */
    if( (lStdReturn != DCM_E_OK)
      &&(lStdReturn != DCM_E_PENDING)
      &&(lStdReturn != DCM_E_NOT_OK) )
    {
      /* #210 Unexpected return value is treated as "DID not supported" */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      lStdReturn = DCM_E_NOT_OK;
    }
#  endif
  }
  /* #220 Otherwise - keep current result: DCM_E_OK, DCM_E_NOT_OK, DCM_E_PENDING */
# endif

  /* #230 If final result available and it is that the DID is supported: */
  if(lStdReturn == DCM_E_OK)
  {
    /* #240 Always perform standard filtering (variant, session, etc.) */
    lStdReturn = Dcm_DidMgrFilterDidLookUp(pDidInfoContext, didOp);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

  }
  /* #250 Otherwise just return the current state or not supported DID: DCM_E_PENDING or DCM_E_NOT_OK */

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_EXT_NEED_API_VARMGRGETACTIVECOMVARIANT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrGetActiveComVariant()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Dcm_CfgVarMgrComVariantType, DCM_CODE) Dcm_VarMgrGetActiveComVariant(void)
{
  return Dcm_SingletonContext.VarMgr.ActiveComVariant;
}
#endif
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service27Init(void)
{
  Dcm_Svc27ResetSequence();
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
  {
    /* For each security level: */
    uint8_least lSecLvlIter;

    for(lSecLvlIter = 0; lSecLvlIter < DCM_STATE_SECURITY_NUM_LEVELS; ++lSecLvlIter)
    {
      /* Initialize the security timer and counter */
      Dcm_Svc27TimerReset(lSecLvlIter);
      Dcm_Svc27CounterReset(lSecLvlIter);

#  if(DCM_STATE_SEC_DELAY_ON_BOOT_ENABLED == STD_ON)
      /* If a delay time on boot is supported: */
      if(Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeOnBoot != 0u)
      {
        /* Start the appropriate security timer */
        Dcm_Svc27TimerStart(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeOnBoot);
      }
#  endif
    }
  }

  /* Initialize the bit masks related to Get- and Set-AttemptCounter APIs */
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.Services.Svc27.GetAttCntrEventMask = DCM_SVC_27_LEVEL_MASK;
  Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask = 0u;
#   if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.Services.Svc27.ReloadMask = 0u;
#   endif
  Dcm_InstanceContext.Diag.Services.Svc27.GetAttOpStatus = DCM_INITIAL;
  Dcm_InstanceContext.Diag.Services.Svc27.SetAttOpStatus = DCM_INITIAL;

  /* Trigger the reading of the attempt counter values */
  Dcm_TskSetEvent(DCM_TSK_ID_SVC27, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_READ);
#  endif
# endif
}
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2AInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service2AInit(void)
{
  Dcm_Service2ASchedulerInit();
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrRead(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                  ,Dcm_OpStatusType opStatus
                                                  ,Dcm_DiagDataContextPtrType pDataContext)
{
  Std_ReturnType lStdReturn;
  Dcm_OpStatusType lOpStatus = opStatus;

  /* The DDDID shall be a defined one! */

  Dcm_DebugAssert((Dcm_Svc2CIsDynDidDefined(dynDidHandle)), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                   /* COV_DCM_RTM_DEV_DEBUG XF */

  lStdReturn = Dcm_Svc2CDefMgrReadCheckAccessAndInit(dynDidHandle, &lOpStatus);                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

  if(lStdReturn == DCM_E_OK)
  {
    if(lOpStatus == DCM_INITIAL)
    {
      Dcm_Svc2CDynDidProcessContextPtrType pProcessContext;

      pProcessContext = Dcm_Svc2CGetDDDidProcessContext(DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED);

      Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = dynDidHandle;
      pProcessContext->ItemInProgress = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);                                                            /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
      pProcessContext->ItemToStop = (Dcm_CfgDidMgrDynDidSrcItemIdxMemType)(pProcessContext->ItemInProgress + Dcm_Svc2CGetItem(dynDidHandle)->Count); /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
    }

    /* Process source items */
    lStdReturn = Dcm_Svc2CDefMgrReadSrcItems(lOpStatus, pDataContext);                                                                               /* SBSW_DCM_POINTER_FORWARD_STACK */
  }

  if(lStdReturn != DCM_E_PENDING)
  {
    /* Release resource */
    Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = DCM_SVC2C_INVALID_DYNDID_HDL;
  }
  return lStdReturn;
}

# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_COND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrConditionCheckRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrConditionCheckRead(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                                ,Dcm_OpStatusType opStatus
                                                                ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK; /* if the DynDID does not contain any DID sources -> always OK */
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext;
  Dcm_OpStatusType lOpStatus = opStatus;

  /* The DDDID shall be a defined one! */
  Dcm_DebugAssert((Dcm_Svc2CIsDynDidDefined(dynDidHandle)), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                   /* COV_DCM_RTM_DEV_DEBUG XF */

  pProcessContext = Dcm_Svc2CGetDDDidProcessContext(DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY);

  if(lOpStatus == DCM_INITIAL)
  {
    pProcessContext->ItemInProgress = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);                                                              /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
    pProcessContext->ItemToStop = (Dcm_CfgDidMgrDynDidSrcItemIdxMemType)(pProcessContext->ItemInProgress
                                                                         + Dcm_Svc2CGetItem(dynDidHandle)->Count);                                   /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
  }

  for(; pProcessContext->ItemInProgress < pProcessContext->ItemToStop; ++pProcessContext->ItemInProgress)                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  {
    if(Dcm_Svc2CIsDidSrcItem(pProcessContext->ItemInProgress))
    {
      if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(Dcm_Svc2CGetSrcItem(pProcessContext->ItemInProgress)->DidDescriptor.DidContext))    /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
                                    ,DCM_DIDMGR_OPTYPE_READCHKCOND))
      {
        Dcm_DidMgrInitOpClassInfo(&(Dcm_Svc2CGetSrcItem(pProcessContext->ItemInProgress)->DidDescriptor.DidContext)                                  /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
                                 ,DCM_DIDMGR_OPTYPE_READCHKCOND);

        lStdResult = Dcm_DidMgrReadCheckCond(lOpStatus
                                            ,&(Dcm_Svc2CGetSrcItem(pProcessContext->ItemInProgress)->DidDescriptor.DidContext)
                                            ,&(pProcessContext->DidOpTypeContext)
                                            ,errorCode);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
        if(lStdResult == DCM_E_OK)
        {
          /* prepare for next item */
          lOpStatus = DCM_INITIAL;
        }
        else
        {
          break; /* just delegate the return value */                                                                                                /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
        }
      } /* else - no check condition supported by this signal */
    } /* else - memory ranges cannot be checked in advance! */
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadDataLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadDataLength(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                            ,Dcm_DidMgrDidLengthPtrType dataLength)
{
  *dataLength = Dcm_Svc2CGetItem(dynDidHandle)->Length;                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
  return DCM_E_OK;
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2CInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service2CInit(void)
{
  Dcm_Svc2CDefMgrInit();
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2FInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service2FInit(void)
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_CfgDidMgrIoDidHandleOptType ioDidIter;

  Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE;
  for(ioDidIter = 0; ioDidIter < Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS); ++ioDidIter)
  {
    Dcm_UtiBitSetBasePtrType pActiveIoDids = Dcm_Svc2FGetActiveIoDids(ioDidIter);
    *pActiveIoDids = 0u;                                                                                                                             /* SBSW_DCM_POINTER_WRITE_2FACTIVEIODIDS */
  }
# endif
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service86Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service86Init(void)
{
  Dcm_ExtService86Init();/* delegate to the extension */
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Module call-out implementations
---------------------------------------------- */
#define DCM_START_SEC_CALLOUT_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDataPadding()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_PagedBufferDataPadding(Dcm_OpStatusType opStatus
                                                                 ,Dcm_DiagDataContextPtrType pDataContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode)                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Check for remaining parts to be padded */
  Dcm_UtiMemSetUintX(Dcm_DiagGetDataContextBuffer(pDataContext), Dcm_MsgItemType, 0x00u, pDataContext->AvailLen);                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
  /* Signalize that all requested data are provided */
  Dcm_DiagCommitData(pDataContext, pDataContext->AvailLen);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  /* Enforce transmission of the current part */
  return DCM_E_BUFFERTOOLOW;
}
#endif
/**********************************************************************************************************************
 *  Dcm_RepeaterDeadEnd()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_RepeaterDeadEnd(Dcm_OpStatusType opStatus
                                                  ,Dcm_MsgContextPtrType pMsgContext                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode)                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return DCM_E_STOP_REPEATER;
}
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DIDMGR_DID_F186_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgr_F186_ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_DidMgr_F186_ReadData(P2VAR(uint8, AUTOMATIC, DCM_VAR_NOINIT) Data)
{
  return Dcm_GetSesCtrlType(Data);                                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service01Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{

  Std_ReturnType lStdResult;

  Dcm_Svc01RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc01;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc01Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC01_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc01_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service02Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType  lStdResult;

  Dcm_Svc02RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc02;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc02Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC02_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc02_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service03Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType  lStdResult;

  Dcm_ObdDtcManagerContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc03.ReadDtcContext;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc03Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC03_PROGRESS_SETDTCFILTER:
    lStdResult = Dcm_Svc03UtiDemSetDTCFilter(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC03_PROGRESS_READDTCBYSTATUSMASK:
    lStdResult = Dcm_ObdDtcMgrReadDtcByStatusMask(opStatus, pMsgContext, ErrorCode, pRepContext);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service03Updater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service03Updater(Dcm_OpStatusType opStatus
                                                           ,Dcm_DiagDataContextPtrType pDataContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(pDataContext, ErrorCode, &Dcm_InstanceContext.Repeater.Contexts.Context.Svc03.ReadDtcContext);            /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service04Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service04Processor(Dcm_OpStatusType                opStatus
                                                             ,Dcm_MsgContextPtrType           pMsgContext                                            /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;
  Dcm_Svc04RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc04;

# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  if(opStatus == DCM_INITIAL)
  {
    pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());                                                            /* SBSW_DCM_GLOBAL_PTR_WRITE */
  }
# endif

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc04Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  case DCM_SVC04_PROGRESS_REPEATERPROXY_SELECT_DTC:
    lStdResult = Dcm_Svc04_XX_RepeaterProxy_SelectDTC(opStatus, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  case DCM_SVC04_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc04_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service06Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service06Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType  lStdResult;

  Dcm_Svc06RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc06;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc06Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC06_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc06_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service06Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service06Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc06RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc06;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc06Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC06_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc06_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service07Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service07Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType  lStdResult;

  Dcm_ObdDtcManagerContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc07.ReadDtcContext;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc07Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC07_PROGRESS_SETDTCFILTER:
    lStdResult = Dcm_Svc07UtiDemSetDTCFilter(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC07_PROGRESS_READDTCBYSTATUSMASK:
    lStdResult = Dcm_ObdDtcMgrReadDtcByStatusMask(opStatus, pMsgContext, ErrorCode, pRepContext);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service07Updater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service07Updater(Dcm_OpStatusType opStatus
                                                           ,Dcm_DiagDataContextPtrType pDataContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(pDataContext, ErrorCode, &Dcm_InstanceContext.Repeater.Contexts.Context.Svc07.ReadDtcContext);            /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service08Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service08Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc08RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc08;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc08Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC08_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc08_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service09Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service09Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc09RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc09;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc09Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC09_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc09_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service0AProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service0AProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType  lStdResult;

  Dcm_ObdDtcManagerContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc0A.ReadDtcContext;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc0AHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC0A_PROGRESS_SETDTCFILTER:
    lStdResult = Dcm_Svc0AUtiDemSetDTCFilter(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC0A_PROGRESS_READDTCBYSTATUSMASK:
    lStdResult = Dcm_ObdDtcMgrReadDtcByStatusMask(opStatus, pMsgContext, ErrorCode, pRepContext);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service0AUpdater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service0AUpdater(Dcm_OpStatusType                opStatus
                                                           ,Dcm_DiagDataContextPtrType      pDataContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(pDataContext, ErrorCode, &Dcm_InstanceContext.Repeater.Contexts.Context.Svc0A.ReadDtcContext);            /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Service10Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service10Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc10RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc10;

  switch(Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc10Handler(opStatus, pMsgContext, ErrorCode , pRepContext);                                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
  case DCM_SVC10_PROGRESS_WAIT_RESET_ACK:
    lStdResult = Dcm_Svc10_WaitForResetAck(opStatus, pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
#  if (DCM_DIAG_RCRRP_ON_BOOT_ENABLED == STD_ON)
  case DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK:
    lStdResult = Dcm_Svc10_WaitForRcrRpAck(opStatus, pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
#  endif
  case DCM_SVC10_PROGRESS_SET_PRGCOND:
    lStdResult = Dcm_Svc10_SetProgConditions(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service10FastPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service10FastPostProcessor(Dcm_ConfirmationStatusType status)
{
  if(status == DCM_RES_POS_OK)
  {
    Dcm_DiagSetP2Timings(Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.SesStateIdx
                        ,Dcm_NetGetProtIdOfActiveProtocol());

# if (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON)
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ResetMode != DCM_MODEMGR_ARENV_MODE_ECURESET_NONE)
    {
      Dcm_SingletonContext.Network.RxAllowed = FALSE; /* lock any further communication while the ECU is getting reset */
    }
# endif
  }
}

/**********************************************************************************************************************
 *  Dcm_Service10PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service10PostProcessor(Dcm_ConfirmationStatusType status)
{
  if(status == DCM_RES_POS_OK)
  {
    /* execute transition */
    Dcm_StateSetSession(Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.SesStateIdx);
# if (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON)
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ResetMode != DCM_MODEMGR_ARENV_MODE_ECURESET_NONE)
    {
      /* fire and forget - if failed - no chance to send any NRC from here */
      (void)Dcm_ModeMgrArEnvSwitchReqEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE);
    }
# endif
  }
  else
  {
    /* on the way of changing a session */
    if(0 == ( Dcm_SingletonContext.StateMgr.Preconditions.Session
            & Dcm_SingletonContext.StateMgr.PendingSession) )
    {
      /* undo pending session expectation */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
      Dcm_UtiArEnvEnterCriticalSection();/* avoid interrupt from the Dcm_NetTaskRx || Dcm_NetStartOfReception() */                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */
# else
      Dcm_SplitTaskEnterCS();/* avoid interrupt from the Dcm_NetTaskRx */                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
# endif
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
      Dcm_StateSyncPendingSession();/* synchronize with the currently active session */
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
      Dcm_UtiArEnvLeaveCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
# else
      Dcm_SplitTaskLeaveCS();                                                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
# endif
    }/* else - nothing to undo */
  }
}
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc11RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc11;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc11Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC11_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc11SubFuncHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
  case DCM_SVC11_PROGRESS_ECURST_WAITFORACK:
    lStdResult = Dcm_Svc11_EcuRst_WaitForAck(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
  case DCM_SVC11_RAPPWRDWN_WAITFORACK:
    lStdResult = Dcm_Svc11_RapPwrDwn_WaitForAck(opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service11PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service11PostProcessor(Dcm_ConfirmationStatusType status)
{
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
  if(status == DCM_RES_POS_OK)
  {
#  if (DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED == STD_ON)
    if( (Dcm_InstanceContext.Repeater.Contexts.Context.Svc11.SubFuncId > 0x00u)
      &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc11.SubFuncId < 0x04u) )
#  endif
    {
      /* reset only on 0x01 (hard), 0x02 (soft), 0x03 (keyOnOff) */
      (void)Dcm_ModeMgrArEnvSwitchReqEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE);
    }
  }
# endif
}

/**********************************************************************************************************************
 *  Dcm_Service11FastPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service11FastPostProcessor(Dcm_ConfirmationStatusType status)
{
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
  if(status == DCM_RES_POS_OK)
  {
#  if (DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED == STD_ON)
    if( (Dcm_InstanceContext.Repeater.Contexts.Context.Svc11.SubFuncId > 0x00u)
      &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc11.SubFuncId < 0x04u) )
#  endif
    {
      Dcm_SingletonContext.Network.RxAllowed = FALSE;
    }
  }
# endif
}
# if (DCM_SVC_11_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_01Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_HARD, ErrorCode);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_11_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_02Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_KEYONOFF, ErrorCode);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_11_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_03Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_SOFT, ErrorCode);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_11_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_04Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_04Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Prepare for a positive response */
  Dcm_DiagProvideResDataAsU8(pMsgContext, DCM_SVC_11_POWERDOWNTIME);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessRapPwrDwn(DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_ENABLE, ErrorCode);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_11_05_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_05Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_05Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessRapPwrDwn(DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_DISABLE, ErrorCode);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service14Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service14Processor(Dcm_OpStatusType                opStatus
                                                             ,Dcm_MsgContextPtrType           pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc14RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc14;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc14Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  case DCM_SVC14_PROGRESS_REPEATERPROXY_SELECT_DTC:
    lStdResult = Dcm_Svc14_XX_RepeaterProxySelectDTC(opStatus, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC14_PROGRESS_REPEATERPROXY_CHECK_SELECTION_RESULT:
    lStdResult = Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult(opStatus, pMsgContext, ErrorCode, pRepContext);                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  case DCM_SVC14_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc14_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19Processor(Dcm_OpStatusType                opStatus
                                                             ,Dcm_MsgContextPtrType           pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc19Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC19_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc19SubFuncHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_UTI_COPYLINEARDATA:
    lStdResult = Dcm_Svc19UtiCopyLinearData(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC:
    lStdResult = Dcm_Svc19UtiDemSelectDTC(opStatus, pMsgContext, ErrorCode, pRepContext);                                                            /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_DISABLERECORDUPDATE:
    lStdResult = Dcm_Svc19UtiDemDisableRecordUpdate(opStatus, pMsgContext, ErrorCode, pRepContext);                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC:
    lStdResult = Dcm_Svc19UtiDemGetStatusOfDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEM_API_SELECT_FFR_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_SELECTFFREC:
    lStdResult = Dcm_Svc19UtiDemSelectFFData(pRepContext);                                                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFFFREC:
    lStdResult = Dcm_Svc19UtiDemGetSizeOfFFRecord(opStatus, pMsgContext, ErrorCode, pRepContext);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEM_API_SELECT_EDR_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_SELECTEXTDATAREC:
    lStdResult = Dcm_Svc19UtiDemSelectExtRecord(opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFEXTDATAREC:
    lStdResult = Dcm_Svc19UtiDemGetSizeOfExtRecord(opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC:
    lStdResult = Dcm_Svc19UtiDemGetNumFltrdDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDSEVERITY:
    lStdResult = Dcm_Svc19UtiDemGetNxtFltrdSeverity(opStatus, pMsgContext, ErrorCode, pRepContext);                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETSEVERITYOFDTC:
    lStdResult = Dcm_Svc19UtiDemGetSeverityOfDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETFUNCUNITOFDTC:
    lStdResult = Dcm_Svc19UtiDemGetFuncUnitOfDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDDTC:
    lStdResult = Dcm_Svc19UtiDemGetNxtFltrdDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_PUTNUMFLTRDDTC:
    lStdResult = Dcm_Svc19UtiPutNumFilteredDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDFDC:
    lStdResult = Dcm_Svc19UtiDemGetNxtFltrdFDC(opStatus, pMsgContext, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_WWHOBD_GETNEXTFLTRDSEVERITY:
    lStdResult = Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity(opStatus, pMsgContext, ErrorCode, pRepContext);                                            /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_19_CHAIN_END_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_CHAIN_END:
    lStdResult = DCM_E_OK;
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_Service19PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service19PostProcessor(Dcm_ConfirmationStatusType status)
{
# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
#  endif
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  (void)Dcm_DemAPI(EnableDTCRecordUpdate)(pRepContext->DemClientId);
#  else
  (void)Dcm_DemAPI(EnableDTCRecordUpdate)();
#  endif
# endif
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19Updater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19Updater(Dcm_OpStatusType                opStatus
                                                           ,Dcm_DiagDataContextPtrType      pDataContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Service19UtiCopyData(pDataContext, ErrorCode, pRepContext);                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
# if (DCM_SVC_19_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_01Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  uint8 reqDtcStatusMask;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &reqDtcStatusMask);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

  return Dcm_Svc19UtiReportNumDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                                 ,reqDtcStatusMask
                                                 ,0
                                                 ,pMsgContext
                                                 ,ErrorCode
                                                 ,pRepContext);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_02Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                              ,DCM_SVC_19_USE_MASK_REQ
                                              ,pMsgContext
                                              ,ErrorCode
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_03Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext                                         /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType             lStdResult;
  Dcm_DemReturnSetFilterType demResult;
  uint16                     numOfRecords;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  demResult = Dcm_DemAPI(SetFreezeFrameRecordFilter)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
      pRepContext->DemClientId,
#  endif
      DEM_DTC_FORMAT_UDS,
      &numOfRecords);                                                                                                                                /* SBSW_DCM_POINTER_FORWARD_STACK */
  if (demResult == DCM_DEM_RET_FILTER_ACCEPTED)
  {
    lStdResult =  Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_NXT_FLTRD_RECORD
                                           ,(Dcm_MsgLenType)(numOfRecords * 4)
                                           ,pRepContext);                                                                                            /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
  else
  { /* Any DEM error */
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_DemApiNrcMapSetDTCFilter);                                                            /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_04Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_04Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext                                         /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)                                          /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportDtcFFRByDtc(DEM_DTC_ORIGIN_PRIMARY_MEMORY, pMsgContext, pRepContext);                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_05_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_05Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_05Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdReturn;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &(pRepContext->RecordNum));                                                                                /* SBSW_DCM_COMB_PTR_FORWARD */

  if( (pRepContext->RecordNum == 0x00u)
    ||(pRepContext->RecordNum == DCM_SVC_19_RECNUM_ALL) )
  {
    uint16 recordLength;
    Dcm_MsgType freezeFrameDataBuffer;
    Dcm_DemReturnGetFreezeFrameDataByRecordType demResult;

    /* Report immediately the only possible SSRN (0x00) */
    Dcm_DiagProvideResDataAsU8(pMsgContext, 0x00u);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    /* Calculate remaining length for SSRN data provision by DEM
     * (i.e. subtract the DTC (3bytes) and status mask (1 Byte) from the current available response buffer, that will be written later)
     */
    recordLength = (uint16)Dcm_DiagGetRemainingResLenWithOffset(pMsgContext, 4u);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    freezeFrameDataBuffer = Dcm_DiagGetResDataRel(pMsgContext, 4);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    pRepContext->Origin = DEM_DTC_ORIGIN_PRIMARY_MEMORY;                                                                                             /* SBSW_DCM_GLOBAL_PTR_WRITE */
    /* Gather the SSRN data (with offset of 4 bytes to the current position) and DTC number */
    demResult = Dcm_DemAPI_GetOBDFreezeFrameData(0x00u                                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */
                                                ,pRepContext->Origin
                                                ,&pRepContext->Dtc
                                                ,freezeFrameDataBuffer
                                                ,&recordLength);
    switch(demResult)
    {
    case DCM_DEM_RET_FFBYRECORD_OK:
      /* Commit the reported SSRN data */
      Dcm_DiagUpdateResLength(pMsgContext, recordLength);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
      /* Delegate the service processing to the "DTCAndStatusRecord" reporting utility (i.e. writes DTC and its status into the response) */
      lStdReturn = Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainGetDtcStatusEnd, pRepContext);                                                            /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
      break;
    case DCM_DEM_RET_FFBYRECORD_NO_DTC:
      /* Otherwise, if the DEM has found no matching DTC, just return the SSRN with no further data */
      lStdReturn = DCM_E_OK;
      break;
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetOBDFreezeFrameData);                                                  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
      break;
    }
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif

# if (DCM_SVC_19_06_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_06Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_06Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportExtDataRecordByDtcNum(DEM_DTC_ORIGIN_PRIMARY_MEMORY
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_07_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_07Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_07Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  uint8 reqDtcStatusMask;
  uint8 reqDtcSeverityMask;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &reqDtcSeverityMask);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &reqDtcStatusMask);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

  return Dcm_Svc19UtiReportNumDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_02
                                                  ,reqDtcStatusMask
                                                  ,reqDtcSeverityMask
                                                  ,pMsgContext
                                                  ,ErrorCode
                                                  ,pRepContext);                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_08Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_08Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                    lStdResult;
  uint8                             dtcStatusMask;
  uint8                             dtcSeverityMask;
  uint8                             dtcSAM;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* save the requested masks */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &dtcSeverityMask);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &dtcStatusMask);                                                                                           /* SBSW_DCM_COMB_PTR_FORWARD */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pRepContext->DemClientId
                                                       ,&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  if(lStdResult == E_OK)
  {
    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(&dtcStatusMask);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_POINTER_FORWARD_STACK */
    /* Form the relevant status bits */
    dtcStatusMask &= dtcSAM;

    if(dtcStatusMask == 0u)
    {
      lStdResult = DCM_E_OK;/* no DTCs to report */
    }
    else
    {
      /* filter the DTCs */
      lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                              ,DCM_SVC_19_DEM_SETFILTER_CLASS_02
                                              ,dtcStatusMask
                                              ,dtcSeverityMask
                                              ,DCM_DEM_FILTER_FOR_FDC_NO
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
      if(lStdResult == DCM_E_OK)
      {
        lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19_08DemChain, pRepContext);                                                                      /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
      }
      else
      {
        /* Already set by Dcm_Svc19UtiDemSetDTCFilter */
      }
    }
  }
  else
  {
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_19_09_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_09Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_09Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  uint8 dtcSAM;

  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagConsumeReqDataAsU24(pMsgContext, &(pRepContext->Dtc));                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Gather the configured DEM SAM */
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pRepContext->DemClientId
                                                       ,&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  if(lStdResult == E_OK)
  {
    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    pRepContext->Origin = DEM_DTC_ORIGIN_PRIMARY_MEMORY;                                                                                             /* SBSW_DCM_GLOBAL_PTR_WRITE */
    lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19_09DemChain, pRepContext);                                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
  else
  {
    /* Otherwise, exit service processing with an appropriate NRC corresponding to the DEM operation error  */
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_0A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0AProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0AProcessor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                               ,DCM_SVC_19_USE_MASK_ALL
                                               ,pMsgContext
                                               ,ErrorCode
                                               ,pRepContext);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0B_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0BProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0BProcessor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(DEM_FIRST_FAILED_DTC
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0CProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0CProcessor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(DEM_FIRST_DET_CONFIRMED_DTC
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0D_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0DProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0DProcessor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(DEM_MOST_RECENT_FAILED_DTC
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0EProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0EProcessor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(DEM_MOST_REC_DET_CONFIRMED_DTC
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0FProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0FProcessor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_03
                                               ,DCM_SVC_19_USE_MASK_REQ
                                               ,pMsgContext
                                               ,ErrorCode
                                               ,pRepContext);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_10_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_10Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_10Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportExtDataRecordByDtcNum(DEM_DTC_ORIGIN_MIRROR_MEMORY
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_11_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_11Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_11Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  uint8 reqDtcStatusMask;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &reqDtcStatusMask);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

  return Dcm_Svc19UtiReportNumDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_03
                                                 ,reqDtcStatusMask
                                                 ,0
                                                 ,pMsgContext
                                                 ,ErrorCode
                                                 ,pRepContext);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
# if (DCM_SVC_19_12_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_12Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_12Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  uint8 reqDtcStatusMask;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &reqDtcStatusMask);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

  return Dcm_Svc19UtiReportNumDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_04
                                                 ,reqDtcStatusMask
                                                 ,0
                                                 ,pMsgContext
                                                 ,ErrorCode
                                                 ,pRepContext);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_13_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_13Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_13Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_04
                                              ,DCM_SVC_19_USE_MASK_REQ
                                              ,pMsgContext
                                              ,ErrorCode
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_14Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_14Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext                                         /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType           lStdResult;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                          ,DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                          ,0x00u
                                          ,0u /* not used */
                                          ,DCM_DEM_FILTER_FOR_FDC_YES
                                          ,pRepContext);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
  if(lStdResult == DCM_E_OK)
  {
    lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19_14DemChain, pRepContext);                                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
  else
  {
    /* Already set by Dcm_Svc19UtiDemSetDTCFilter */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_15_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_15Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_15Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_05
                                              ,DCM_SVC_19_USE_MASK_ALL
                                              ,pMsgContext
                                              ,ErrorCode
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_17_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_17Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_17Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext;
  uint8 lUserMemId;

  lUserMemId = Dcm_DiagGetReqDataAsU8Rel(pMsgContext, 1);
  pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_SVC_19_USER_MEM_ID_CHECK_ENABLED == STD_ON)
  if(lUserMemId != DCM_SVC_19_USER_MEM_ID)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
#  endif
  {
    Dcm_DiagBufferIndexType resUserMemIdx = pMsgContext->resIndex;

    /* Set the UserMid in response now */
    Dcm_DiagProvideResData(pMsgContext, 1);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc19UtiReportDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_06
                                                      ,DCM_SVC_19_USE_MASK_REQ
                                                      ,pMsgContext
                                                      ,ErrorCode
                                                      ,pRepContext);                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    /* place the UserMid to the response */
    Dcm_DiagSetResDataAsU8At(pMsgContext, resUserMemIdx, lUserMemId);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_18_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_18Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_18Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)                                          /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lStdResult;
  uint8 lUserMemId;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext;

  pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  lUserMemId = Dcm_DiagGetReqDataAsU8Rel(pMsgContext, 4);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_SVC_19_USER_MEM_ID_CHECK_ENABLED == STD_ON)
  if (lUserMemId != DCM_SVC_19_USER_MEM_ID)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
#  endif
  {
    /* save UserMid response location */
    Dcm_DiagBufferIndexType resUserMemIdx = pMsgContext->resIndex;
    /* Set the UserMid in response now */
    Dcm_DiagProvideResData(pMsgContext, 1);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc19UtiReportDtcFFRByDtc(DEM_DTC_ORIGIN_SECONDARY_MEMORY
                                              ,pMsgContext
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    /* place the UserMid to the response */
    Dcm_DiagSetResDataAsU8At(pMsgContext, resUserMemIdx, lUserMemId);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_19Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_19Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  uint8 lUserMemId;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext;

  pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  lUserMemId = Dcm_DiagGetReqDataAsU8Rel(pMsgContext, 4);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_SVC_19_USER_MEM_ID_CHECK_ENABLED == STD_ON)
  if (lUserMemId != DCM_SVC_19_USER_MEM_ID)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
#  endif
  {
    /* save UserMid response location */
    Dcm_DiagBufferIndexType resUserMemIdx = pMsgContext->resIndex;
    /* skip the UserMid in response now */
    Dcm_DiagProvideResData(pMsgContext, 1);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc19UtiReportExtDataRecordByDtcNum(DEM_DTC_ORIGIN_SECONDARY_MEMORY
                                                        ,pMsgContext
                                                        ,ErrorCode
                                                        ,pRepContext);                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */
    /* place the UserMid to the response */
    Dcm_DiagSetResDataAsU8At(pMsgContext, resUserMemIdx, lUserMemId);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_42Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_42Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;
  uint8                         dtcStatusMask;
  uint8                         dtcSeverityMask;
  uint8                         functionalId;
  uint8                         dtcSAM;
  uint8                         dtcSevAM;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &functionalId);                                                                                            /* SBSW_DCM_COMB_PTR_FORWARD */

  if (functionalId == 0x33u)
  {
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &dtcStatusMask);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &dtcSeverityMask);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Echo the requested functional group (do it here, otherwise the above extracted data could be overwritten in case of shared Rx-Tx-Buffers) */
    Dcm_DiagProvideResDataAsU8(pMsgContext, functionalId);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Gather the configured DEM SAM */
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
    lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pRepContext->DemClientId
                                                         ,&dtcSAM);                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
    lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(&dtcSAM);                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

    if(lStdResult == E_OK)
    {
      /* Report configured DEM SAM */
      Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
      lStdResult = Dcm_DemAPI(GetDTCSeverityAvailabilityMask)(pRepContext->DemClientId
                                                             ,&dtcSevAM);                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
      lStdResult = Dcm_DemAPI(GetDTCSeverityAvailabilityMask)(&dtcSevAM);                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

      if(lStdResult == E_OK)
      {
        Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSevAM);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
        /* Report the configured in DEM DTC format identifier */
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
        Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_DemAPI(GetTranslationType)(pRepContext->DemClientId));                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
        Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_DemAPI(GetTranslationType)());                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif

        Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(&dtcStatusMask);                                                                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_POINTER_FORWARD_STACK */

        /* Form the relevant status bits */
        dtcStatusMask &= dtcSAM;

        if(dtcStatusMask == 0u)
        {
          lStdResult = DCM_E_OK;/* no DTCs to report */
        }
        else
        {
          /* filter the DTCs */
          lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                                  ,DCM_SVC_19_DEM_SETFILTER_CLASS_07
                                                  ,dtcStatusMask
                                                  ,dtcSeverityMask
                                                  ,DCM_DEM_FILTER_FOR_FDC_NO
                                                  ,pRepContext);                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

          if(lStdResult == DCM_E_OK)
          {
            lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19_42DemChain, pRepContext);                                                                  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
          }
          else
          {
            /* Already set by Dcm_Svc19UtiDemSetDTCFilter */
          }
        }
      }
      else
      {
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                       /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
    else
    {
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }
  else
  {
    /* Invalid functional group */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service22Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service22Processor(Dcm_OpStatusType                opStatus
                                                             ,Dcm_MsgContextPtrType           pMsgContext                                            /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc22RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc22;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc22Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC22_PROGRESS_DIDLOOKUP:
    lStdResult = Dcm_Svc22DidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC22_PROGRESS_CHECKCONDITION:
    lStdResult = Dcm_Svc22CheckCondition(opStatus, pMsgContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC22_PROGRESS_GETLENGTH:
    lStdResult = Dcm_Svc22GetLength(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC22_PROGRESS_READDATA:
    lStdResult = Dcm_Svc22ReadData(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE XX */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service22Updater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service22Updater(Dcm_OpStatusType                opStatus
                                                           ,Dcm_DiagDataContextPtrType      pDataContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc22;

  return Dcm_Svc22UtiReadData(opStatus, pDataContext, ErrorCode, pRepContext);                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service22Cancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service22Cancel(Dcm_DiagDataContextPtrType pDataContext)
{
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;
  Dcm_NegativeResponseCodeType     lNrc;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22));                                              /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* Notify the application about the cancellation */
  (void)Dcm_DidMgrReadDid(DCM_CANCEL
                         ,pDataContext
                         ,pDidInfoContext
                         ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidOpTypeContext)
                         ,&lNrc);                                                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

#  if (DCM_DIDMGR_CANCEL_OP_ENABLED == STD_ON)                                                                                                       /* COV_DCM_UNSUPPORTED TX */
  /* Cancel the ongoing DID operation */
  Dcm_DidMgrCancelOperation();
#  endif
}
# endif
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service23Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service23Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc23RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc23;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc23Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  case DCM_SVC23_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc23CheckAccess(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  case DCM_SVC23_PROGRESS_READMEMORY:
    lStdResult = Dcm_Svc23ReadMemory(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service24Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service24Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext                                                      /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc24RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc24;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc24Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC24_PROGRESS_DIDLOOKUP:
    lStdResult = Dcm_Svc24DidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC24_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_Svc24ExecuteOp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc27RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc27;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc27Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC27_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc27SubFuncHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
  case DCM_SVC27_PROGRESS_SETATTEMPTCNTR:
    lStdResult = Dcm_Service27SetAttemptCntrRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  case DCM_SVC27_PROGRESS_SEEDREPEATER:
    lStdResult = Dcm_Service27SeedRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC27_PROGRESS_KEYREPEATER:
    lStdResult = Dcm_Service27KeyRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                                            /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
  case DCM_SVC27_PROGRESS_CHECKATTEMPTSEXCEEDED:
    lStdResult = Dcm_Service27CheckAttemptsExceededRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service27PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service27PostProcessor(Dcm_ConfirmationStatusType status)
{
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc27;

  /* If a positive response was successfully sent */
  if(status == DCM_RES_POS_OK)
  {
    /* If it was a compare key request: */
    if(Dcm_Svc27IsKeyRequest(pRepContext->SubSvcRef) == TRUE)
    {
      /* Apply the new security state and reset sequence */
      Dcm_StateSetSecurity((Dcm_StateIndexOptType)((Dcm_Svc27GetSecLvlRef(pRepContext->SubSvcRef)) + 1u));/* locked = 0x00 -> level 1 = 0x01, etc */
    }
    else
    {
      /* If this was no zero seed response: */
      if(pRepContext->IsZeroSeed == FALSE)
      {
        /* Prepare for key acceptance */
        Dcm_InstanceContext.Diag.Services.Svc27.SeedLevel = Dcm_CfgStateSecurityInfo[(Dcm_Svc27GetSecLvlRef(pRepContext->SubSvcRef))].Value;
      }
      else
      {
        /* Otherwise, there is no key expected in that case after zero seed */
        Dcm_Svc27ResetSequence();
      }
    }
  }
  else if((DCM_DIAG_RES_NEG_ANY & status) != 0) /* Otherwise, if any negative response was sent: */
  {
    /* Reset the key-seed-sequence */
    Dcm_Svc27ResetSequence();
  }
  else /* POS_NOK */
  {
    /*
     * Otherwise no change required:
     *   - on SeedReq: the client shall retry the seed request or send another one
     *                 -> do not move to expect key for a certain level
     *   - on KeyReq:  the client may retry the key request to get a response
     *                 -> do not invalidate expect key for this level
     */
  }
}
/**********************************************************************************************************************
 *  Dcm_Service27SeedProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27SeedProcessor(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode)                                         /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc27;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If the attempt counters are currently read or written by the application: */
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  if(Dcm_TskGetEvent(DCM_TSK_ID_SVC27) != 0u)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
# endif
  {
    pRepContext->IsZeroSeed = FALSE;                                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */

    /* If the security timer is active: */
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
    if(Dcm_Svc27TimerActive(pRepContext->SecLvlRef) == TRUE)
    {
      /* Send the NRC 0x37 */
      *ErrorCode = DCM_E_REQUIREDTIMEDELAYNOTEXPIRED;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
# endif
    {
      /* If seed level not yet unlocked: */
      if (0 == (Dcm_StateGetSecurity() & Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, (pRepContext->SecLvlRef + 1u))))
      {
        /* New seed request / repetition of the same seed request. Get application generated seed */
        Dcm_RepeaterNextStep(DCM_SVC27_PROGRESS_SEEDREPEATER);
        lStdResult = DCM_E_LOOP;/* Speed up processing */
      }
      else
      {
        Dcm_CfgNetBufferSizeMemType lSeedSize = Dcm_CfgSvc27SecLevelInfo[pRepContext->SecLvlRef].SeedResLength;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
        if(Dcm_DiagMsgContextVerifySize(pMsgContext, lSeedSize) == FALSE)                                                                            /* COV_DCM_RTM_RUNTIME_CHECK XF */ /* SBSW_DCM_PARAM_PTR_FORWARD */
        {
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
        else
# endif
        {
          /* return zero seed */
          pRepContext->IsZeroSeed = TRUE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_UtiMemSetUintX(Dcm_DiagGetResData(pMsgContext), Dcm_MsgItemType, 0x00u, lSeedSize);                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_RESBUFFER */
          Dcm_DiagProvideResData(pMsgContext, lSeedSize);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
          lStdResult = DCM_E_OK;
        }
      }
    }
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_Service27KeyProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27KeyProcessor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If the attempt counters are currently read or written by the application: */
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  if(Dcm_TskGetEvent(DCM_TSK_ID_SVC27) != 0u)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
# endif
  {
    /* Get application key comparator */
    Dcm_RepeaterNextStep(DCM_SVC27_PROGRESS_KEYREPEATER);
    lStdResult = DCM_E_LOOP; /* Speed up processing */
  }
  return lStdResult;
}
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service28_XXProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service28_XXProcessor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8   msgType;
  boolean validParam = TRUE;
  Dcm_Svc28RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc28;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Extract and validate the requested network type (i.e. request data byte[0], high nibble) */
  {
    sint16_least lookUpResult;
    lookUpResult = Dcm_UtiLookUpUint8(Dcm_CfgSvc28SubNetIdLookUp, (uint8)(Dcm_DiagGetReqDataAsU8(pMsgContext) >> 4u));                               /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

    if(lookUpResult >= 0)
    {
      pRepContext->NetworkRef = Dcm_CfgSvc28SubNetIdMap[lookUpResult];                                                                               /* SBSW_DCM_GLOBAL_PTR_WRITE */
# if (DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON)
      if(pRepContext->NetworkRef == DCM_SVC_28_NETWORK_CURRENT)
      {
        pRepContext->NetworkRef = Dcm_PbCfgNetConnComMChannelMap[Dcm_PbCfgNetConnectionInfo[Dcm_DiagGetTranspObj()->ConnId].NetworkIdRef];           /* SBSW_DCM_GLOBAL_PTR_WRITE */
      }
# endif
    }
    else
    {
      validParam = FALSE;
    }
  }

  /* Extract and validate the requested message type (i.e. request data byte[0], low nibble) */
  {
    msgType = (uint8)(Dcm_DiagGetReqDataAsU8(pMsgContext) & 0x0Fu);

    if(Dcm_UtiLookUpUint8(Dcm_CfgSvc28MessageTypeLookUpTable, msgType) < 0)                                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    {
      validParam = FALSE;
    }
  }

  if(validParam == TRUE)
  {
    /*--------------------------------------------------------------
    Message types      |   Operations                |ComParamValue
    (Affected = 1,     |                             |
     Not affected = 0) | (Enable = 0, Disable = 1)   |
    ------+------------+-----------------+-----------+
    NM    |    Appl    |    RxPath       |  TxPath   |
    ------+------------+-----------------+-----------+--------------
      0   |     0      |        x        |    x      |    -
      0   |     1      |        0        |    0      |    4
      0   |     1      |        0        |    1      |    5
      0   |     1      |        1        |    0      |    6
      0   |     1      |        1        |    1      |    7
      1   |     0      |        0        |    0      |    8
      1   |     0      |        0        |    1      |    9
      1   |     0      |        1        |    0      |    10
      1   |     0      |        1        |    1      |    11
      1   |     1      |        0        |    0      |    12
      1   |     1      |        0        |    1      |    13
      1   |     1      |        1        |    0      |    14
      1   |     1      |        1        |    1      |    15
    ------+------------+-----------------+-----------+--------------
    => ModeValue := ((msgType) & 0x03) << 2) | ((RxPath) & 0x01) << 1) | ((TxPath) & 0x01) ) ) - 4
    SubFunc == ((RxPath) & 0x01) << 1) | ((TxPath) & 0x01);
    => ModeValue := ((msgType) & 0x03) << 2) | (SubFunc) ) - 4
    */
    pRepContext->ComMode = (Dcm_CommunicationModeType)( ( ((msgType & 0x03u) << 2) | (pRepContext->SubServiceId & DCM_SVC_28_CTRL_OP_MASK) ) - 4);   /* SBSW_DCM_GLOBAL_PTR_WRITE */
# if (DCM_SVC_28_USER_ENABLED == STD_ON)
    /* Mark current service execution as internally handled to perform the post-processing step later on */
    pRepContext->IsInternallyProcessed = TRUE;                                                                                                       /* SBSW_DCM_GLOBAL_PTR_WRITE */
# endif
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service28Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service28Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;
  Dcm_Svc28RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc28;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc28Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC28_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc28SubFuncHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service28PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service28PostProcessor(Dcm_ConfirmationStatusType status)
{
  if(status == DCM_RES_POS_OK)
  {
# if (DCM_SVC_28_USER_ENABLED == STD_ON)
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.IsInternallyProcessed == TRUE)
# endif
    {
      Dcm_Svc28ApplyCommControl(Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.NetworkRef,
                                Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.ComMode);
    }
  }
}
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2AProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2AProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2AHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP:
    lStdResult = Dcm_Svc2AScheduledDidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2A_PROGRESS_DID_CHECKCONDITION:
    lStdResult = Dcm_Svc2ADidCheckCondition(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2A_PROGRESS_DID_GETLENGTH:
    lStdResult = Dcm_Svc2ADidGetLength(opStatus, pMsgContext, ErrorCode, pRepContext);                                                               /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2A_PROGRESS_STOPPED_DID_LOOKUP:
    lStdResult = Dcm_Svc2AStoppedDidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2APostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2APostProcessor(Dcm_ConfirmationStatusType status)
{
  if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.UdsRate != DCM_SVC_2A_STOP_SENDING)
  {
    if(status == DCM_RES_POS_OK)
    {
      Dcm_Svc2ASchdCommit(Dcm_Svc2AMakeSchdRateFromUdsRate(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.UdsRate));
      Dcm_NetPeriodicMsgSetConnection(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.ConnId);
    }
    else
    {
      Dcm_Svc2ASchdDiscard();
    }
  }/* else - nothing */
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2C_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_01Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdReturn;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C;

  lStdReturn = Dcm_Svc2CParseAndCheckDynDid(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdReturn == DCM_E_OK)
  {
    /* there shall be an iteration (+[4Byte]) */
    if( (pMsgContext->reqDataLen > 0u)
      &&( (pMsgContext->reqDataLen % 4u) == 0) )
    {
      uint8 numReqItems = (uint8)(pMsgContext->reqDataLen / 4); /* calculate number of source items to be processed */

      /* check DynDID capacity */
      lStdReturn = Dcm_Svc2CCheckAndSetNumOfItems(numReqItems, ErrorCode, pRepContext);                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(lStdReturn == DCM_E_OK)
      {
        Dcm_RepeaterNextStep(DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP);
        lStdReturn = DCM_E_LOOP; /* speed up processing */
      } /* else - Nrc and return value already set */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
  } /* else - just return the value: DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2C_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_02Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdReturn;
  uint8          lAlfid;
  uint8          lBlockLength;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C;

  lStdReturn = Dcm_Svc2CParseAndCheckDynDid(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdReturn == DCM_E_OK)
  {
    /* Check, whether the ALFID is available */
    if (pMsgContext->reqDataLen != 0u)
    {
      /* the ALFID availability is checked within next call */
      lStdReturn = Dcm_MemMgrValidateAndGetAlfid(pMsgContext, &lAlfid, &lBlockLength, ErrorCode);                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
      if (lStdReturn == DCM_E_OK)
      {
        /* pMsgContext->reqDataLen cannot be zero! */
        if((pMsgContext->reqDataLen % lBlockLength) == 0) /* the remained request length shall be a multiple of the memory address and size request block */
        {
          uint8 numReqItems = (uint8)(pMsgContext->reqDataLen / lBlockLength); /* calculate number of source items to be processed */

          /* check DynDID capacity */
          lStdReturn = Dcm_Svc2CCheckAndSetNumOfItems(numReqItems, ErrorCode, pRepContext);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
          if (lStdReturn == DCM_E_OK)
          {
            lStdReturn = Dcm_Svc2C_02SrcItemsGetLength(lAlfid, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
          } /* else - ErrorCode and return value already set */
        }
        else
        {
          /* else - ErrorCode set to 0x13 */
          *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdReturn = DCM_E_NOT_OK;
        }
      } /* else - DCM_E_NOT_OK (ErrorCode already set) */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
  } /* else - DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Service2C_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_03Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)                                          /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lStdReturn;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pRepContext->DynDidItemCount = 0u; /* prepare for a successful clear */                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */

  if(pMsgContext->reqDataLen == 0u)
  {
    /* clear all DynDID definitions */
    Dcm_CfgDidMgrDynDidHandleOptType dynDidIter;
    for(dynDidIter = 0; dynDidIter < DCM_NUM_DYNDIDS; ++dynDidIter)
    {
      Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)dynDidIter);
    }
    lStdReturn = DCM_E_OK;
  }
  else if (pMsgContext->reqDataLen == 2u)
  {
    Dcm_RepeaterNextStep(DCM_SVC2C_PROGRESS_03_DIDLOOKUP); /* next job */
    lStdReturn = DCM_E_LOOP; /* speed up processing */
  }
  else
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  return lStdReturn;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Service2CProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2CProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2CHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2C_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc2CSubFuncHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP:
    lStdResult = Dcm_Svc2C_01SrcDidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2C_PROGRESS_01SRC_DIDCHECKCONDITIONS:
    lStdResult = Dcm_Svc2C_01SrcDidCheckCondition(opStatus, pMsgContext, ErrorCode, pRepContext);                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2C_PROGRESS_01SRC_DIDGETLENGTH:
    lStdResult = Dcm_Svc2C_01SrcDidGetLength(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
  case DCM_SVC2C_PROGRESS_03_DIDLOOKUP:
    lStdResult = Dcm_Svc2C_03DidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2CPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2CPostProcessor(Dcm_ConfirmationStatusType status)
{
  if(status == DCM_RES_POS_OK)
  {
    Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C;

    if(pRepContext->DynDidItemCount != 0u) /* this is a definition service , not the clear one */
    {
      Dcm_Svc2CDynDidItemPtrType pItem;

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
      uint16 lDid = Dcm_DidMgrGetDynDidIdFromHandle(pRepContext->DynDidHandle);
      /* Kill any still not finished read periodic DID jobs to avoid inconsistent response data/length ! */
      Dcm_Svc2ASchdCancelReadByDid(lDid);
# endif
      /* Commit DynDID definition immediately */
      pItem = Dcm_Svc2CGetItem(pRepContext->DynDidHandle);
      pItem->Length = pRepContext->DynDidLength;                                                                                                     /* SBSW_DCM_POINTER_WRITE_2CITEM */
      pItem->Count  = pRepContext->DynDidItemCount;                                                                                                  /* SBSW_DCM_POINTER_WRITE_2CITEM */
    } /* else - the dynDid has been already cleared */
  } /* else - the dynDid list properties will not be changed - all prepared data will be discarded */
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2EProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2EProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2EHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2E_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc2ECheckAccess(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2E_PROGRESS_WRITEDATA:
    lStdResult = Dcm_Svc2EWriteData(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2FProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2FProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2FHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2F_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc2FCheckAccess(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2F_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_Svc2FExecuteOp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# if(DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC2F_PROGRESS_GETLENGTH:
    lStdResult = Dcm_Svc2FGetLength(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2F_PROGRESS_READDATA:
    lStdResult = Dcm_Svc2FReadData(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2FPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2FPostProcessor(Dcm_ConfirmationStatusType status)
{
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DidMgrDidRelease(DCM_DIDMGR_DIDLOCK_OWNER_IO);
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service31Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service31Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc31RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc31;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc31Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC31_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_RidMgrExecuteRoutine(opStatus, pMsgContext, ErrorCode, pRepContext);                                                            /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service3DProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service3DProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc3DRepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc3D;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc3DHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  case DCM_SVC3D_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc3DCheckAccess(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  case DCM_SVC3D_PROGRESS_WRITEMEMORY:
    lStdResult = Dcm_Svc3DWriteMemory(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service3EProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service3EProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;

  /* Check initialization state */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                             ,Dcm_CfgSvc3ESubFuncLookUpTable
                                             ,Dcm_CfgSvc3ESubFuncExecPrecondTable
                                             ,Dcm_DiagSvcWithOnlySubFuncReqLengthGetter
                                             ,Dcm_DiagNoSequenceChecker
                                             ,&subSvcRef
                                             ,ErrorCode);                                                                                            /* SBSW_DCM_COMB_PTR_FORWARD */

}
#endif /* (DCM_SVC_3E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service85Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service85Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc85RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc85;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc85Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC85_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc85_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service85PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service85PostProcessor(Dcm_ConfirmationStatusType status)
{
  /* If a positive response was (successfully) sent: */
  if((status & DCM_DIAG_RES_NEG_ANY) == 0)
  {
    /* Trigger the requested mode switch */
    Dcm_ModeSwitchDtcSetting(Dcm_InstanceContext.Repeater.Contexts.Context.Svc85.ReqMode
                            ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc85.DTCGroup
                            ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc85.DemClientId);
  }
}
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service86Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service86Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;

  Dcm_Svc86RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc86;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc86Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC86_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc86SubFuncHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CALLOUT_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Component Detailed Design of generated functions
---------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_ModeRule<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_ModeCondGet_<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_ModeOnComControlModeChange()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 *  Dcm_DidMgr<XXX>ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr<DynDID>Read<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr<XXX>WriteData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr<OBD_AID>ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr<MID>ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr_<Data>_Write_IOControlRequest_ControlState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr_DeadEnd_Write_IOControlRequest_ControlState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr_<Data>_Write_IOControlRequest_IOOperationRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr_<Data>_Read_IOControlRequest_UnderControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr_<Data>_Write_IOControlRequest_UnderControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr_<DID>_IoControlOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr_<DID>_ReturnControlToECU()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr_<SupportedID>_ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr_<SupportedID>_ReadDataLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr_<SupportedID>_WriteData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_DidMgr_<SupportedID>_ShortTermAdjustment()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 *  Dcm_RidMgr<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_RidMgr_<XXX>_OBD_AID()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_RidMgr_<XXX>_OBD_TID()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_RidMgr_<SupportedID>_Start()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 *  Dcm_SvcWrapper_<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_SubSvcWrapper_<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_ServiceNoPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_ServiceNoUpdater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_ServiceNoCancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
/* ----------------------------------------------
 ~&&&   MISRA
---------------------------------------------- */
/* module specific MISRA deviations:

   MD_Dcm_BitNegation_0277:
     Description: Rule 3.1
                  All usage of implementation-defined behavior shall be documented.
     Reason:      Using the ~ operator avoids errors in manually typed bit masks.
     Risk:        May generate compiler warnings although explicit casts are used.
     Prevention:  None.

   MD_Dcm_Optimize_0759:
     Description: Rule 18.4
                  An object of union type has been defined.
     Reason:      An union object has been defined to optimize RAM usage for not in parallel executed jobs.
     Risk:        No risks, since all members of this shared RAM have always mutually exclusive access (i.e. service processor cannot be executed in parallel to another one).
     Prevention:  None.

   MD_Dcm_CfgDepend_0777:
     Description: Rule 5.1
                  Identifiers (internal and external) shall not rely on the significance of more than 31 characters.
     Reason:      It depends on the module's configuration (user settings) on how long the identifiers will be.
     Risk:        Compilation errors are possible.
     Prevention:  The user shall choose shorter names while configuring the module.

   MD_Dcm_Understand_0779:
     Description: Rule 5.1
                  Identifiers (internal and external) shall not rely on the significance of more than 31 characters.
     Reason:      Code maintainability requires structured names conflicting with this limitation.
     Risk:        Compilation errors are possible.
     Prevention:  Compiler compatibility is tested during integration.

   MD_Dcm_CodingRule_3218:
     Description: Rule 8.7
                  Objects shall be defined at block scope if they are only accessed from within a single function.
     Reason:      Vector style guide prevents usage of static variables/constant objects in function scope.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_3353:
    Description: Rule 9.1: The variable '%s' is possibly unset at this point.
    Reason:      A variable is only set under certain conditions in another branch; when used later, a preceding check which verifies that the specific condition are fulfilled is not recognized by QAC.
    Risk:        Variable may be unset.
    Prevention:  Review, runtime tests in test suite.

   MD_Dcm_AbstractTokenReplacement_3410:
     Description: Rule 19.10
                  Macro parameter not enclosed in ().
     Reason:      The macro parameter represents an abstract token: either data type or operation, or structure member, etc.. If enclosed in () the code will not compile.
     Risk:        In worst case, the code will not compile due to unknown or not expected token.
     Prevention:  None.

   MD_Dcm_3415:
     Description: Rule 12.4
                  The right hand operand of a logical && or || operator shall not contain side effects
     Reason:      The function called on the right hand side has no side effects.
     Risk:        The function may introduce side effects at a later time.
     Prevention:  None.

   MD_Dcm_OptimizedInlineCode_3440:
     Description: Rule 12.13
                  Result of ++ or -- operator used in expression.
     Reason:      This kind of operator is used only in case of function-like macros where also a return value is expected. Needed for maximum inlining efficiency and less other MISRA deviations.
     Risk:        The risks are at minimum since the affected locations are simple expressions.
     Prevention:  These code sections are thoroughly tested by dedicated unit tests.

   MD_Dcm_0313:
     Description: Rule 11.1
                  Conversions shall not be performed between a pointer to a function and any type other than an integral type.
     Reason:      No efficient dynamic-cast operation available in ANSI-C.
     Risk:        Data corruption due to miscast.
     Prevention:  Covered by descriptive pointer types and code review for correct usage.

   MD_Dcm_GenericStructAssign_0310:
     Description: Rule 11.4
                  A cast should not be performed between a pointer to object type and a different pointer to object type.
     Reason:      For some compilers there is a workaround that helps perform generic structure assignments. Usually this operation is left to the compiler.
     Risk:        Compile error/warnings.
     Prevention:  Compiler compatibility is tested during integration.

   MD_Dcm_DifferentPointerType_0310:
     Description: Rule 11.4
                  A cast should not be performed between a pointer to object type and a different pointer to object type.
     Reason:      To optimize access without the need of local variable, pointers to data types of the same size (uint8, sint8) will be casted to the corresponding target pointer type.
     Risk:        Compile error/warnings.
     Prevention:  Compiler compatibility is tested during integration.

   MD_Dcm_3355:
     Description: Rule 13.7
                  Boolean operations whose results are invariant shall not be permitted.
     Reason:      The expression is not invariant. Depending on supported features invariant value is possible but
                  the resulting code modification will adversely affect maintainability of already complicated code
                  paths.
     Risk:        Compile error/warnings.
     Prevention:  None.

   MD_Dcm_3356:
     Description: Rule 13.7
                  Boolean operations whose results are invariant shall not be permitted.
     Reason:      The expression is not invariant. Depending on supported features invariant value is possible but
                  the resulting code modification will adversely affect maintainability of already complicated code
                  paths.
     Risk:        Compile error/warnings.
     Prevention:  None.

   MD_Dcm_3358:
     Description: Rule 13.7
                  Boolean operations whose results are invariant shall not be permitted.
     Reason:      The expression is not invariant. Depending on supported features invariant value is possible but
                  the resulting code modification will adversely affect maintainability of already complicated code
                  paths.
     Risk:        Compile error/warnings.
     Prevention:  None.

   MD_Dcm_3360:
     Description: Rule 13.7
                  Boolean operations whose results are invariant shall not be permitted.
     Reason:      The expression is not invariant. Depending on supported features invariant value is possible but
                  the resulting code modification will adversely affect maintainability of already complicated code
                  paths.
     Risk:        Compile error/warnings.
     Prevention:  None.

   MD_Dcm_3219:
     Description: Rule 14.1
                  There shall be no unreachable code.
     Reason:      This statement is used to avoid warnings caused by APIs that are used as library functions and are
                  therefore always available.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_3112:
     Description: Rule 14.2
                  All non-null statements shall either (i) have at least one side-effect however executed, or
                  (ii) cause control flow to change.
     Reason:      This statement is used to avoid warnings caused by unused parameters. Parameters are defined by
                  standardized API requirements, and not needed in case a feature is disabled by configuration.
                  It is either impossible due to API standardization or necessary code duplication (severe maintenance
                  increase) to provide feature dependent APIs with different signatures.
     Risk:        Unavoidable compiler warning or error because of either unused statements or unused parameter.
     Prevention:  None.

   MD_Dcm_CfgDepend_3109:
     Description: Rule 14.3
                  Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a
                  comment provided that the first character following the null statement is a white-space character.
     Reason:      The statement can be empty or not - it is configuration parameter dependent.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Optimize_0771:
     Description: Rule 14.6
                  For any iteration statement there shall be at most one break statement used for loop termination.
     Reason:      The loop needs multiple exit points since error conditions cannot be verified prior to the loop.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Optimize_2006:
     Description: Rule 14.7
                  A function shall have a single point of exit at the end of the function.
     Reason:      For code run-time/ROM usage reason this function terminates immediately.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_APIStd_3673:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The API is defined by the AUTOSAR standardization.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Design_3673:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The API has to be compatible to a common prototype, defined by module's design to serve generic purposes.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_StructMemberAbstr_3410:
     Description: Rule 19.10
                  In the definition of a function-like macro each instance of a parameter shall be enclosed in
                  parentheses unless it is used as the operand of # or ##.
     Reason:      This is a special deviation in order to make dynamic structure member reference: #define a(idx, member)  (myStruct[idx].Member).
     Risk:        Compile error will occur if the macro parameter is enclosed in ().
     Prevention:  None.

   MD_Dcm_Optimize_0750:
     Description: Rule 18.4
                  Unions shall not be used
     Reason:      Data without shared lifetime is stored in union for efficiency.
     Risk:        None due to no shared lifetime.
     Prevention:  None.

  MD_Dcm_Consistency_0342:
     Description: Rule 19.13
                  The # and ## preprocessor operators should not be used.
     Reason:      Simplifies and improves the consistency on for function name convention change within AR releases.
     Risk:        If a preprocessor does not support this ISO operator, then a compile error will occur.
     Prevention:  Compiler compatibility is tested during integration.

  MD_Dcm_BitNegation_0290:
     Description: Rule 21.1
                  Minimization of run-time failures shall be ensured by the use of at least one of (a) static analysis
                  tools/techniques; (b) dynamic analysis tools/techniques; (c) explicit coding of checks to handle
                  run-time faults.
     Reason:      False positive due to insufficient data flow analysis. Despite thorough review no defect could be
                  recognized.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_BitNegation_0291:
     Description: Rule 21.1
                  Minimization of run-time failures shall be ensured by the use of at least one of (a) static analysis
                  tools/techniques; (b) dynamic analysis tools/techniques; (c) explicit coding of checks to handle
                  run-time faults.
     Reason:      False positive due to insufficient data flow analysis. Despite thorough review no defect could be
                  recognized.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_Optimize_2003:
     Description: Rule 15.2
                  The preceding non-empty 'case' or 'default' clause does not end with an explicit 'break' or 'return' statement.
     Reason:      To use optimal design small switch-case dispatchers use fall-through cases.
     Risk:        None, since documented as an explicit fall-through case.
     Prevention:  None.

  MD_Dcm_RteSpecific_1330:
     Description: Rule 16.4
                  The parameter identifiers in this function declaration differ from those in a previous declaration.
     Reason:      The function declaration generated by the RTE are RTE-implementation specific and unknown at the DCM development time.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_Design_6060:
     Description: Metric STPAR
                  Number of function parameters defined by HIS shall be in range 0..5.
     Reason:      DCM uses flyweight pattern to minimize shared resource management complexity and risks of overwritten RAM.
                  This pattern requires more input data in comparison with functions with access to global RAM.
     Risk:        Stack usage and runtime too high for target uC.
     Prevention:  Use local inline functions to minimize stack and run-time usage.
*/
/* ----------------------------------------------
 ~&&&   COVERAGE
---------------------------------------------- */
/* COV_JUSTIFICATION_BEGIN

\ID COV_DCM_MACRO_OVERRIDE
  \ACCEPT TX
  \ACCEPT XF
  \REASON The value of a macro may be overridden by user config for test purposes. Since this is not officially
          supported, it is not covered by the test suite.

\ID COV_DCM_UNSUPPORTED
  \REASON [COV_MSR_UNSUPPORTED]

\ID COV_DCM_SUPPORT_PARTIALLY
  \REASON [COV_MSR_UNSUPPORTED]

\ID COV_DCM_SUPPORT_ALWAYS
  \REASON This configuration switch is always on, but the code is enclosed in a pre-processor precondition for consistency reasons and safe future changes.

\ID COV_DCM_SUPPORT_RESTRICTED
  \REASON This configuration switch is always on/off, due to feature range limitation.

\ID COV_DCM_SUPPORT_XOR
  \REASON Disjunction of configuration switches that are mutually exclusive and one of them is always true.

\ID COV_DCM_SUPPORT_WITH_MSR_DEM
  \REASON This configuration switch is always on as long as MSR4 DEM is used (required for SafeBSW context).

\ID COV_DCM_REQUIRED_BY_SAFEBSW
  \REASON This configuration switch is always on as required by SafeBSW context.

\ID COV_DCM_DEPENDS_ON_UNSUPPORTED
  \REASON This configuration switch is always on/off due to a justified expression it is involved in.

\ID COV_DCM_DEV_DEBUG
  \REASON The justified object is uncovered, since it is only used during component development to ease the detection of errors!

\ID COV_DCM_UNSUPPORTED_ERROR_DETECTION
  \REASON The justified object is uncovered, since it is only used to ease the detection of configuration errors!

\ID COV_DCM_RTM_NO_RCR_RP_TX
  \ACCEPT XX
  \REASON The justified object is unreachable, since the configuration does not support any feature that could use it.
          A complete encapsulation of all use-cases where no RCR-RP will be sent would be too complex and risky.

\ID COV_DCM_RTM_DEV_DEBUG
  \REASON [COV_DCM_DEV_DEBUG]

\ID COV_DCM_RTM_UNREACHABLE
  \REASON The justified object is uncovered, since it is not intended to be reached! It just exists because of other reasons like MISRA (default case in a switch)
          or because of added debug assert monitoring for development purposes (see COV_DCM_RTM_DEV_DEBUG).

\ID COV_DCM_RTM_UNREACHABLE_COMPLEXITY
  \REASON The justified object is uncovered, since it can be reached only in very rare situations (i.e. interrupt, multiple events in a specific sequence, etc.)!
          But at the same time it is part of the (sub-)component design and cannot be removed.

\ID COV_DCM_RTM_DESIGN_LOWER_LAYER
  \REASON The justified object is uncovered, since it is a basic (lower layer) functionality and is designed to behave in different situations.
          These situations are not necessarily supported by all configurations. Due to the high complexity of dependent functionalities
          the concrete usage of the uncovered functionality is left to the upper layers in DCM!

\ID COV_DCM_RTM_RUNTIME_CHECK
  \REASON This condition depends on a NULL_PTR returned due to a triggered runtime check.

\ID COV_DCM_RTM_DEPENDS_ON_UNSUPPORTED
  \REASON The justified object is uncovered, since it can vary only if a specific (non supported in SafeBSW context) configuration is activated.

\ID COV_DCM_RTM_DEPENDS_ON_CFG
  \ACCEPT TX
  \ACCEPT XF
  \REASON The justified expression evaluates always depending on the configuration either to true or false.

COV_JUSTIFICATION_END */
/* ----------------------------------------------
 ~&&&   SafeBSW
---------------------------------------------- */
/* SBSW_JUSTIFICATION_BEGIN

\ID SBSW_DCM_PARAM_PTR_WRITE
  \DESCRIPTION    In a function, data is written through a pointer passed as function argument.
  \COUNTERMEASURE \N [CM_DCM_N_PASS_PARAM_PTR]

\ID SBSW_DCM_LOCAL_ARRAY_WRITE
  \DESCRIPTION    In a function, data written to an array.
  \COUNTERMEASURE \N [CM_DCM_N_ARRAY_INDEX_WRITE]

\ID SBSW_DCM_GEN_PARAM_PTR_WRITE
  \DESCRIPTION    In a generated function, called only by DCM static code, data is written through a
                  pointer passed as function argument.
  \COUNTERMEASURE \S [CM_DCM_S_GEN_PARAM_PTR_WRITE]

\ID SBSW_DCM_PARAM_PTR_FORWARD
  \DESCRIPTION    A pointer received in a function is passed to a function expecting a valid pointer.
  \COUNTERMEASURE \N [CM_DCM_N_PASS_PARAM_PTR]

\ID SBSW_DCM_GEN_PARAM_PTR_FORWARD
  \DESCRIPTION    A pointer received in a generated function, called only by DCM static code, is passed to
                  a function expecting a valid pointer.
  \COUNTERMEASURE \S [CM_DCM_S_GEN_PARAM_PTR_FORWARD]

\ID SBSW_DCM_PARAM_FUNCPTR_CALL
  \DESCRIPTION    In a function, a function pointer passed as function argument is called.
  \COUNTERMEASURE \N [CM_DCM_N_CALL_PARAM_FUNCPTR]

\ID SBSW_DCM_GLOBAL_PTR_WRITE
  \DESCRIPTION    In a function, data is written through a pointer taken from a global variable.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_POINTER_FORWARD_STACK
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer. The called function does not store its
                  pointer parameter(s).
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_GEN_POINTER_FORWARD_STACK
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer (i.e. to return data through it).
                  The called function does not store its pointer parameter(s) for deferred writing.
  \COUNTERMEASURE \S [CM_DCM_S_GEN_POINTER_FORWARD_STACK]

\ID SBSW_DCM_POINTER_FORWARD_GLOBAL
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer. The called function does not store its
                  pointer parameters.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_COMB_PTR_FORWARD
  \DESCRIPTION    A combination of pointers is passed to a function expecting valid pointers. The called function does
                  not store its pointer parameters.The pointer is taken from one of the following locations:
                     - global variable;
                     - local (stack) variable;
                     - is an argument of the caller function (refer also to CM_DCM_N_PASS_PARAM_PTR);
                     - is a pointer initialized with one of the following associated initialization function that
                       returns always a valid Pointer: Dcm_DiagGetDataContextBuffer(),
                                                       Dcm_DiagGetResData(),
                                                       Dcm_DiagGetResDataAt(),
                                                       Dcm_DiagInitDataContext(),
                                                       Dcm_DiagInitiateServiceProcessing(),
                                                       Dcm_NetGetBufferInfos(),
                                                       Dcm_NetGetTransportObject(),
                                                       Dcm_Svc22GetDidInfoContext(),
                                                       Dcm_Svc2ASchdGetEntry(),
                                                       Dcm_Svc2CGetSrcItem(),
                                                       Dcm_RepeaterGetExtSvcContext(),
                                                       Dcm_NetGetPeriodicTxObject()
                     as such it is always valid.
\COUNTERMEASURE \M [CM_DCM_M_SIZEOF_BUFFERINFO]
                \R [CM_DCM_R_GET_BUFFERINFO]
                \R [CM_DCM_R_SET_DATA_CONTEXT_USAGE]

\ID SBSW_DCM_GEN_COMB_PARAM_PTR_FORWARD
  \DESCRIPTION    A combination of pointers is passed to a function expecting valid pointers. The called function does
                  not store its pointer parameters.The pointer is taken from one of the following locations:
                     - local (stack) variable;
                     - is an argument of the caller function (refer also to CM_DCM_S_GEN_PARAM_PTR_FORWARD);
                     - is a pointer initialized with one of the following associated initialization function that
                       returns always a valid Pointer: Dcm_DiagGetResDataAt()
                     as such it is always valid.
\COUNTERMEASURE \R [CM_DCM_R_SET_MESSAGE_CONTEXT_REQBUFFER]
                \R [CM_DCM_R_SET_MESSAGE_CONTEXT_RESBUFFER]
                \S [CM_DCM_S_ROUTINE_OP_FUNC_SIGNATURE]
                \S [CM_DCM_S_ROUTINE_OP_FUNC_WRITE_DATA_LENGTH]
                \S [CM_DCM_S_ROUTINE_WRAPPER_WRITE_DATA_LENGTH]

\ID SBSW_DCM_GEN_RID_WRAPPER
  \DESCRIPTION    In a generated function, a pointer to a uint8/sint8 array routine signal is passed to a function
                  expecting a valid pointer.
  \COUNTERMEASURE \S [CM_DCM_S_ROUTINE_OP_FUNC_SIGNATURE]
                  \S [CM_DCM_S_ROUTINE_OP_FUNC_WRITE_DATA_LENGTH]
                  \S [CM_DCM_S_ROUTINE_WRAPPER_WRITE_DATA_LENGTH]

\ID SBSW_DCM_GEN_DID_WRAPPER
  \DESCRIPTION    In a generated function, a pointer to a uint8 array DID signal is passed to a function
                  expecting a valid pointer.
  \COUNTERMEASURE \S [CM_DCM_S_DID_WRAPPER_WRITE_DATA_LENGTH]
                  \S [CM_DCM_S_DID_WRAPPER_NV_BLOCK_ID_READ]
                  \S [CM_DCM_S_DID_WRAPPER_NV_BLOCK_ID_WRITE]

\ID SBSW_DCM_ROE_NV_ACCESS
  \DESCRIPTION    In a function, a pointer to a NvM data structure is passed to a function expecting valid pointers.
  \COUNTERMEASURE \S [CM_DCM_S_ROE_NV_BLOCK_ID_ACCESS]

\ID SBSW_DCM_POINTER_WRITE_BUFFERINFO
  \DESCRIPTION    In an internal function, data is written through a pointer to a buffer info element, or the
                  pointer is passed to a function expecting a valid reference to a buffer info element.
                  The memory entry pointer is initialized by Dcm_NetGetBufferInfos() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_CONSISTENCY_BUFFERINFO]
                  \M [CM_DCM_M_SIZEOF_BUFFERINFO]
                  \R [CM_DCM_R_GET_BUFFERINFO]

\ID SBSW_DCM_POINTER_WRITE_COMMCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a ComM context element, or the
                  pointer is passed to a function expecting a valid reference to a ComM context element.
                  The memory entry pointer is initialized by Dcm_NetGetComMContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_COMMCONTEXT]
                  \R [CM_DCM_R_GET_COMMCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a buffer context element, or the
                  pointer is passed to a function expecting a valid reference to a buffer context element.
                  The memory entry pointer is initialized by Dcm_NetGetBufferContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_BUFFERCONTEXT]
                  \R [CM_DCM_R_GET_BUFFERCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetGetTransportObject() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]

\ID SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_DiagGetQueuedTranspObj() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]

\ID SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetGetTranspObjOfConnectionOrNull() which will always
                  return a pointer to a valid memory entry or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TOBJ_OF_CONNECTION]

\ID SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetAllocateOrGetTranspObjectOrNull() which will always
                  return a pointer to a valid memory entry or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_ALLOCATEDTOBJ]

\ID SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetLockConnectionOrNull() which will always return a
                  pointer to a valid memory entry or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_RESERVEDTOBJ]

\ID SBSW_DCM_POINTER_WRITE_PERTXOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a periodic transport ojbect, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetGetPeriodicTxObject() which will always
                  return a pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_PERTXOBJ]
                  \R [CM_DCM_R_SET_PERTXOBJ]

\ID SBSW_DCM_POINTER_WRITE_TASKCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a task context object.
                  The memory entry pointer is initialized by Dcm_TskGetTaskContextOrNull() which will always return a
                  pointer to a valid memory entry or NULL_PTR.
  \COUNTERMEASURE \R [CM_DCM_R_GET_TASKCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_SCHEDULERCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a scheduler context object.
                  The memory entry pointer is initialized by Dcm_TskGetSchedulerContextOrNull() which will always
                  return a pointer to a valid memory entry or NULL_PTR.
  \COUNTERMEASURE \R [CM_DCM_R_GET_SCHEDULERCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_BITSET
  \DESCRIPTION    In an internal function, data is written to an array representing a bitset. The index within the
                  array is calculated by Dcm_UtiBitSetGetRowIdxSafe() which will always return a valid index within
                  the given bitset.
  \COUNTERMEASURE \R [CM_DCM_R_GET_BITSETROWINDEX]
                  \R [CM_DCM_R_BITSET_BASETYPE]

\ID SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY
  \DESCRIPTION    In an internal function, data is written through a pointer to a service 0x2A scheduler table entry, or
                  the pointer is passed to a function expecting a valid reference to a service 0x2A scheduler table
                  entry. The memory entry pointer is initialized by Dcm_Svc2ASchdGetEntry() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2ASCHEDULERENTRY]

\ID SBSW_DCM_POINTER_WRITE_2CSRCITEM
  \DESCRIPTION    In an internal function, data is written through a pointer to a service 0x2C source item, or the
                  pointer is passed to a function expecting a valid reference to a service 0x2C source item. The memory
                  entry pointer is initialized by Dcm_Svc2CGetSrcItem() which will always return a pointer to a valid
                  memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2CSRCITEM]

\ID SBSW_DCM_POINTER_WRITE_2CITEM
  \DESCRIPTION    In an internal function, data is written through a pointer to a service 0x2C item, or the pointer is
                  passed to a function expecting a valid reference to a service 0x2C item. The memory entry pointer is
                  initialized by Dcm_Svc2CGetItem() which will always return a pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2CITEM]

\ID SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a process context of a DID, or the
                  pointer is passed to a function expecting a valid reference to a process context. The memory entry
                  pointer is initialized by Dcm_Svc2CGetDDDidProcessContext() which will always return a pointer to a
                  valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2CPROCESSCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_2FACTIVEIODIDS
  \DESCRIPTION    In an internal function, data is written through a pointer to a bitmask of active IODIDs, or the
                  pointer is passed to a function expecting a valid reference to a bitmask of active IODIDs. The memory
                  entry pointer is initialized by Dcm_Svc2FGetActiveIoDids() which will always return a pointer to a
                  valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2FACTIVEIODIDS]

\ID SBSW_DCM_POINTER_WRITE_VSGACTIVECFGVARIANTS
  \DESCRIPTION    In an internal function, data is written to the array Dcm_SingletonContext.VarMgr.ActiveCfgVariants[]
                  using an iterator.
  \COUNTERMEASURE \R [CM_DCM_R_GET_VSGACTIVECFGVARIANTS]

\ID SBSW_DCM_POINTER_WRITE_PERIODICTXBUFFER
  \DESCRIPTION    In an internal function, data is written through a pointer to the tx buffer of a periodic message, or
                  the pointer is passed to a function expecting a valid reference to the tx buffer of a periodic
                  message. The memory entry pointer is initialized by Dcm_NetPeriodicMsgGetTxBuffer() which will always
                  return a pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_PERIODICTXBUFFER]

\ID SBSW_DCM_POINTER_WRITE_RXPDUINFO
  \DESCRIPTION    In an internal function, data is written through a pointer to a Rx-PduInfo, or the
                  pointer is passed to a function expecting a valid reference to a Rx-PduInfo element.
                  The memory entry pointer is initialized by Dcm_NetProvideRxBuffer() which will always return a
                  pointer to a valid memory entry if the return values is BUFREQ_OK.
  \COUNTERMEASURE \R [CM_DCM_R_GET_RXPDUINFO]

\ID SBSW_DCM_POINTER_WRITE_DIDINFOCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a Did info context, or the
                  pointer is passed to a function expecting a valid reference to a Did info context.
                  The memory entry pointer is initialized by Dcm_Svc22GetDidInfoContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_DIDINFOCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_EXTSVCCONTEXT
  \DESCRIPTION    In an internal function, data are written through a pointer to an extension service context,
                  or the pointer is passed to a function expecting a valid reference to an extension service context.
                  The memory entry pointer is initialized by Dcm_RepeaterGetExtSvcContext() whill will always return
                  a pointer to a valid memeory entry for service 0x86.
  \COUNTERMEASURE \N Dcm_RepeaterGetExtSvcContext will always return a valid extension service context for service 0x86.

\ID SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT
  \DESCRIPTION    The global message context variable is passed to Dcm_DiagInitiateServiceProcessing() for
                  initialization. That initalization function ensures that all pointer members are pointing to valid
                  memory entry pointer and the corresponding buffer size members are matching to the pointed memory
                  entry sizes.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_REQBUFFER
  \DESCRIPTION    In an internal function, data is written through a pointer to a message context request buffer,
                  or the pointer is passed to a function expecting a valid reference to a message context
                  request buffer. The caller ensures that the reqData member points to a valid memory entry pointer
                  and the reqBufSize member matches to the pointed memory entry size.
  \COUNTERMEASURE \R [CM_DCM_R_SET_MESSAGE_CONTEXT_REQBUFFER]

\ID SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_RESBUFFER
  \DESCRIPTION    In an internal function, data is written through a pointer to a message context response buffer,
                  or the pointer is passed to a function expecting a valid reference to a message context
                  response buffer. The caller ensures that the resData member points to a valid memory entry pointer
                  and the resBufSize member matches to the pointed memory entry size.
  \COUNTERMEASURE \R [CM_DCM_R_SET_MESSAGE_CONTEXT_RESBUFFER]

\ID SBSW_DCM_POINTER_WRITE_IO_CTRL_CEMR_SESSION_MASK
  \DESCRIPTION    In an internal function, data is written through a pointer to an IO control CEMR session mask, or the
                  pointer is passed to a function expecting a valid reference to an IO control CEMR session mask.
  \COUNTERMEASURE \R [CM_DCM_R_WRITE_IO_CTRL_CEMR_SESSION_MASK]

\ID SBSW_DCM_POINTER_WRITE_RECOVERYINFOCOMMCHANNELSTATE
  \DESCRIPTION    In an internal function, data is written through a pointer to a ComM channel state of the recovery
                  info, or the pointer is passed to a function expecting a valid reference to a ComM channel state of
                  the recovery info. The memory entry pointer is initialized by
                  Dcm_DiagGetRecoveryInfoComMChannelState() which will always return a pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_RECOVERYINFOCOMMCHANNELSTATE]

\ID SBSW_DCM_POINTER_WRITE_RECOVERYINFOCOMMCONTROLSTATE
  \DESCRIPTION    In an internal function, data is written through a pointer to the communication state of a ComM
                  channel of the recovery info, or the pointer is passed to a function expecting a valid reference to
                  the communication state of a ComM channel of the recovery info. The memory entry pointer is
                  initialized by Dcm_DiagGetRecoveryInfoCommControlState() which will always return a pointer to a
                  valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_RECOVERYINFOCOMMCONTROLSTATE]

\ID SBSW_DCM_POINTER_WRITE_UTI_STRUCT
  \DESCRIPTION    In a macro, data of a struct is written via direct struct assignment and the compiler ensures the
                  correct number of bytes to be written or the data of a struct is written through a pointer to an
                  array. Then the number of bytes to write is initialized by sizeOf(struct) which will always return
                  the right length of the array.
  \COUNTERMEASURE \R [CM_DCM_R_SET_UTI_STRUCT]

\ID SBSW_DCM_POINTER_INIT_DATA_CONTEXT
  \DESCRIPTION    The data context pointer is locally allocated and passed to Dcm_DiagInitDataContext() for
                  initialization. The caller ensures that the passed buffer pointer points to a valid memory entry
                  pointer and the passed buffer size matches to the pointed memory entry size.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_DATA_CONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a data context, or the
                  pointer is passed to a function expecting a valid reference to a data context.
                  The pointer is initialized by Dcm_DiagInitDataContext(), which will always initialize it to point
                  to a valid memory entry. A data context ensures that the sum of Usage and AvailLen member is always
                  equal to or smaller than the referenced buffer size.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DATA_CONTEXT_BUFFER]
                  \R [CM_DCM_R_SET_DATA_CONTEXT_USAGE]

\ID SBSW_DCM_POINTER_MEMCPY_BUFFER
  \DESCRIPTION    In an internal function, data is copied into a buffer through a pointer using memcpy, or the
                  buffer pointer with the appropriate buffer size are passed to a function expecting a valid pair
                  of buffer pointer and buffer size.
  \COUNTERMEASURE \R [CM_DCM_R_MEMCPY_PASS_BUFFER]
                  \R [CM_DCM_R_MEMCPY_WRITE]

\ID SBSW_DCM_CALL_FUNCPTR_TASKINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_TskGetTaskInfoOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \R [CM_DCM_R_GET_TASKINFO]

\ID SBSW_DCM_CALL_FUNCPTR_TIMERINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_TmrGetTimerInfoOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \R [CM_DCM_R_GET_TIMERINFO]

\ID SBSW_DCM_CALL_FUNCPTR_SVCPOSTPROCESSORS
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_DiagGetPostProcessorFunc() which will always return a valid function pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVCPOSTPROCESSORS]
                  \R [CM_DCM_R_GET_SVCPOSTPROCESSORS]

\ID SBSW_DCM_CALL_FUNCPTR_SVCUPDATERS
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_DiagGetUpdateFunc() which will always return a valid function pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVCUPDATERS]
                  \R [CM_DCM_R_GET_SVCUPDATERS]

\ID SBSW_DCM_CALL_FUNCPTR_SVCCANCELLERS
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_DiagGetCancelFunc() which will always return a valid function pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVCCANCELLERS]
                  \R [CM_DCM_R_GET_SVCCANCELLERS]

\ID SBSW_DCM_CALL_FUNCPTR_MODEMGRRULES
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgModeMgrRulesGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_MODEMGRRULES]
                  \R [CM_DCM_R_GET_MODEMGRRULES]

\ID SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST
  \DESCRIPTION    In an internal function, iteration over all elements of a given table is done.
                  Each element is a function pointer or a structure containing only function pointer members.
                  The end of iteration is marked by NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_TERMINATED_LIST]
                  \R [CM_DCM_R_TERMINATED_LIST]

\ID SBSW_DCM_POINTER_WRITE_TOBJ_ADDBUFFER
  \DESCRIPTION    In an internal function, data is written to array AddBuffer[] of a specific transport object using a
                  function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_TOBJ_ADDBUFFER]

\ID SBSW_DCM_POINTER_WRITE_COMCONTROLCHANNEL
  \DESCRIPTION    In an internal function, data is written to array Dcm_PbRamNetComCtrlChannels[] using a
                  function argument as index.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_COMCONTROLCHANNEL]
                  \R [CM_DCM_R_SET_COMCONTROLCHANNEL]

\ID SBSW_DCM_POINTER_WRITE_TOBJHANDLE
  \DESCRIPTION    In an internal function, data is written to array Dcm_PbRamNetConnId2TObjMap[] using a
                  function argument as index.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TOBJHANDLE]
                  \R [CM_DCM_R_SET_TOBJHANDLE]

\ID SBSW_DCM_POINTER_WRITE_DELAYTIMER
  \DESCRIPTION    In an internal function, data is written to array
                  Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DELAYTIMER]

\ID SBSW_DCM_POINTER_WRITE_TIMER
  \DESCRIPTION    In an internal function, data is written to array Dcm_SingletonContext.TimerMgr.Timer[] using a
                  function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_TIMER]

\ID SBSW_DCM_POINTER_WRITE_START_UP_FBL_RES_BUFFER
  \DESCRIPTION    In an internal function, data is written to array Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[]
                  using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_START_UP_FBL_RES_BUFFER]

\ID SBSW_DCM_POINTER_WRITE_CURRENT_TASK_PRIO_STACK
  \DESCRIPTION    In an internal function, data is written to array CurrentTaskPrioStack.Stack[] using a
                  function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_CURRENT_TASK_PRIO_STACK]

\ID SBSW_DCM_POINTER_WRITE_ATTEMPTCOUNT
  \DESCRIPTION    In an internal function, data is written to array
                  Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_ATTEMPTCOUNT]

\ID SBSW_DCM_POINTER_WRITE_DELAYTIME
  \DESCRIPTION    In an internal function, data is written to array Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[]
                  using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DELAYTIME]

\ID SBSW_DCM_POINTER_WRITE_DIDLOCKLIST
  \DESCRIPTION    In an internal function, data is written to array Dcm_InstanceContext.DidMgr.DidLockList[] using a
                  loop iterator as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DIDLOCKLIST]

\ID SBSW_DCM_CALL_FUNCPTR_SVC11SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc11SubFuncInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC11SUBFUNC]
                  \R [CM_DCM_R_GET_SVC11SUBFUNC]

\ID SBSW_DCM_CALL_FUNCPTR_SVC19SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc19SubFuncInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC19SUBFUNC]
                  \R [CM_DCM_R_GET_SVC19SUBFUNC]

\ID SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull() which will always return a valid function pointer or
                  NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_DIDMGROPFUNC]
                  \R [CM_DCM_R_GET_DIDMGROPFUNC]
                  \S [CM_DCM_S_DIDMGR_OP_FUNC_SIGNATURE]
                  \S [CM_DCM_S_DIDMGR_OP_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry() which will always return a valid function
                  pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_IOCTRLSRHANDLERS]

\ID SBSW_DCM_CALL_FUNCPTR_SVC27SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc27SubFuncInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC27SUBFUNC]
                  \R [CM_DCM_R_GET_SVC27SUBFUNC]

\ID SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc27SecLevelInfoGetEntryOrNull() which will always return a valid function pointer or
                  NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC27SECLEVEL]
                  \R [CM_DCM_R_GET_SVC27SECLEVEL]

\ID SBSW_DCM_CALL_FUNCPTR_SVC27GETSEED
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc27SecLevelInfoGetEntryOrNull() which will always return a valid function pointer or
                  NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC27SECLEVEL]
                  \R [CM_DCM_R_GET_SVC27SECLEVEL]
                  \S [CM_DCM_S_GET_SEED_FUNC_SIGNATURE]
                  \S [CM_DCM_S_GET_SEED_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgRidMgrOpInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC31OPFUNC]
                  \R [CM_DCM_R_GET_SVC31OPFUNC]
                  \S [CM_DCM_S_ROUTINE_OP_FUNC_SIGNATURE]
                  \S [CM_DCM_S_ROUTINE_OP_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC28SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc28SubFuncInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC28SUBFUNC]
                  \R [CM_DCM_R_GET_SVC28SUBFUNC]

\ID SBSW_DCM_CALL_FUNCPTR_SVC2CSUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc2CSubFuncInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC2CSUBFUNC]
                  \R [CM_DCM_R_GET_SVC2CSUBFUNC]

\ID SBSW_DCM_CALL_FUNCPTR_SVC85SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc85SubFuncInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC85SUBFUNC]
                  \R [CM_DCM_R_GET_SVC85SUBFUNC]

\ID SBSW_DCM_CALL_FUNCPTR_SVC86SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc86SubFuncInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC86SUBFUNC]
                  \R [CM_DCM_R_GET_SVC86SUBFUNC]

\ID SBSW_DCM_CALL_FUNCPTR_ROEMODESWITCH
  \DESCRIPTION    In an internal function, a function pointer is called. The index to the called function pointer
                  is a function argument.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_ROEEVENTMODESWITCHINFO]
                  \R [CM_DCM_R_GET_ROEEVENTMODESWITCHINFO]

\ID SBSW_DCM_CALL_FUNCPTR_SERVICEINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgDiagServiceInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SERVICEINFO]
                  \R [CM_DCM_R_GET_SERVICEINFO]

\ID SBSW_DCM_CALL_READMEMORY
  \DESCRIPTION    The callout Dcm_ReadMemory uses a write-able pointer of the DCM buffer, which is always valid. The
                  application always writes as many data as the caller expects.
  \COUNTERMEASURE \S [CM_DCM_S_READMEMORY_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC01SERVICEINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc01ServiceInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC01SERVICEINFO]
                  \R [CM_DCM_R_GET_SVC01SERVICEINFO]
                  \S [CM_DCM_S_GET_SVC01SERVICEINFO_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC08SERVICEINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc08ServiceInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC08SERVICEINFO]
                  \R [CM_DCM_R_GET_SVC08SERVICEINFO]
                  \S [CM_DCM_S_GET_SVC08SERVICEINFO_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC09SERVICEINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc09ServiceInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC09SERVICEINFO]
                  \R [CM_DCM_R_GET_SVC09SERVICEINFO]
                  \S [CM_DCM_S_GET_SVC09SERVICEINFO_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC06MIDTIDINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc06MidTidInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC06MIDTIDINFO]
                  \R [CM_DCM_R_GET_SVC06MIDTIDINFO]

SBSW_JUSTIFICATION_END */

/*
\CM CM_DCM_N_PASS_PARAM_PTR
  The caller ensures the pointers passed to this function are valid.

\CM CM_DCM_N_ARRAY_INDEX_WRITE
  The function insures calculating the correct array size and writing in an array index within the array index limit.

\CM CM_DCM_S_GEN_PARAM_PTR_WRITE
  Verify that the generated function does not modify the pointer passed as an argument, but only writes a new value.
  SMI-37386

\CM CM_DCM_S_GEN_PARAM_PTR_FORWARD
  Verify that the generated function does not modify the pointer passed as an argument, but only forwards it.
  SMI-37387

\CM CM_DCM_S_GEN_POINTER_FORWARD_STACK
  Verify that the generated function does not modify the pointer, taken from a local variable,
  and that the function receiving those pointer parameter(s) does not store the adresses after return.
  SMI-37386

\CM CM_DCM_S_DIDMGR_OP_FUNC_SIGNATURE
  Verify that the generated OpFunc functions match the signatures expected by the DCM.
  SMI-106112, SMI-117436, SMI-126353, SMI-163630

\CM CM_DCM_S_GET_SEED_FUNC_SIGNATURE
  Verify that the generated GetSeed functions match the signatures expected by the DCM.
  SMI-40607

\CM CM_DCM_S_GET_SEED_FUNC_WRITE_DATA_LENGTH
  Verify that the generated GetSeed functions do not write more data than specified by SeedResLength parameter.
  SMI-49478

\CM CM_DCM_S_ROUTINE_OP_FUNC_SIGNATURE
  Verify that the generated OpFunc functions match the signatures expected by the DCM.
  SMI-64952

\CM CM_DCM_S_ROUTINE_OP_FUNC_WRITE_DATA_LENGTH
  Verify that for generated OpFunc functions with array signals the offset plus array size must not be larger than
  specified by ResMaxLength parameter.
  SMI-64953

\CM CM_DCM_S_ROUTINE_WRAPPER_WRITE_DATA_LENGTH
  Verify that for generated OpFunc function definitions, the offset plus array size of each array OUT-signal must not be
  larger than specified by ResMaxLength parameter.
  SMI-65597

\CM CM_DCM_S_DID_WRAPPER_WRITE_DATA_LENGTH
  Verify that for generated OpFunc function definitions, the offset plus array size of the array OUT-signal must not be
  larger than specified by MaxLength parameter.
  SMI-105069

\CM CM_DCM_S_DID_WRAPPER_NV_BLOCK_ID_READ
  Verify that for generated OpFunc function definitions using a NV Block ID, the NV Block ID passed to function
  Dcm_DidMgrNvMReadSignal() is valid.
  SMI-106815, SMI-106816

\CM CM_DCM_S_DID_WRAPPER_NV_BLOCK_ID_WRITE
  Verify that for generated OpFunc function definitions using a NV Block ID, the NV Block ID passed to function
  Dcm_DidMgrNvMWriteSignal() is valid.
  SMI-117437, SMI-117438

\CM CM_DCM_S_ROE_NV_BLOCK_ID_ACCESS
  Verify that in the function Dcm_ExtSvc86UpdateNvM(), the NV Block ID passed to the function Dcm_UtiNvMWrite() is valid
  and in the function Dcm_ExtSvc86Task(), the NV Block ID passed to the function Dcm_UtiNvMRead() is valid.
  SMI-163518, SMI-163519

\CM CM_DCM_S_READMEMORY_FUNC_WRITE_DATA_LENGTH
  Verify that the implementation of Dcm_ReadMemory, will write no more data as specified by MemorySize parameter.
  SMI-74833

\CM CM_DCM_S_DIDMGR_OP_FUNC_WRITE_DATA_LENGTH
  Verify that the generated OpFunc functions do not write more data than specified by MaxLength parameter.
  SMI-105069, SMI-105312

\CM CM_DCM_S_GET_SVC01SERVICEINFO_WRITE_DATA_LENGTH
  Verify that the generated OpFunc functions do not write more data than specified by ResLength parameter.
  SMI-147940

\CM CM_DCM_S_GET_SVC08SERVICEINFO_WRITE_DATA_LENGTH
  Verify that the generated OpFunc functions do not write more data than specified by ResLength parameter.
  SMI-143395

\CM CM_DCM_S_GET_SVC09SERVICEINFO_WRITE_DATA_LENGTH
  Verify that the generated OpFunc functions do not write more data than specified by ResLength parameter.
  SMI-147938

\CM CM_DCM_N_CALL_PARAM_FUNCPTR
  The caller ensures the pointers passed to this function are valid.

\CM CM_DCM_M_DEV_ERROR_DETECT
  Verify that development error detection is active in the configuration.

\CM CM_DCM_M_CONSISTENCY_BUFFERINFO
  Verify for each element in Dcm_CfgNetBufferInfo[] that the member 'Size' matches to the size of the array the
  member 'BufferPtr' is pointing to.

\CM CM_DCM_M_SIZEOF_BUFFERINFO
  Verify Dcm_PbCfgNetBufferInfo[] is defined for each id in range [0..Dcm_PbCfgNetNumBuffers[.

\CM CM_DCM_M_SIZEOF_COMMCONTEXT
  Verify Dcm_PbRamNetComMContext[] is defined for each id in range [0..Dcm_PbCfgNetNumComMChannels[.

\CM CM_DCM_M_SIZEOF_BUFFERCONTEXT
  Verify Dcm_PbRamNetBufferContext[] is defined for each id in range [0..Dcm_PbCfgNetNumBuffers[.

\CM CM_DCM_M_SIZEOF_TRANSPORTOBJECT
  Verify Dcm_PbRamNetTransportObject[] is defined for each id in range [0..Dcm_PbCfgNetNumTransportObjects[.

\CM CM_DCM_M_SIZEOF_COMCONTROLCHANNEL
  Verify Dcm_PbRamNetComCtrlChannels[] is defined for each id in range [0..Dcm_PbCfgNetNumComMChannels[.

\CM CM_DCM_M_SIZEOF_TOBJHANDLE
  Verify Dcm_PbRamNetConnId2TObjMap[] is defined for each id in range [0..Dcm_PbCfgNetNumConnections[.

\CM CM_DCM_M_SIZEOF_PERTXOBJ
  Verify Dcm_PbRamNetPeriodicTxObject[] is defined for each id in range [0..Dcm_PbCfgNetNumPerTxObjects[.

\CM CM_DCM_M_SIZEOF_SVCPOSTPROCESSORS
  Verify Dcm_CfgDiagSvcPostProcessors[] is defined for each id in range [0..DCM_CFGDIAGSVCPOSTPROCESSORS_SIZE[.

\CM CM_DCM_M_SIZEOF_SVCUPDATERS
  Verify Dcm_CfgDiagSvcUpdaters[] is defined for each id in range [0..DCM_CFGDIAGSVCUPDATERS_SIZE[.

\CM CM_DCM_M_SIZEOF_SVCCANCELLERS
  Verify Dcm_CfgDiagSvcCancellers[] is defined for each id in range [0..DCM_CFGDIAGSVCCANCELLERS_SIZE[.

\CM CM_DCM_M_SIZEOF_MODEMGRRULES
  Verify Dcm_CfgModeMgrRulesGetEntryOrNull[] is defined for each id in range [0..DCM_CFGMODEMGRRULES_SIZE[.

\CM CM_DCM_M_TERMINATED_LIST
  Verify that the last element of the given table is a NULL_PTR.

\CM CM_DCM_M_SIZEOF_SVC11SUBFUNC
  Verify Dcm_CfgSvc11SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC11SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC19SUBFUNC
  Verify Dcm_CfgSvc19SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC19SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_DIDMGROPFUNC
  Verify Dcm_CfgDidMgrSignalOpClassInfo[] is defined for each id in range [0..DCM_CFGDIDMGRSIGNALOPCLASSINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_IOCTRLSRHANDLERS
  Verify Dcm_CfgDidMgr_IOControlSenderReceiverHandlers[] is defined for each id in range
  [0..DCM_CFGDIDMGR_IOCONTROLSENDERRECEIVERHANDLERS_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC27SUBFUNC
  Verify Dcm_CfgSvc27SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC27SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC27SECLEVEL
  Verify Dcm_CfgSvc27SecLevelInfo[] is defined for each id in range [0..DCM_CFGSVC27SECLEVELINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC31OPFUNC
  Verify Dcm_CfgRidMgrOpInfo[] is defined for each id in range [0..DCM_CFGRIDMGROPINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC28SUBFUNC
  Verify Dcm_CfgSvc28SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC28SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC2CSUBFUNC
  Verify Dcm_CfgSvc2CSubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC2CSUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC85SUBFUNC
  Verify Dcm_CfgSvc85SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC85SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC86SUBFUNC
  Verify Dcm_CfgSvc86SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC86SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_ROEEVENTMODESWITCHINFO
  Verify Dcm_CfgModeRoEEventModeSwitchInfoTable[] is defined for each id in range [0..DCM_CFGMODEROEEVENTMODESWITCHINFOTABLE_SIZE[.

\CM CM_DCM_M_SIZEOF_SERVICEINFO
  Verify Dcm_CfgDiagServiceInfo[] is defined for each id in range [0..DCM_CFGDIAGSERVICEINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC01SERVICEINFO
  Verify Dcm_CfgSvc01ServiceInfoTable[] is defined for each id in range [0..DCM_CFGSVC01SERVICEINFOTABLE_SIZE[.

 \CM CM_DCM_M_SIZEOF_SVC06MIDTIDINFO
  Verify Dcm_CfgSvc06MidTidInfoTable[] is defined for each id in range [0..DCM_CFGSVC06MIDTIDINFOTABLE_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC08SERVICEINFO
  Verify Dcm_CfgSvc08ServiceInfoTable[] is defined for each id in range [0..DCM_CFGSVC08SERVICEINFOTABLE_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC09SERVICEINFO
  Verify Dcm_CfgSvc09ServiceInfoTable[] is defined for each id in range [0..DCM_CFGSVC09SERVICEINFOTABLE_SIZE[.

\CM CM_DCM_R_CHECK_REMAINING_BUFFER
  Before writing data to a buffer, check that the buffer is large enough for the data written to it.

\CM CM_DCM_R_GET_BUFFERINFO
  Dcm_NetGetBufferInfo() will always return a valid buffer info element even when the passed memory index is
  not a handle to a buffer info element.

\CM CM_DCM_R_GET_COMMCONTEXT
  Dcm_NetGetComMContext() will always return a valid ComM context element even when the passed memory index is
  not a handle to a ComM context element.

\CM CM_DCM_R_GET_BUFFERCONTEXT
  Dcm_NetGetBufferContext() will always return a valid buffer context element even when the passed memory index is
  not a handle to a buffer context element.

\CM CM_DCM_R_GET_TRANSPORTOBJECT
  Dcm_NetGetTransportObject() will always return a valid transport object even when the passed memory index is
  not a handle to a transport object.

\CM CM_DCM_R_GET_TOBJ_OF_CONNECTION
  Dcm_NetGetTranspObjOfConnectionOrNull() will return a valid transport object or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_ALLOCATEDTOBJ
  Dcm_NetAllocateOrGetTranspObjectOrNull() will return a valid transport object or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_RESERVEDTOBJ
  Dcm_NetLockConnectionOrNull() will return a valid transport object or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_TASKCONTEXT
  Dcm_TskGetTaskContextOrNull() will return a valid task context or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it, unless
  when it can be guaranteed that the passed memory index is valid.

\CM CM_DCM_R_GET_SCHEDULERCONTEXT
  Dcm_TskGetSchedulerContextOrNull() will return a valid scheduler context or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_BITSETROWINDEX
  Dcm_UtiBitSetGetRowIdxSafe() will return a index within the given bitset array, even when the passed bit position is
  not within the bitset.

\CM CM_DCM_R_BITSET_BASETYPE
  Verify that the base type passed to the bitset manipulation macro matches the base type of the respective bitset
  array.

\CM CM_DCM_R_GET_2ASCHEDULERENTRY
  Dcm_Svc2ASchdGetEntry() will return a valid entry of the 0x2A scheduler table, even when the passed memory index is
  not a handle to a scheduler table entry.

\CM CM_DCM_R_GET_2CSRCITEM
  Dcm_Svc2CGetSrcItem() will return a valid entry of the 0x2C source item table, even when the passed memory index is
  not a handle to a source item table entry.

\CM CM_DCM_R_GET_2CITEM
  Dcm_Svc2CGetItem() will return a valid entry of the 0x2C item table, even when the passed memory index is not a handle
  to an item table entry.

\CM CM_DCM_R_GET_2CPROCESSCONTEXT
  Dcm_Svc2CGetDDDidProcessContext() will return a valid process context of a DID, even when the passed memory index is
  not a handle to a process context.

\CM CM_DCM_R_GET_2FACTIVEIODIDS
  Dcm_Svc2FGetActiveIoDids() will return a valid bitmask of active IODIDs, even when the passed memory index is not a
  handle to a bitmask of active IODIDs.

\CM CM_DCM_R_GET_VSGACTIVECFGVARIANTS
 Verify that the array index is in range before writing to Dcm_SingletonContext.VarMgr.ActiveCfgVariants[].

\CM CM_DCM_R_GET_PERIODICTXBUFFER
  Dcm_NetPeriodicMsgGetTxBuffer() will return a valid tx buffer of a periodic message, even when the passed memory index
  is not a handle to a periodic tx object.

\CM CM_DCM_R_GET_RXPDUINFO
  Verify that the local pointer initialized as a NULL_PTR is set after calling Dcm_NetProvideRxBuffer().

\CM CM_DCM_R_GET_TASKINFO
  Dcm_TskGetTaskInfoOrNull() will return a valid task info or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it, unless
  when it can be guaranteed that the passed memory index is valid.

\CM CM_DCM_R_GET_SVC11SUBFUNC
  Dcm_CfgSvc11SubFuncInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC19SUBFUNC
  Dcm_CfgSvc19SubFuncInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_DIDMGROPFUNC
  Dcm_CfgDidMgrSignalOpClassInfoGetEntryOrNull() will return a valid pointer or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC27SUBFUNC
  Dcm_CfgSvc27SubFuncInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC27SECLEVEL
  Dcm_CfgSvc27SecLevelInfoGetEntryOrNull() will return a valid security level info or NULL_PTR. Therefore the caller
  must explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC31OPFUNC
  Dcm_CfgRidMgrOpInfoGetEntryOrNull() will return a valid pointer or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC28SUBFUNC
  Dcm_CfgSvc28SubFuncInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC2CSUBFUNC
  Dcm_CfgSvc2CSubFuncInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC85SUBFUNC
  Dcm_CfgSvc85SubFuncInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC86SUBFUNC
  Dcm_CfgSvc86SubFuncInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SERVICEINFO
  Dcm_CfgDiagServiceInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC01SERVICEINFO
  Dcm_CfgSvc01ServiceInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC08SERVICEINFO
  Dcm_CfgSvc08ServiceInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC09SERVICEINFO
  Dcm_CfgSvc09ServiceInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_TIMERINFO
  Dcm_TmrGetTimerInfoOrNull() will always return a valid task info even when the passed memory index is
  not a handle to a timer info.

\CM CM_DCM_R_GET_SVCPOSTPROCESSORS
  Dcm_DiagGetPostProcessorFunc() will always return a valid function pointer even when the passed memory index is
  not a handle to a post-processor function.

\CM CM_DCM_R_GET_SVCUPDATERS
  Dcm_DiagGetUpdateFunc() will always return a valid function pointer even when the passed memory index is
  not a handle to an update function.

\CM CM_DCM_R_GET_SVCCANCELLERS
  Dcm_DiagGetCancelFunc() will always return a valid function pointer even when the passed memory index is
  not a handle to a cancellation function.

\CM CM_DCM_R_GET_MODEMGRRULES
  Dcm_CfgModeMgrRulesGetEntryOrNull() will return a valid function pointer if the passed memory index is a valid one
  or NULL_PTR if not. Therefore the caller must explicitly verify that the retrieved function pointer is unequal
  to NULL_PTR before calling it.

\CM CM_DCM_R_TERMINATED_LIST
  The for loop ensures that the index never exceeds the size of the given table.

\CM CM_DCM_R_SET_TOBJ_ADDBUFFER
  Verify that the array index is in range before writing to AddBfufer[] of a specific transport object.

\CM CM_DCM_R_SET_COMCONTROLCHANNEL
  Verify that the array index is in range before writing to Dcm_PbRamNetComCtrlChannels[].

\CM CM_DCM_R_SET_TOBJHANDLE
  Verify that the array index is in range before writing to Dcm_PbRamNetConnId2TObjMap[].

\CM CM_DCM_R_SET_TIMER
  Verify that the array index is in range before writing to Dcm_SingletonContext.TimerMgr.Timer[].

\CM CM_DCM_R_SET_START_UP_FBL_RES_BUFFER
  Verify that the array index is in range before writing to Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[].

\CM CM_DCM_R_SET_CURRENT_TASK_PRIO_STACK
  Verify that the array index is in range before writing to CurrentTaskPrioStack.Stack[].

\CM CM_DCM_R_SET_ATTEMPTCOUNT
  Verify that the array index is in range before writing to Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[].

\CM CM_DCM_R_SET_DELAYTIME
  Verify that the array index is in range before writing to Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[].

\CM CM_DCM_R_SET_DIDLOCKLIST
  Verify that the array index is in range before writing to Dcm_InstanceContext.DidMgr.DidLockList[].

\CM CM_DCM_R_SET_PERTXOBJ
  Verify that the array index is in range before writing to Dcm_PbRamNetPeriodicTxObject[].

\CM CM_DCM_R_SET_DELAYTIMER
  Verify that the array index is in range before writing to Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[].

\CM CM_DCM_R_SET_DATA_CONTEXT_BUFFER
  Verify that the array index is in range [0..pDataContext->Size[ before writing to pDataContext->Buffer.

\CM CM_DCM_R_SET_MESSAGE_CONTEXT_RESBUFFER
  Verify that the array index is in range [0..pMsgContext->resBufSize[ before writing to pMsgContext->resData.

\CM CM_DCM_R_WRITE_IO_CTRL_CEMR_SESSION_MASK
  Verify that the write access to the bitmask Dcm_InstanceContext.DidMgr.IoControlCemrSessionMask does not exceed its
  size (DCM_DIDMGR_IODID_MAX_EXT_CEMR_SIZE).

\CM CM_DCM_R_SET_MESSAGE_CONTEXT_REQBUFFER
  Verify that the array index is in range [0..pMsgContext->reqBufSize[ before writing to pMsgContext->reqData.

\CM CM_DCM_R_SET_DATA_CONTEXT_USAGE
  Verify that the sum of pDataContext->Usage and pDataContext->AvailLen is always equal to or smaller as
  pDataContext->Size.

\CM CM_DCM_R_SET_UTI_STRUCT
  The for loop of Dcm_UtiMemCopy() ensures that the index never exceeds the size of the array.

\CM CM_DCM_R_MEMCPY_PASS_BUFFER
  Verify that the passed pair of buffer pointer and buffer size matches to referenced memory entry and memory size.

\CM CM_DCM_R_MEMCPY_WRITE
  Verify that the array index is in range between 0 and the passed buffer size before writing to the passed
  buffer pointer.

\CM CM_DCM_R_GET_SVC06MIDTIDINFO
  Dcm_CfgSvc06MidTidInfoGetEntryOrNull() will return a valid pointer or NULL_PTR. Therefore the caller must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_DIDINFOCONTEXT
  Dcm_Svc22GetDidInfoContext() will always return a valid Did info context even when the passed memory index is
  not a handle to a Did info context.

\CM CM_DCM_R_GET_ROEEVENTMODESWITCHINFO
  Verify that the array index is in range before getting the mode switch function from Dcm_CfgModeRoEEventModeSwitchInfoTable[].

\CM CM_DCM_R_GET_RECOVERYINFOCOMMCHANNELSTATE
  Dcm_DiagGetRecoveryInfoComMChannelState() will return a valid ComM channel state of the recovery info, even when the
  passed memory index is not a handle to a ComM channel state of the recovery info.

\CM CM_DCM_R_GET_RECOVERYINFOCOMMCONTROLSTATE
  Dcm_DiagGetRecoveryInfoCommControlState() will return a valid communication state of a ComM channel of the recovery
  info, even when the passed memory index is not a handle to a communication state of a ComM channel of the recovery
  info.

*/
/* ********************************************************************************************************************
 * END OF FILE: Dcm.c
 * ******************************************************************************************************************** */
